{
  "address": "0xef54dB43b6b7a28A26041577716b1aD5F78f699E",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtPriceX96",
          "type": "uint160"
        }
      ],
      "name": "IllegalSqrtPrice",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "y_target",
          "type": "uint256"
        },
        {
          "internalType": "uint160",
          "name": "x_lower",
          "type": "uint160"
        },
        {
          "internalType": "uint160",
          "name": "x_upper",
          "type": "uint160"
        }
      ],
      "name": "SolutionOutOfBounds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "getTwapPriceX128",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "getTwapSqrtPriceX96",
      "outputs": [
        {
          "internalType": "uint160",
          "name": "sqrtPriceX96",
          "type": "uint160"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_priceX128",
          "type": "uint256"
        }
      ],
      "name": "setPriceX128",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "_sqrtPriceX96",
          "type": "uint160"
        }
      ],
      "name": "setSqrtPriceX96",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x07289744690483490027f9309891093727956b436416600a643adcf30ccd2d35",
  "receipt": {
    "to": null,
    "from": "0x4ec0dda0430A54b4796109913545F715B2d89F34",
    "contractAddress": "0xef54dB43b6b7a28A26041577716b1aD5F78f699E",
    "transactionIndex": 23,
    "gasUsed": "338043",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe45f478de487790d36e61036aab2d926fa9d7cfccb9e6e7720fac217a68f77d3",
    "transactionHash": "0x07289744690483490027f9309891093727956b436416600a643adcf30ccd2d35",
    "logs": [],
    "blockNumber": 10493619,
    "cumulativeGasUsed": "8805929",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "acad56d9e6b4e961725cfa8553c86ccb",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"}],\"name\":\"IllegalSqrtPrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"y_target\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"x_lower\",\"type\":\"uint160\"},{\"internalType\":\"uint160\",\"name\":\"x_upper\",\"type\":\"uint160\"}],\"name\":\"SolutionOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"getTwapPriceX128\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"getTwapSqrtPriceX96\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceX128\",\"type\":\"uint256\"}],\"name\":\"setPriceX128\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"_sqrtPriceX96\",\"type\":\"uint160\"}],\"name\":\"setSqrtPriceX96\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/test/mocks/OracleMock.sol\":\"OracleMock\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":833},\"remappings\":[]},\"sources\":{\"@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.0;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x0ba8a9b95a956a4050749c0158e928398c447c91469682ca8a7cc7e77a7fe032\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7825565a4bb2a34a1dc96bbfead755785dfb0df8ef81bd934c43023689685645\",\"license\":\"MIT\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    error T();\\n    error R();\\n\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        unchecked {\\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\\n\\n            uint256 ratio = absTick & 0x1 != 0\\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\\n                : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n        }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        unchecked {\\n            // second inequality must be < because the price can never reach the price at the max tick\\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5c57de03a91cc2ec8939865dbbcb0197bb6c353b711075eefd8e0fca5e102129\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\ninterface IOracle {\\n    function getTwapPriceX128(uint32 twapDuration) external view returns (uint256 priceX128);\\n}\\n\",\"keccak256\":\"0xe98d764bed7fc805dd2bb3aae8bf7b2f1cc66e42e15b61852840f28ea3b7d1e1\",\"license\":\"MIT\"},\"contracts/libraries/Bisection.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\n/// @title Bisection Method\\n/// @notice https://en.wikipedia.org/wiki/Bisection_method\\nlibrary Bisection {\\n    error SolutionOutOfBounds(uint256 y_target, uint160 x_lower, uint160 x_upper);\\n\\n    /// @notice Finds the solution to the equation f(x) = y_target using the bisection method\\n    /// @param f: strictly increasing function f: uint160 -> uint256\\n    /// @param y_target: the target value of f(x)\\n    /// @param x_lower: the lower bound for x\\n    /// @param x_upper: the upper bound for x\\n    /// @return x_target: the rounded down solution to the equation f(x) = y_target\\n    function findSolution(\\n        function(uint160) pure returns (uint256) f,\\n        uint256 y_target,\\n        uint160 x_lower,\\n        uint160 x_upper\\n    ) internal pure returns (uint160) {\\n        // compute y at the bounds\\n        uint256 y_lower = f(x_lower);\\n        uint256 y_upper = f(x_upper);\\n\\n        // if y is out of the bounds then revert\\n        if (y_target < y_lower || y_target > y_upper) revert SolutionOutOfBounds(y_target, x_lower, x_upper);\\n\\n        // bisect repeatedly until the solution is within an error of 1 unit\\n        uint256 y_mid;\\n        uint160 x_mid;\\n        while (x_upper - x_lower > 1) {\\n            x_mid = x_lower + (x_upper - x_lower) / 2;\\n            y_mid = f(x_mid);\\n            if (y_mid > y_target) {\\n                x_upper = x_mid;\\n                y_upper = y_mid;\\n            } else {\\n                x_lower = x_mid;\\n                y_lower = y_mid;\\n            }\\n        }\\n\\n        // at this point, x_upper - x_lower is either 0 or 1\\n        // if it is 1 then check if x_upper is the solution, else return x_lower as the rounded down solution\\n        return x_lower != x_upper && f(x_upper) == y_target ? x_upper : x_lower;\\n    }\\n}\\n\",\"keccak256\":\"0x2075fe39689855e3b604cf962794f9ec838c480eeaf24a5d9f8823e02c209152\",\"license\":\"MIT\"},\"contracts/libraries/PriceMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.9;\\n\\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\\nimport { FixedPoint96 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint96.sol';\\nimport { TickMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/TickMath.sol';\\n\\nimport { Bisection } from './Bisection.sol';\\n\\n/// @title Price math functions\\nlibrary PriceMath {\\n    using FullMath for uint256;\\n\\n    error IllegalSqrtPrice(uint160 sqrtPriceX96);\\n\\n    /// @notice Computes the square of a sqrtPriceX96 value\\n    /// @param sqrtPriceX96: input price in Q128 format\\n    /// @return priceX128 : the square root of the input price in Q96 format\\n    function toPriceX128(uint160 sqrtPriceX96) internal pure returns (uint256 priceX128) {\\n        if (sqrtPriceX96 < TickMath.MIN_SQRT_RATIO || sqrtPriceX96 >= TickMath.MAX_SQRT_RATIO) {\\n            revert IllegalSqrtPrice(sqrtPriceX96);\\n        }\\n\\n        priceX128 = _toPriceX128(sqrtPriceX96);\\n    }\\n\\n    function _toPriceX128(uint160 sqrtPriceX96) private pure returns (uint256 priceX128) {\\n        priceX128 = uint256(sqrtPriceX96).mulDiv(sqrtPriceX96, 1 << 64);\\n    }\\n\\n    /// @notice Computes the square root of a priceX128 value\\n    /// @param priceX128: input price in Q128 format\\n    /// @return sqrtPriceX96 : the square root of the input price in Q96 format\\n    function toSqrtPriceX96(uint256 priceX128) internal pure returns (uint160 sqrtPriceX96) {\\n        // Uses bisection method to find solution to the equation toPriceX128(x) = priceX128\\n        sqrtPriceX96 = Bisection.findSolution(\\n            _toPriceX128,\\n            priceX128,\\n            /// @dev sqrtPriceX96 is always bounded by MIN_SQRT_RATIO and MAX_SQRT_RATIO.\\n            ///     If solution falls outside of these bounds, findSolution method reverts\\n            TickMath.MIN_SQRT_RATIO,\\n            TickMath.MAX_SQRT_RATIO - 1\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x8f6c36a6b671efeb83ce5cfdd8b5c8fbca7ee1eef3209ad8ebffbd38b3b8986f\",\"license\":\"GPL-2.0-or-later\"},\"contracts/test/mocks/OracleMock.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.9;\\n\\nimport { IOracle } from '../../interfaces/IOracle.sol';\\n\\nimport { PriceMath } from '../../libraries/PriceMath.sol';\\n\\ncontract OracleMock is IOracle {\\n    using PriceMath for uint256;\\n    using PriceMath for uint160;\\n\\n    uint256 priceX128;\\n\\n    constructor() {\\n        setPriceX128(1 << 128);\\n    }\\n\\n    function getTwapPriceX128(uint32) external view returns (uint256) {\\n        return priceX128;\\n    }\\n\\n    function getTwapSqrtPriceX96(uint32) external view returns (uint160 sqrtPriceX96) {\\n        sqrtPriceX96 = priceX128.toSqrtPriceX96();\\n    }\\n\\n    function setSqrtPriceX96(uint160 _sqrtPriceX96) public {\\n        priceX128 = _sqrtPriceX96.toPriceX128();\\n    }\\n\\n    function setPriceX128(uint256 _priceX128) public {\\n        priceX128 = _priceX128;\\n    }\\n}\\n\",\"keccak256\":\"0xed5bed95b88542b6cfe48ffc949d06d5295f2a459f1ea265171d0bf5e5f16694\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061001e600160801b600055565b6104c18061002d6000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c8063726416331461005157806372b6bb3814610066578063c9c32f2a14610096578063dd86c101146100a9575b600080fd5b61006461005f366004610386565b600055565b005b61007961007436600461039f565b6100cc565b6040516001600160a01b0390911681526020015b60405180910390f35b6100646100a43660046103c5565b6100df565b6100be6100b736600461039f565b5060005490565b60405190815260200161008d565b60006100d96000546100f7565b92915050565b6100f1816001600160a01b031661012a565b60005550565b60006100d9610198836401000276a3610125600173fffd8963efd1fc6a506488495d951d5263988d26610404565b6101b7565b60006401000276a36001600160a01b0383161080610165575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b03831610155b1561019357604051635d236c4560e01b81526001600160a01b03831660048201526024015b60405180910390fd5b6100d9825b60006100d96001600160a01b03831680680100000000000000006102d3565b6000806101c7848763ffffffff16565b905060006101d8848863ffffffff16565b9050818610806101e757508086115b1561021f5760405163f7b6b2e960e01b8152600481018790526001600160a01b0380871660248301528516604482015260640161018a565b6000805b600161022f8888610404565b6001600160a01b0316111561028d57600261024a8888610404565b610254919061042c565b61025e9088610460565b905061026d818a63ffffffff16565b91508782111561028257809550819250610223565b809650819350610223565b856001600160a01b0316876001600160a01b0316141580156102ba5750876102b8878b63ffffffff16565b145b6102c457866102c6565b855b9998505050505050505050565b600080806000198587098587029250828110838203039150508060000361030c576000841161030157600080fd5b50829004905061037f565b80841161031857600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150505b9392505050565b60006020828403121561039857600080fd5b5035919050565b6000602082840312156103b157600080fd5b813563ffffffff8116811461037f57600080fd5b6000602082840312156103d757600080fd5b81356001600160a01b038116811461037f57600080fd5b634e487b7160e01b600052601160045260246000fd5b60006001600160a01b0383811690831681811015610424576104246103ee565b039392505050565b60006001600160a01b038084168061045457634e487b7160e01b600052601260045260246000fd5b92169190910492915050565b60006001600160a01b03808316818516808303821115610482576104826103ee565b0194935050505056fea2646970667358221220024043a37112f5bf16fbf50169f8681ff5a96ab973f9f26a3f1a63afda3c509f64736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c8063726416331461005157806372b6bb3814610066578063c9c32f2a14610096578063dd86c101146100a9575b600080fd5b61006461005f366004610386565b600055565b005b61007961007436600461039f565b6100cc565b6040516001600160a01b0390911681526020015b60405180910390f35b6100646100a43660046103c5565b6100df565b6100be6100b736600461039f565b5060005490565b60405190815260200161008d565b60006100d96000546100f7565b92915050565b6100f1816001600160a01b031661012a565b60005550565b60006100d9610198836401000276a3610125600173fffd8963efd1fc6a506488495d951d5263988d26610404565b6101b7565b60006401000276a36001600160a01b0383161080610165575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b03831610155b1561019357604051635d236c4560e01b81526001600160a01b03831660048201526024015b60405180910390fd5b6100d9825b60006100d96001600160a01b03831680680100000000000000006102d3565b6000806101c7848763ffffffff16565b905060006101d8848863ffffffff16565b9050818610806101e757508086115b1561021f5760405163f7b6b2e960e01b8152600481018790526001600160a01b0380871660248301528516604482015260640161018a565b6000805b600161022f8888610404565b6001600160a01b0316111561028d57600261024a8888610404565b610254919061042c565b61025e9088610460565b905061026d818a63ffffffff16565b91508782111561028257809550819250610223565b809650819350610223565b856001600160a01b0316876001600160a01b0316141580156102ba5750876102b8878b63ffffffff16565b145b6102c457866102c6565b855b9998505050505050505050565b600080806000198587098587029250828110838203039150508060000361030c576000841161030157600080fd5b50829004905061037f565b80841161031857600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150505b9392505050565b60006020828403121561039857600080fd5b5035919050565b6000602082840312156103b157600080fd5b813563ffffffff8116811461037f57600080fd5b6000602082840312156103d757600080fd5b81356001600160a01b038116811461037f57600080fd5b634e487b7160e01b600052601160045260246000fd5b60006001600160a01b0383811690831681811015610424576104246103ee565b039392505050565b60006001600160a01b038084168061045457634e487b7160e01b600052601260045260246000fd5b92169190910492915050565b60006001600160a01b03808316818516808303821115610482576104826103ee565b0194935050505056fea2646970667358221220024043a37112f5bf16fbf50169f8681ff5a96ab973f9f26a3f1a63afda3c509f64736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 28961,
        "contract": "contracts/test/mocks/OracleMock.sol:OracleMock",
        "label": "priceX128",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}