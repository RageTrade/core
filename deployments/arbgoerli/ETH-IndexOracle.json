{
  "address": "0x7877ec52e712a9DC0B5377eb9c56db810654c665",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtPriceX96",
          "type": "uint160"
        }
      ],
      "name": "IllegalSqrtPrice",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "y_target",
          "type": "uint256"
        },
        {
          "internalType": "uint160",
          "name": "x_lower",
          "type": "uint160"
        },
        {
          "internalType": "uint160",
          "name": "x_upper",
          "type": "uint160"
        }
      ],
      "name": "SolutionOutOfBounds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "getTwapPriceX128",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "getTwapSqrtPriceX96",
      "outputs": [
        {
          "internalType": "uint160",
          "name": "sqrtPriceX96",
          "type": "uint160"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_priceX128",
          "type": "uint256"
        }
      ],
      "name": "setPriceX128",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "_sqrtPriceX96",
          "type": "uint160"
        }
      ],
      "name": "setSqrtPriceX96",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x05579f2f46d88ff369536e4854e87ad56588b0e9e03b44fbfe188480e0ac35e4",
  "receipt": {
    "to": null,
    "from": "0x4ec0dda0430A54b4796109913545F715B2d89F34",
    "contractAddress": "0x7877ec52e712a9DC0B5377eb9c56db810654c665",
    "transactionIndex": 1,
    "gasUsed": "323698",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9762af53a1002c60ae74a15f6fca77981c8c369998dc853d2a09e2080855cab5",
    "transactionHash": "0x05579f2f46d88ff369536e4854e87ad56588b0e9e03b44fbfe188480e0ac35e4",
    "logs": [],
    "blockNumber": 403376,
    "cumulativeGasUsed": "323698",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "e2d022a5c828f2ed8f5d3781fb319748",
  "metadata": "{\"compiler\":{\"version\":\"0.8.14+commit.80d49f37\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"}],\"name\":\"IllegalSqrtPrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"y_target\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"x_lower\",\"type\":\"uint160\"},{\"internalType\":\"uint160\",\"name\":\"x_upper\",\"type\":\"uint160\"}],\"name\":\"SolutionOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"getTwapPriceX128\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"getTwapSqrtPriceX96\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceX128\",\"type\":\"uint256\"}],\"name\":\"setPriceX128\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"_sqrtPriceX96\",\"type\":\"uint160\"}],\"name\":\"setSqrtPriceX96\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/test/mocks/OracleMock.sol\":\"OracleMock\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":4999},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.0;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x0ba8a9b95a956a4050749c0158e928398c447c91469682ca8a7cc7e77a7fe032\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7825565a4bb2a34a1dc96bbfead755785dfb0df8ef81bd934c43023689685645\",\"license\":\"MIT\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    error T();\\n    error R();\\n\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        unchecked {\\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\\n\\n            uint256 ratio = absTick & 0x1 != 0\\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\\n                : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n        }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        unchecked {\\n            // second inequality must be < because the price can never reach the price at the max tick\\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5c57de03a91cc2ec8939865dbbcb0197bb6c353b711075eefd8e0fca5e102129\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface IOracle {\\n    function getTwapPriceX128(uint32 twapDuration) external view returns (uint256 priceX128);\\n}\\n\",\"keccak256\":\"0x0b868e6dbb5dbbe067f65dda1a2c405a124142dbd936deeb4cc995ceb9ab232e\",\"license\":\"MIT\"},\"contracts/libraries/Bisection.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/// @title Bisection Method\\n/// @notice https://en.wikipedia.org/wiki/Bisection_method\\nlibrary Bisection {\\n    error SolutionOutOfBounds(uint256 y_target, uint160 x_lower, uint160 x_upper);\\n\\n    /// @notice Finds the solution to the equation f(x) = y_target using the bisection method\\n    /// @param f: strictly increasing function f: uint160 -> uint256\\n    /// @param y_target: the target value of f(x)\\n    /// @param x_lower: the lower bound for x\\n    /// @param x_upper: the upper bound for x\\n    /// @return x_target: the rounded down solution to the equation f(x) = y_target\\n    function findSolution(\\n        function(uint160) pure returns (uint256) f,\\n        uint256 y_target,\\n        uint160 x_lower,\\n        uint160 x_upper\\n    ) internal pure returns (uint160) {\\n        // compute y at the bounds\\n        uint256 y_lower = f(x_lower);\\n        uint256 y_upper = f(x_upper);\\n\\n        // if y is out of the bounds then revert\\n        if (y_target < y_lower || y_target > y_upper) revert SolutionOutOfBounds(y_target, x_lower, x_upper);\\n\\n        // bisect repeatedly until the solution is within an error of 1 unit\\n        uint256 y_mid;\\n        uint160 x_mid;\\n        while (x_upper - x_lower > 1) {\\n            x_mid = x_lower + (x_upper - x_lower) / 2;\\n            y_mid = f(x_mid);\\n            if (y_mid > y_target) {\\n                x_upper = x_mid;\\n                y_upper = y_mid;\\n            } else {\\n                x_lower = x_mid;\\n                y_lower = y_mid;\\n            }\\n        }\\n\\n        // at this point, x_upper - x_lower is either 0 or 1\\n        // if it is 1 then check if x_upper is the solution, else return x_lower as the rounded down solution\\n        return x_lower != x_upper && f(x_upper) == y_target ? x_upper : x_lower;\\n    }\\n}\\n\",\"keccak256\":\"0xae30dfb5c8806a894fd086f494cd19bb7019c8bc865522b5ec407b7d71b8e4bc\",\"license\":\"MIT\"},\"contracts/libraries/PriceMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\\nimport { FixedPoint96 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint96.sol';\\nimport { TickMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/TickMath.sol';\\n\\nimport { Bisection } from './Bisection.sol';\\n\\n/// @title Price math functions\\nlibrary PriceMath {\\n    using FullMath for uint256;\\n\\n    error IllegalSqrtPrice(uint160 sqrtPriceX96);\\n\\n    /// @notice Computes the square of a sqrtPriceX96 value\\n    /// @param sqrtPriceX96: the square root of the input price in Q96 format\\n    /// @return priceX128 : input price in Q128 format\\n    function toPriceX128(uint160 sqrtPriceX96) internal pure returns (uint256 priceX128) {\\n        if (sqrtPriceX96 < TickMath.MIN_SQRT_RATIO || sqrtPriceX96 >= TickMath.MAX_SQRT_RATIO) {\\n            revert IllegalSqrtPrice(sqrtPriceX96);\\n        }\\n\\n        priceX128 = _toPriceX128(sqrtPriceX96);\\n    }\\n\\n    /// @notice computes the square of a sqrtPriceX96 value\\n    /// @param sqrtPriceX96: input price in Q128 format\\n    function _toPriceX128(uint160 sqrtPriceX96) private pure returns (uint256 priceX128) {\\n        priceX128 = uint256(sqrtPriceX96).mulDiv(sqrtPriceX96, 1 << 64);\\n    }\\n\\n    /// @notice computes the square root of a priceX128 value\\n    /// @param priceX128: input price in Q128 format\\n    /// @return sqrtPriceX96 : the square root of the input price in Q96 format\\n    function toSqrtPriceX96(uint256 priceX128) internal pure returns (uint160 sqrtPriceX96) {\\n        // Uses bisection method to find solution to the equation toPriceX128(x) = priceX128\\n        sqrtPriceX96 = Bisection.findSolution(\\n            _toPriceX128,\\n            priceX128,\\n            /// @dev sqrtPriceX96 is always bounded by MIN_SQRT_RATIO and MAX_SQRT_RATIO.\\n            ///     If solution falls outside of these bounds, findSolution method reverts\\n            TickMath.MIN_SQRT_RATIO,\\n            TickMath.MAX_SQRT_RATIO - 1\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x88bb3e3cb05a8474c5e69c26e2c29bf382a82a4d460f79674ae407114463c3b7\",\"license\":\"GPL-2.0-or-later\"},\"contracts/test/mocks/OracleMock.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.9;\\n\\nimport { IOracle } from '../../interfaces/IOracle.sol';\\n\\nimport { PriceMath } from '../../libraries/PriceMath.sol';\\n\\ncontract OracleMock is IOracle {\\n    using PriceMath for uint256;\\n    using PriceMath for uint160;\\n\\n    uint256 priceX128;\\n\\n    constructor() {\\n        setPriceX128(1 << 128);\\n    }\\n\\n    function getTwapPriceX128(uint32) external view returns (uint256) {\\n        return priceX128;\\n    }\\n\\n    function getTwapSqrtPriceX96(uint32) external view returns (uint160 sqrtPriceX96) {\\n        sqrtPriceX96 = priceX128.toSqrtPriceX96();\\n    }\\n\\n    function setSqrtPriceX96(uint160 _sqrtPriceX96) public {\\n        priceX128 = _sqrtPriceX96.toPriceX128();\\n    }\\n\\n    function setPriceX128(uint256 _priceX128) public {\\n        priceX128 = _priceX128;\\n    }\\n}\\n\",\"keccak256\":\"0xed5bed95b88542b6cfe48ffc949d06d5295f2a459f1ea265171d0bf5e5f16694\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001e57600160801b60005561048290816100248239f35b600080fdfe608080604052600436101561001357600080fd5b600090813560e01c918263726416331461022e57826372b6bb38146100605750508063c9c32f2a146100575763dd86c1011461004f575b600080fd5b61004a61030e565b5061004a61026a565b3461022b5761006e3661024b565b5080546401000276a39073fffd8963efd1fc6a506488495d951d5263988d25926001948583108015610202575b6101ae575093805b610120575b506101019373ffffffffffffffffffffffffffffffffffffffff8085169084161415918261010c575b50501561010557505b60405173ffffffffffffffffffffffffffffffffffffffff90911681529081906020820190565b0390f35b90506100da565b90915061011884610429565b1490856100d1565b929383610149610130858861035b565b73ffffffffffffffffffffffffffffffffffffffff1690565b11156101a7578461018361017d61016186889961035b565b60011c737fffffffffffffffffffffffffffffffffffffff1690565b8561038c565b908361018e83610429565b111561019e5750935b90946100a3565b94935092610197565b93926100a8565b7ff7b6b2e9000000000000000000000000000000000000000000000000000000008152600481018390526401000276a3602482015273fffd8963efd1fc6a506488495d951d5263988d256044820152606490fd5b507ffffb12cdf108779ad387f409f1a66d1a2f5124ea64410ed5b3a4d30149805a4f831161009b565b80fd5b9034610247576020600319360112610247576004358255f35b5080fd5b600319602091011261004a5760043563ffffffff8116810361004a5790565b503461004a57602060031936011261004a5760043573ffffffffffffffffffffffffffffffffffffffff811680910361004a576401000276a3811080156102f0575b6102bf57806102ba916103c1565b600055005b602490604051907f5d236c450000000000000000000000000000000000000000000000000000000082526004820152fd5b5073fffd8963efd1fc6a506488495d951d5263988d268110156102ac565b503461004a5761031d3661024b565b506020600054604051908152f35b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b73ffffffffffffffffffffffffffffffffffffffff9182169116818110610380570390565b61038861032b565b0390565b9073ffffffffffffffffffffffffffffffffffffffff80809316911680920381116103b5570190565b6103bd61032b565b0190565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82820990828102928380841093039280840393146104205768010000000000000000918383111561004a570990828211900360c01b910360401c1790565b50505060401c90565b73ffffffffffffffffffffffffffffffffffffffff6104499116806103c1565b9056fea264697066735822122007ab1bd4212254eefe15c752fa2d51318b5bd84db9f1ef25d7749d2b7056054b64736f6c634300080e0033",
  "deployedBytecode": "0x608080604052600436101561001357600080fd5b600090813560e01c918263726416331461022e57826372b6bb38146100605750508063c9c32f2a146100575763dd86c1011461004f575b600080fd5b61004a61030e565b5061004a61026a565b3461022b5761006e3661024b565b5080546401000276a39073fffd8963efd1fc6a506488495d951d5263988d25926001948583108015610202575b6101ae575093805b610120575b506101019373ffffffffffffffffffffffffffffffffffffffff8085169084161415918261010c575b50501561010557505b60405173ffffffffffffffffffffffffffffffffffffffff90911681529081906020820190565b0390f35b90506100da565b90915061011884610429565b1490856100d1565b929383610149610130858861035b565b73ffffffffffffffffffffffffffffffffffffffff1690565b11156101a7578461018361017d61016186889961035b565b60011c737fffffffffffffffffffffffffffffffffffffff1690565b8561038c565b908361018e83610429565b111561019e5750935b90946100a3565b94935092610197565b93926100a8565b7ff7b6b2e9000000000000000000000000000000000000000000000000000000008152600481018390526401000276a3602482015273fffd8963efd1fc6a506488495d951d5263988d256044820152606490fd5b507ffffb12cdf108779ad387f409f1a66d1a2f5124ea64410ed5b3a4d30149805a4f831161009b565b80fd5b9034610247576020600319360112610247576004358255f35b5080fd5b600319602091011261004a5760043563ffffffff8116810361004a5790565b503461004a57602060031936011261004a5760043573ffffffffffffffffffffffffffffffffffffffff811680910361004a576401000276a3811080156102f0575b6102bf57806102ba916103c1565b600055005b602490604051907f5d236c450000000000000000000000000000000000000000000000000000000082526004820152fd5b5073fffd8963efd1fc6a506488495d951d5263988d268110156102ac565b503461004a5761031d3661024b565b506020600054604051908152f35b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b73ffffffffffffffffffffffffffffffffffffffff9182169116818110610380570390565b61038861032b565b0390565b9073ffffffffffffffffffffffffffffffffffffffff80809316911680920381116103b5570190565b6103bd61032b565b0190565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82820990828102928380841093039280840393146104205768010000000000000000918383111561004a570990828211900360c01b910360401c1790565b50505060401c90565b73ffffffffffffffffffffffffffffffffffffffff6104499116806103c1565b9056fea264697066735822122007ab1bd4212254eefe15c752fa2d51318b5bd84db9f1ef25d7749d2b7056054b64736f6c634300080e0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 34456,
        "contract": "contracts/test/mocks/OracleMock.sol:OracleMock",
        "label": "priceX128",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}