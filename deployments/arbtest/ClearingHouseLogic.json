{
  "address": "0x4b173C91CDFb0c57e23d6920E1aB8Be4F5bD01b7",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "senderAddress",
          "type": "address"
        }
      ],
      "name": "AccessDenied",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CannotPauseIfUnpauseInProgress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CannotUnpauseIfPauseInProgress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "collateralId",
          "type": "uint32"
        }
      ],
      "name": "CollateralDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "collateralId",
          "type": "uint32"
        }
      ],
      "name": "CollateralNotAllowedForUse",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtPriceX96",
          "type": "uint160"
        }
      ],
      "name": "IllegalSqrtPrice",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "incorrectAddress",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "correctAddress",
          "type": "address"
        }
      ],
      "name": "IncorrectCollateralAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "invalidAddress",
          "type": "address"
        }
      ],
      "name": "InvalidCollateralAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "enum IClearingHouseEnums.MulticallOperationType",
          "name": "multicallOperationType",
          "type": "uint8"
        }
      ],
      "name": "InvalidMulticallOperationType",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorCode",
          "type": "uint256"
        }
      ],
      "name": "InvalidSetting",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidTokenLiquidationParameters",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "keeperFee",
          "type": "int256"
        }
      ],
      "name": "KeeperFeeNotPositive",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "notionalValue",
          "type": "uint256"
        }
      ],
      "name": "LowNotionalValue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotRageTradeFactory",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        }
      ],
      "name": "PoolDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        }
      ],
      "name": "PoolNotAllowedForTrade",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "SafeCast_UInt224Overflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SlippageBeyondTolerance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "T",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Unauthorised",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAmount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "ownerAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        }
      ],
      "name": "AccountCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract IERC20",
          "name": "cToken",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "contract IOracle",
              "name": "oracle",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "twapDuration",
              "type": "uint32"
            },
            {
              "internalType": "bool",
              "name": "isAllowedForDeposit",
              "type": "bool"
            }
          ],
          "indexed": false,
          "internalType": "struct IClearingHouseStructures.CollateralSettings",
          "name": "cTokenInfo",
          "type": "tuple"
        }
      ],
      "name": "CollateralSettingsUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousGovernancePending",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newGovernancePending",
          "type": "address"
        }
      ],
      "name": "GovernancePending",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousGovernance",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newGovernance",
          "type": "address"
        }
      ],
      "name": "GovernanceTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bool",
          "name": "paused",
          "type": "bool"
        }
      ],
      "name": "PausedUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "initialMarginRatioBps",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "maintainanceMarginRatioBps",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "maxVirtualPriceDeviationRatioBps",
              "type": "uint16"
            },
            {
              "internalType": "uint32",
              "name": "twapDuration",
              "type": "uint32"
            },
            {
              "internalType": "bool",
              "name": "isAllowedForTrade",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isCrossMargined",
              "type": "bool"
            },
            {
              "internalType": "contract IOracle",
              "name": "oracle",
              "type": "address"
            }
          ],
          "indexed": false,
          "internalType": "struct IClearingHouseStructures.PoolSettings",
          "name": "settings",
          "type": "tuple"
        }
      ],
      "name": "PoolSettingsUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "rangeLiquidationFeeFraction",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "tokenLiquidationFeeFraction",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "closeFactorMMThresholdBps",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "partialLiquidationCloseFactorBps",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "insuranceFundFeeShareBps",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "liquidationSlippageSqrtToleranceBps",
              "type": "uint16"
            },
            {
              "internalType": "uint64",
              "name": "maxRangeLiquidationFees",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "minNotionalLiquidatable",
              "type": "uint64"
            }
          ],
          "indexed": false,
          "internalType": "struct IClearingHouseStructures.LiquidationParams",
          "name": "liquidationParams",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "removeLimitOrderFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "minimumOrderNotional",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "minRequiredMargin",
          "type": "uint256"
        }
      ],
      "name": "ProtocolSettingsUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousTeamMultisigPending",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newTeamMultisigPending",
          "type": "address"
        }
      ],
      "name": "TeamMultisigPending",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousTeamMultisig",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newTeamMultisig",
          "type": "address"
        }
      ],
      "name": "TeamMultisigTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "acceptGovernanceTransfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptTeamMultisigTransfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createAccount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "newAccountId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "collateralId",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "createAccountAndAddMargin",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "newAccountId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "slot",
          "type": "bytes32"
        }
      ],
      "name": "extsload",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "val",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "slots",
          "type": "bytes32[]"
        }
      ],
      "name": "extsload",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isInitialMargin",
          "type": "bool"
        }
      ],
      "name": "getAccountMarketValueAndRequiredMargin",
      "outputs": [
        {
          "internalType": "int256",
          "name": "marketValue",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "requiredMargin",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        }
      ],
      "name": "getAccountNetProfit",
      "outputs": [
        {
          "internalType": "int256",
          "name": "accountNetProfit",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        }
      ],
      "name": "getAccountNetTokenPosition",
      "outputs": [
        {
          "internalType": "int256",
          "name": "netPosition",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        }
      ],
      "name": "getRealTwapPriceX128",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "realPriceX128",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        }
      ],
      "name": "getVirtualTwapPriceX128",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "virtualPriceX128",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "governance",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "governancePending",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_rageTradeFactoryAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "initialGovernance",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "initialTeamMultisig",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "_defaultCollateralToken",
          "type": "address"
        },
        {
          "internalType": "contract IOracle",
          "name": "_defaultCollateralTokenOracle",
          "type": "address"
        },
        {
          "internalType": "contract IInsuranceFund",
          "name": "_insuranceFund",
          "type": "address"
        },
        {
          "internalType": "contract IVQuote",
          "name": "_vQuote",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newGovernancePending",
          "type": "address"
        }
      ],
      "name": "initiateGovernanceTransfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newTeamMultisigPending",
          "type": "address"
        }
      ],
      "name": "initiateTeamMultisigTransfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "insuranceFund",
      "outputs": [
        {
          "internalType": "contract IInsuranceFund",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        }
      ],
      "name": "liquidateLiquidityPositions",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "targetAccountId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        }
      ],
      "name": "liquidateTokenPosition",
      "outputs": [
        {
          "internalType": "int256",
          "name": "keeperFee",
          "type": "int256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "enum IClearingHouseEnums.MulticallOperationType",
              "name": "operationType",
              "type": "uint8"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct IClearingHouseStructures.MulticallOperation[]",
          "name": "operations",
          "type": "tuple[]"
        }
      ],
      "name": "multicallWithSingleMarginCheck",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "numAccounts",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "numberOfPoolsToUpdateInThisTx",
          "type": "uint256"
        }
      ],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rageTradeFactoryAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract IVToken",
              "name": "vToken",
              "type": "address"
            },
            {
              "internalType": "contract IUniswapV3Pool",
              "name": "vPool",
              "type": "address"
            },
            {
              "internalType": "contract IVPoolWrapper",
              "name": "vPoolWrapper",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "uint16",
                  "name": "initialMarginRatioBps",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "maintainanceMarginRatioBps",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "maxVirtualPriceDeviationRatioBps",
                  "type": "uint16"
                },
                {
                  "internalType": "uint32",
                  "name": "twapDuration",
                  "type": "uint32"
                },
                {
                  "internalType": "bool",
                  "name": "isAllowedForTrade",
                  "type": "bool"
                },
                {
                  "internalType": "bool",
                  "name": "isCrossMargined",
                  "type": "bool"
                },
                {
                  "internalType": "contract IOracle",
                  "name": "oracle",
                  "type": "address"
                }
              ],
              "internalType": "struct IClearingHouseStructures.PoolSettings",
              "name": "settings",
              "type": "tuple"
            }
          ],
          "internalType": "struct IClearingHouseStructures.Pool",
          "name": "poolInfo",
          "type": "tuple"
        }
      ],
      "name": "registerPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        }
      ],
      "name": "removeLimitOrder",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        }
      ],
      "name": "settleProfit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "components": [
            {
              "internalType": "int256",
              "name": "amount",
              "type": "int256"
            },
            {
              "internalType": "uint160",
              "name": "sqrtPriceLimit",
              "type": "uint160"
            },
            {
              "internalType": "bool",
              "name": "isNotional",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isPartialAllowed",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "settleProfit",
              "type": "bool"
            }
          ],
          "internalType": "struct IClearingHouseStructures.SwapParams",
          "name": "swapParams",
          "type": "tuple"
        }
      ],
      "name": "swapToken",
      "outputs": [
        {
          "internalType": "int256",
          "name": "vTokenAmountOut",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "vQuoteAmountOut",
          "type": "int256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "teamMultisig",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "teamMultisigPending",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "numberOfPoolsToUpdateInThisTx",
          "type": "uint256"
        }
      ],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "cToken",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "contract IOracle",
              "name": "oracle",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "twapDuration",
              "type": "uint32"
            },
            {
              "internalType": "bool",
              "name": "isAllowedForDeposit",
              "type": "bool"
            }
          ],
          "internalType": "struct IClearingHouseStructures.CollateralSettings",
          "name": "collateralSettings",
          "type": "tuple"
        }
      ],
      "name": "updateCollateralSettings",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "collateralId",
          "type": "uint32"
        },
        {
          "internalType": "int256",
          "name": "amount",
          "type": "int256"
        }
      ],
      "name": "updateMargin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "initialMarginRatioBps",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "maintainanceMarginRatioBps",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "maxVirtualPriceDeviationRatioBps",
              "type": "uint16"
            },
            {
              "internalType": "uint32",
              "name": "twapDuration",
              "type": "uint32"
            },
            {
              "internalType": "bool",
              "name": "isAllowedForTrade",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isCrossMargined",
              "type": "bool"
            },
            {
              "internalType": "contract IOracle",
              "name": "oracle",
              "type": "address"
            }
          ],
          "internalType": "struct IClearingHouseStructures.PoolSettings",
          "name": "newSettings",
          "type": "tuple"
        }
      ],
      "name": "updatePoolSettings",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "amount",
          "type": "int256"
        }
      ],
      "name": "updateProfit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "rangeLiquidationFeeFraction",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "tokenLiquidationFeeFraction",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "closeFactorMMThresholdBps",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "partialLiquidationCloseFactorBps",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "insuranceFundFeeShareBps",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "liquidationSlippageSqrtToleranceBps",
              "type": "uint16"
            },
            {
              "internalType": "uint64",
              "name": "maxRangeLiquidationFees",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "minNotionalLiquidatable",
              "type": "uint64"
            }
          ],
          "internalType": "struct IClearingHouseStructures.LiquidationParams",
          "name": "_liquidationParams",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "_removeLimitOrderFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minimumOrderNotional",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minRequiredMargin",
          "type": "uint256"
        }
      ],
      "name": "updateProtocolSettings",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "components": [
            {
              "internalType": "int24",
              "name": "tickLower",
              "type": "int24"
            },
            {
              "internalType": "int24",
              "name": "tickUpper",
              "type": "int24"
            },
            {
              "internalType": "int128",
              "name": "liquidityDelta",
              "type": "int128"
            },
            {
              "internalType": "uint160",
              "name": "sqrtPriceCurrent",
              "type": "uint160"
            },
            {
              "internalType": "uint16",
              "name": "slippageToleranceBps",
              "type": "uint16"
            },
            {
              "internalType": "bool",
              "name": "closeTokenPosition",
              "type": "bool"
            },
            {
              "internalType": "enum IClearingHouseEnums.LimitOrderType",
              "name": "limitOrderType",
              "type": "uint8"
            },
            {
              "internalType": "bool",
              "name": "settleProfit",
              "type": "bool"
            }
          ],
          "internalType": "struct IClearingHouseStructures.LiquidityChangeParams",
          "name": "liquidityChangeParams",
          "type": "tuple"
        }
      ],
      "name": "updateRangeOrder",
      "outputs": [
        {
          "internalType": "int256",
          "name": "vTokenAmountOut",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "vQuoteAmountOut",
          "type": "int256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "numberOfPoolsToUpdateInThisTx",
          "type": "uint256"
        }
      ],
      "name": "withdrawProtocolFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "InsufficientCollateralBalance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "accountMarketValue",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "totalRequiredMargin",
          "type": "int256"
        }
      ],
      "name": "InvalidLiquidationAccountAboveWater",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        }
      ],
      "name": "InvalidLiquidationActiveRangePresent",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "accountMarketValue",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "totalRequiredMargin",
          "type": "int256"
        }
      ],
      "name": "InvalidTransactionNotEnoughMargin",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "totalProfit",
          "type": "int256"
        }
      ],
      "name": "InvalidTransactionNotEnoughProfit",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "internalType": "uint256",
          "name": "liquidity",
          "type": "uint256"
        }
      ],
      "name": "LPS_DeactivationFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        }
      ],
      "name": "LPS_IllegalTicks",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LPS_InactiveRange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LP_AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LP_IneligibleLimitOrderRemoval",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "y_target",
          "type": "uint256"
        },
        {
          "internalType": "uint160",
          "name": "x_lower",
          "type": "uint160"
        },
        {
          "internalType": "uint160",
          "name": "x_upper",
          "type": "uint160"
        }
      ],
      "name": "SolutionOutOfBounds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "element",
          "type": "uint32"
        }
      ],
      "name": "U32L8_IllegalElement",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "element",
          "type": "uint32"
        }
      ],
      "name": "U32L8_NoSpaceLeftToInsert",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint48",
          "name": "element",
          "type": "uint48"
        }
      ],
      "name": "U48L5_IllegalElement",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint48",
          "name": "element",
          "type": "uint48"
        }
      ],
      "name": "U48L5_NoSpaceLeftToInsert",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        }
      ],
      "name": "VPS_DeactivationFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        }
      ],
      "name": "VPS_TokenInactive",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "keeperAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "liquidationFee",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "keeperFee",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "insuranceFundFee",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "accountMarketValueFinal",
          "type": "int256"
        }
      ],
      "name": "LiquidityPositionsLiquidated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "collateralId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "amount",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isSettleProfit",
          "type": "bool"
        }
      ],
      "name": "MarginUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "amount",
          "type": "int256"
        }
      ],
      "name": "ProfitUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "keeperFee",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "insuranceFundFee",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "accountMarketValueFinal",
          "type": "int256"
        }
      ],
      "name": "TokenPositionLiquidated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int128",
          "name": "liquidityDelta",
          "type": "int128"
        },
        {
          "indexed": false,
          "internalType": "enum IClearingHouseEnums.LimitOrderType",
          "name": "limitOrderType",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "vTokenAmountOut",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "vQuoteAmountOut",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "uint160",
          "name": "sqrtPriceX96",
          "type": "uint160"
        }
      ],
      "name": "LiquidityChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "amount",
          "type": "int256"
        }
      ],
      "name": "LiquidityPositionEarningsRealized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "amount",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "sumALastX128",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "sumBInsideLastX128",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "sumFpInsideLastX128",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "sumFeeInsideLastX128",
          "type": "uint256"
        }
      ],
      "name": "LiquidityPositionFundingPaymentRealized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "vTokenAmountOut",
          "type": "int256"
        }
      ],
      "name": "TokenPositionChangedDueToLiquidityChanged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "VPS_IncorrectUpdate",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "vTokenAmountOut",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "vQuoteAmountOut",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "uint160",
          "name": "sqrtPriceX96Start",
          "type": "uint160"
        },
        {
          "indexed": false,
          "internalType": "uint160",
          "name": "sqrtPriceX96End",
          "type": "uint160"
        }
      ],
      "name": "TokenPositionChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "accountId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "poolId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "amount",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "sumALastX128",
          "type": "int256"
        }
      ],
      "name": "TokenPositionFundingPaymentRealized",
      "type": "event"
    }
  ],
  "transactionHash": "0xe69a2929827474228b4fb2ef38579366123b33f63e3552082e3cb5cce9a6ad48",
  "receipt": {
    "to": null,
    "from": "0x4ec0dda0430A54b4796109913545F715B2d89F34",
    "contractAddress": "0x4b173C91CDFb0c57e23d6920E1aB8Be4F5bD01b7",
    "transactionIndex": 0,
    "gasUsed": "81857747",
    "logsBloom": "0x00000000000000000000000000000200000000004000000000200000000000000000000000000000000000000000000000000000040000000000040000000000000000000000000000000000000000000000000000000800000000000000008000000400020000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000400000000000000000000000000000000000000000000000000000000000020000000000000000000000800000000000000000000000000000200000000000000",
    "blockHash": "0x3e3cb77e543a0b7010080573c4febce889ac0813f01ebce7a30035e8b8672c68",
    "transactionHash": "0xe69a2929827474228b4fb2ef38579366123b33f63e3552082e3cb5cce9a6ad48",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 12705278,
        "transactionHash": "0xe69a2929827474228b4fb2ef38579366123b33f63e3552082e3cb5cce9a6ad48",
        "address": "0x4b173C91CDFb0c57e23d6920E1aB8Be4F5bD01b7",
        "topics": [
          "0x5f56bee8cffbe9a78652a74a60705edede02af10b0bbb888ca44b79a0d42ce80",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000004ec0dda0430a54b4796109913545f715b2d89f34"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x3e3cb77e543a0b7010080573c4febce889ac0813f01ebce7a30035e8b8672c68"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 12705278,
        "transactionHash": "0xe69a2929827474228b4fb2ef38579366123b33f63e3552082e3cb5cce9a6ad48",
        "address": "0x4b173C91CDFb0c57e23d6920E1aB8Be4F5bD01b7",
        "topics": [
          "0x39355f2f5c8206286978f443aa8126bbd29fa09c53c04569502647f3a59c8cb2",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000004ec0dda0430a54b4796109913545f715b2d89f34"
        ],
        "data": "0x",
        "logIndex": 1,
        "blockHash": "0x3e3cb77e543a0b7010080573c4febce889ac0813f01ebce7a30035e8b8672c68"
      }
    ],
    "blockNumber": 12705278,
    "cumulativeGasUsed": "38988047",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "a0f251f14be82fcda6f51ae633510bf0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.14+commit.80d49f37\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"}],\"name\":\"AccessDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotPauseIfUnpauseInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotUnpauseIfPauseInProgress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"collateralId\",\"type\":\"uint32\"}],\"name\":\"CollateralDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"collateralId\",\"type\":\"uint32\"}],\"name\":\"CollateralNotAllowedForUse\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"}],\"name\":\"IllegalSqrtPrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"incorrectAddress\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"correctAddress\",\"type\":\"address\"}],\"name\":\"IncorrectCollateralAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"invalidAddress\",\"type\":\"address\"}],\"name\":\"InvalidCollateralAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum IClearingHouseEnums.MulticallOperationType\",\"name\":\"multicallOperationType\",\"type\":\"uint8\"}],\"name\":\"InvalidMulticallOperationType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"InvalidSetting\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenLiquidationParameters\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"keeperFee\",\"type\":\"int256\"}],\"name\":\"KeeperFeeNotPositive\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notionalValue\",\"type\":\"uint256\"}],\"name\":\"LowNotionalValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotRageTradeFactory\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"}],\"name\":\"PoolDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"}],\"name\":\"PoolNotAllowedForTrade\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCast_UInt224Overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SlippageBeyondTolerance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"T\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"}],\"name\":\"AccountCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"cToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"twapDuration\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isAllowedForDeposit\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct IClearingHouseStructures.CollateralSettings\",\"name\":\"cTokenInfo\",\"type\":\"tuple\"}],\"name\":\"CollateralSettingsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernancePending\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernancePending\",\"type\":\"address\"}],\"name\":\"GovernancePending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"PausedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"initialMarginRatioBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maintainanceMarginRatioBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxVirtualPriceDeviationRatioBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"twapDuration\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isAllowedForTrade\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCrossMargined\",\"type\":\"bool\"},{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct IClearingHouseStructures.PoolSettings\",\"name\":\"settings\",\"type\":\"tuple\"}],\"name\":\"PoolSettingsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"rangeLiquidationFeeFraction\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tokenLiquidationFeeFraction\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"closeFactorMMThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"partialLiquidationCloseFactorBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"insuranceFundFeeShareBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationSlippageSqrtToleranceBps\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"maxRangeLiquidationFees\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minNotionalLiquidatable\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"struct IClearingHouseStructures.LiquidationParams\",\"name\":\"liquidationParams\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"removeLimitOrderFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumOrderNotional\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minRequiredMargin\",\"type\":\"uint256\"}],\"name\":\"ProtocolSettingsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTeamMultisigPending\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTeamMultisigPending\",\"type\":\"address\"}],\"name\":\"TeamMultisigPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTeamMultisig\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTeamMultisig\",\"type\":\"address\"}],\"name\":\"TeamMultisigTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernanceTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptTeamMultisigTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newAccountId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"collateralId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createAccountAndAddMargin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newAccountId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"extsload\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"slots\",\"type\":\"bytes32[]\"}],\"name\":\"extsload\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isInitialMargin\",\"type\":\"bool\"}],\"name\":\"getAccountMarketValueAndRequiredMargin\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"marketValue\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"requiredMargin\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"}],\"name\":\"getAccountNetProfit\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"accountNetProfit\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"}],\"name\":\"getAccountNetTokenPosition\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"netPosition\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"}],\"name\":\"getRealTwapPriceX128\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"realPriceX128\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"}],\"name\":\"getVirtualTwapPriceX128\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"virtualPriceX128\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governancePending\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rageTradeFactoryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialGovernance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialTeamMultisig\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_defaultCollateralToken\",\"type\":\"address\"},{\"internalType\":\"contract IOracle\",\"name\":\"_defaultCollateralTokenOracle\",\"type\":\"address\"},{\"internalType\":\"contract IInsuranceFund\",\"name\":\"_insuranceFund\",\"type\":\"address\"},{\"internalType\":\"contract IVQuote\",\"name\":\"_vQuote\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernancePending\",\"type\":\"address\"}],\"name\":\"initiateGovernanceTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTeamMultisigPending\",\"type\":\"address\"}],\"name\":\"initiateTeamMultisigTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insuranceFund\",\"outputs\":[{\"internalType\":\"contract IInsuranceFund\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"}],\"name\":\"liquidateLiquidityPositions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetAccountId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"}],\"name\":\"liquidateTokenPosition\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"keeperFee\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"enum IClearingHouseEnums.MulticallOperationType\",\"name\":\"operationType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IClearingHouseStructures.MulticallOperation[]\",\"name\":\"operations\",\"type\":\"tuple[]\"}],\"name\":\"multicallWithSingleMarginCheck\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfPoolsToUpdateInThisTx\",\"type\":\"uint256\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rageTradeFactoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IVToken\",\"name\":\"vToken\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV3Pool\",\"name\":\"vPool\",\"type\":\"address\"},{\"internalType\":\"contract IVPoolWrapper\",\"name\":\"vPoolWrapper\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"initialMarginRatioBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maintainanceMarginRatioBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxVirtualPriceDeviationRatioBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"twapDuration\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isAllowedForTrade\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCrossMargined\",\"type\":\"bool\"},{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"}],\"internalType\":\"struct IClearingHouseStructures.PoolSettings\",\"name\":\"settings\",\"type\":\"tuple\"}],\"internalType\":\"struct IClearingHouseStructures.Pool\",\"name\":\"poolInfo\",\"type\":\"tuple\"}],\"name\":\"registerPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"removeLimitOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"}],\"name\":\"settleProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimit\",\"type\":\"uint160\"},{\"internalType\":\"bool\",\"name\":\"isNotional\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPartialAllowed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"settleProfit\",\"type\":\"bool\"}],\"internalType\":\"struct IClearingHouseStructures.SwapParams\",\"name\":\"swapParams\",\"type\":\"tuple\"}],\"name\":\"swapToken\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"vTokenAmountOut\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"vQuoteAmountOut\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamMultisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamMultisigPending\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfPoolsToUpdateInThisTx\",\"type\":\"uint256\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"cToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"twapDuration\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isAllowedForDeposit\",\"type\":\"bool\"}],\"internalType\":\"struct IClearingHouseStructures.CollateralSettings\",\"name\":\"collateralSettings\",\"type\":\"tuple\"}],\"name\":\"updateCollateralSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"collateralId\",\"type\":\"uint32\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"updateMargin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"initialMarginRatioBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maintainanceMarginRatioBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxVirtualPriceDeviationRatioBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"twapDuration\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isAllowedForTrade\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCrossMargined\",\"type\":\"bool\"},{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"}],\"internalType\":\"struct IClearingHouseStructures.PoolSettings\",\"name\":\"newSettings\",\"type\":\"tuple\"}],\"name\":\"updatePoolSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"updateProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"rangeLiquidationFeeFraction\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tokenLiquidationFeeFraction\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"closeFactorMMThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"partialLiquidationCloseFactorBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"insuranceFundFeeShareBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationSlippageSqrtToleranceBps\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"maxRangeLiquidationFees\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minNotionalLiquidatable\",\"type\":\"uint64\"}],\"internalType\":\"struct IClearingHouseStructures.LiquidationParams\",\"name\":\"_liquidationParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_removeLimitOrderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumOrderNotional\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minRequiredMargin\",\"type\":\"uint256\"}],\"name\":\"updateProtocolSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accountId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"poolId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int128\",\"name\":\"liquidityDelta\",\"type\":\"int128\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceCurrent\",\"type\":\"uint160\"},{\"internalType\":\"uint16\",\"name\":\"slippageToleranceBps\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"closeTokenPosition\",\"type\":\"bool\"},{\"internalType\":\"enum IClearingHouseEnums.LimitOrderType\",\"name\":\"limitOrderType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"settleProfit\",\"type\":\"bool\"}],\"internalType\":\"struct IClearingHouseStructures.LiquidityChangeParams\",\"name\":\"liquidityChangeParams\",\"type\":\"tuple\"}],\"name\":\"updateRangeOrder\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"vTokenAmountOut\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"vQuoteAmountOut\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfPoolsToUpdateInThisTx\",\"type\":\"uint256\"}],\"name\":\"withdrawProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AccessDenied(address)\":[{\"params\":{\"senderAddress\":\"address of msg sender\"}}],\"CollateralDoesNotExist(uint32)\":[{\"params\":{\"collateralId\":\"address of token\"}}],\"CollateralNotAllowedForUse(uint32)\":[{\"params\":{\"collateralId\":\"address of token\"}}],\"IncorrectCollateralAddress(address,address)\":[{\"params\":{\"correctAddress\":\"correct address of collateral token\",\"incorrectAddress\":\"incorrect address of collateral token\"}}],\"InvalidCollateralAddress(address)\":[{\"params\":{\"invalidAddress\":\"invalid address of collateral token\"}}],\"InvalidMulticallOperationType(uint8)\":[{\"params\":{\"multicallOperationType\":\"is the value that is out of bounds\"}}],\"LowNotionalValue(uint256)\":[{\"params\":{\"notionalValue\":\"notional value of txn\"}}],\"PoolDoesNotExist(uint32)\":[{\"params\":{\"poolId\":\"unitialized truncated address supplied\"}}],\"PoolNotAllowedForTrade(uint32)\":[{\"params\":{\"poolId\":\"address of token\"}}]},\"kind\":\"dev\",\"methods\":{\"createAccount()\":{\"returns\":{\"newAccountId\":\"- serial number of the new account created\"}},\"createAccountAndAddMargin(uint32,uint256)\":{\"params\":{\"amount\":\"amount of token to deposit\",\"collateralId\":\"truncated address of collateral token to deposit\"},\"returns\":{\"newAccountId\":\"- serial number of the new account created\"}},\"extsload(bytes32)\":{\"params\":{\"slot\":\"to read from.\"},\"returns\":{\"val\":\"stored at the slot.\"}},\"extsload(bytes32[])\":{\"params\":{\"slots\":\"to read from.\"},\"returns\":{\"_0\":\"values stored at the slots.\"}},\"getAccountMarketValueAndRequiredMargin(uint256,bool)\":{\"details\":\"This method can be used to check if an account is under water or not.     If accountMarketValue < requiredMargin then liquidation can take place.\",\"params\":{\"accountId\":\"the account id\",\"isInitialMargin\":\"true is initial margin, false is maintainance margin\"},\"returns\":{\"marketValue\":\"the market value of the account, due to collateral and positions\",\"requiredMargin\":\"margin needed due to positions\"}},\"getAccountNetProfit(uint256)\":{\"params\":{\"accountId\":\"the account id\"},\"returns\":{\"accountNetProfit\":\"the net profit of the account\"}},\"getAccountNetTokenPosition(uint256,uint32)\":{\"params\":{\"accountId\":\"the account id\",\"poolId\":\"the id of the pool (vETH, ... etc)\"},\"returns\":{\"netPosition\":\"the net position of the account\"}},\"getRealTwapPriceX128(uint32)\":{\"params\":{\"poolId\":\"the id of the pool\"},\"returns\":{\"realPriceX128\":\"the real price of the pool\"}},\"getVirtualTwapPriceX128(uint32)\":{\"params\":{\"poolId\":\"the id of the pool\"},\"returns\":{\"virtualPriceX128\":\"the virtual price of the pool\"}},\"initiateGovernanceTransfer(address)\":{\"params\":{\"newGovernancePending\":\"the new governance address\"}},\"initiateTeamMultisigTransfer(address)\":{\"params\":{\"newTeamMultisigPending\":\"the new team multisig address\"}},\"liquidateLiquidityPositions(uint256)\":{\"details\":\"removes all the active range positions and gives liquidator a percent of notional amount closed + fixedFee\",\"params\":{\"accountId\":\"account id\"}},\"liquidateTokenPosition(uint256,uint32)\":{\"details\":\"transfers the fraction of token position at a discount to current price to liquidators account and gives liquidator some fixedFee\",\"params\":{\"poolId\":\"truncated address of token to withdraw\",\"targetAccountId\":\"account id\"},\"returns\":{\"keeperFee\":\"- amount of fees transferred to keeper\"}},\"multicall(bytes[])\":{\"details\":\"The `msg.value` should not be trusted for any method callable from multicall.\",\"params\":{\"data\":\"The encoded function data for each of the calls to make to this contract\"},\"returns\":{\"results\":\"The results from each of the calls passed in via data\"}},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"removeLimitOrder(uint256,uint32,int24,int24)\":{\"details\":\"checks the position of current price relative to limit order and checks limitOrderType\",\"params\":{\"accountId\":\"account id\",\"poolId\":\"truncated address of token to withdraw\",\"tickLower\":\"liquidity change parameters\",\"tickUpper\":\"liquidity change parameters\"}},\"settleProfit(uint256)\":{\"params\":{\"accountId\":\"account id\"}},\"swapToken(uint256,uint32,(int256,uint160,bool,bool,bool))\":{\"params\":{\"accountId\":\"account id\",\"poolId\":\"truncated address of token to withdraw\",\"swapParams\":\"swap parameters\"}},\"updateMargin(uint256,uint32,int256)\":{\"params\":{\"accountId\":\"account id\",\"amount\":\"amount of token to deposit\",\"collateralId\":\"truncated address of token to deposit\"}},\"updatePoolSettings(uint32,(uint16,uint16,uint16,uint32,bool,bool,address))\":{\"params\":{\"newSettings\":\"updated rage trade pool settings\",\"poolId\":\"rage trade pool id\"}},\"updateProfit(uint256,int256)\":{\"params\":{\"accountId\":\"account id\",\"amount\":\"amount of token to withdraw\"}},\"updateRangeOrder(uint256,uint32,(int24,int24,int128,uint160,uint16,bool,uint8,bool))\":{\"params\":{\"accountId\":\"account id\",\"liquidityChangeParams\":\"liquidity change parameters\",\"poolId\":\"truncated address of token to withdraw\"}},\"withdrawProtocolFee(uint256)\":{\"params\":{\"numberOfPoolsToUpdateInThisTx\":\"number of pools to collect fees from\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"AccessDenied(address)\":[{\"notice\":\"error to denote invalid account access\"}],\"CannotPauseIfUnpauseInProgress()\":[{\"notice\":\"error to denote unpause is in progress, hence cannot pause\"}],\"CannotUnpauseIfPauseInProgress()\":[{\"notice\":\"error to denote pause is in progress, hence cannot unpause\"}],\"CollateralDoesNotExist(uint32)\":[{\"notice\":\"error to denote usage of uninitialized token\"}],\"CollateralNotAllowedForUse(uint32)\":[{\"notice\":\"error to denote usage of unsupported collateral token\"}],\"IncorrectCollateralAddress(address,address)\":[{\"notice\":\"error to denote incorrect address is supplied while updating collateral settings\"}],\"InvalidCollateralAddress(address)\":[{\"notice\":\"error to denote invalid address supplied as a collateral token\"}],\"InvalidMulticallOperationType(uint8)\":[{\"notice\":\"this is errored when the enum (uint8) value is out of bounds\"}],\"InvalidSetting(uint256)\":[{\"notice\":\"error to denote an invalid setting for parameters\"}],\"InvalidTokenLiquidationParameters()\":[{\"notice\":\"error to denote invalid token liquidation (fraction to liquidate> 1)\"}],\"KeeperFeeNotPositive(int256)\":[{\"notice\":\"error to denote that keeper fee is negative or zero\"}],\"LowNotionalValue(uint256)\":[{\"notice\":\"error to denote low notional value of txn\"}],\"NotRageTradeFactory()\":[{\"notice\":\"error to denote that caller is not ragetrade factory\"}],\"PoolDoesNotExist(uint32)\":[{\"notice\":\"error to denote usage of uninitialized pool\"}],\"PoolNotAllowedForTrade(uint32)\":[{\"notice\":\"error to denote usage of unsupported pool\"}],\"SlippageBeyondTolerance()\":[{\"notice\":\"error to denote slippage of txn beyond set threshold\"}],\"ZeroAmount()\":[{\"notice\":\"error to denote that zero amount is passed and it's prohibited\"}]},\"events\":{\"AccountCreated(address,uint256)\":{\"notice\":\"denotes new account creation\"},\"CollateralSettingsUpdated(address,(address,uint32,bool))\":{\"notice\":\"new collateral supported as margin\"},\"PoolSettingsUpdated(uint32,(uint16,uint16,uint16,uint32,bool,bool,address))\":{\"notice\":\"maintainance margin ratio of a pool changed\"},\"ProtocolSettingsUpdated((uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64),uint256,uint256,uint256)\":{\"notice\":\"protocol settings changed\"}},\"kind\":\"user\",\"methods\":{\"acceptGovernanceTransfer()\":{\"notice\":\"Completes governance transfer, on being called by _governancePending.\"},\"acceptTeamMultisigTransfer()\":{\"notice\":\"Completes teamMultisig transfer, on being called by _teamMultisigPending.\"},\"createAccount()\":{\"notice\":\"creates a new account and adds it to the accounts map\"},\"createAccountAndAddMargin(uint32,uint256)\":{\"notice\":\"creates a new account and deposits 'amount' of token associated with 'poolId'\"},\"extsload(bytes32)\":{\"notice\":\"Returns a value from the storage.\"},\"extsload(bytes32[])\":{\"notice\":\"Returns multiple values from storage.\"},\"getAccountMarketValueAndRequiredMargin(uint256,bool)\":{\"notice\":\"Gets the market value and required margin of an account\"},\"getAccountNetProfit(uint256)\":{\"notice\":\"Gets the net profit of an account\"},\"getAccountNetTokenPosition(uint256,uint32)\":{\"notice\":\"Gets the net position of an account\"},\"getRealTwapPriceX128(uint32)\":{\"notice\":\"Gets the real twap price from the respective oracle of the given poolId\"},\"getVirtualTwapPriceX128(uint32)\":{\"notice\":\"Gets the virtual twap price from the respective oracle of the given poolId\"},\"governance()\":{\"notice\":\"Returns the address of the current governance.\"},\"governancePending()\":{\"notice\":\"Returns the address of the current governance.\"},\"initialize(address,address,address,address,address,address,address)\":{\"notice\":\"SYSTEM FUNCTIONS\"},\"initiateGovernanceTransfer(address)\":{\"notice\":\"Initiates governance transfer to a new account (`newGovernancePending`).\"},\"initiateTeamMultisigTransfer(address)\":{\"notice\":\"Initiates teamMultisig transfer to a new account (`newTeamMultisigPending`).\"},\"liquidateLiquidityPositions(uint256)\":{\"notice\":\"keeper call for liquidation of range position\"},\"liquidateTokenPosition(uint256,uint32)\":{\"notice\":\"keeper call for liquidation of token position\"},\"multicall(bytes[])\":{\"notice\":\"Call multiple functions in the current contract and return the data from all of them if they all succeed\"},\"multicallWithSingleMarginCheck(uint256,(uint8,bytes)[])\":{\"notice\":\"MULTICALL\"},\"removeLimitOrder(uint256,uint32,int24,int24)\":{\"notice\":\"keeper call to remove a limit order\"},\"settleProfit(uint256)\":{\"notice\":\"settles the profit/loss made with the settlement token collateral deposits\"},\"swapToken(uint256,uint32,(int256,uint160,bool,bool,bool))\":{\"notice\":\"swaps token associated with 'poolId' by 'amount' (Long if amount>0 else Short)\"},\"teamMultisig()\":{\"notice\":\"Returns the address of the current team multisig.transferTeamMultisig\"},\"teamMultisigPending()\":{\"notice\":\"Returns the address of the current team multisig.transferTeamMultisig\"},\"updateCollateralSettings(address,(address,uint32,bool))\":{\"notice\":\"ADMIN FUNCTIONS\"},\"updateMargin(uint256,uint32,int256)\":{\"notice\":\"deposits 'amount' of token associated with 'poolId'\"},\"updatePoolSettings(uint32,(uint16,uint16,uint16,uint32,bool,bool,address))\":{\"notice\":\"updates the rage trade pool settings\"},\"updateProfit(uint256,int256)\":{\"notice\":\"withdraws 'amount' of settlement token from the profit made\"},\"updateRangeOrder(uint256,uint32,(int24,int24,int128,uint160,uint16,bool,uint8,bool))\":{\"notice\":\"updates range order of token associated with 'poolId' by 'liquidityDelta' (Adds if amount>0 else Removes)also can be used to update limitOrderType\"},\"withdrawProtocolFee(uint256)\":{\"notice\":\"withdraws protocol fees collected in the supplied wrappers to team multisig\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/clearinghouse/ClearingHouse.sol\":\"ClearingHouse\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":4999},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x372b0bc04e3b4c074559bbbfb1317afddb56de5504158ca25a7f9cd403980445\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x041af89e5e60b74e1203d5a34614c9de379726f52ecb8cf064cab78b9fdcdf9d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbbc8ac883ac3c0078ce5ad3e288fbb3ffcc8a30c3a98c0fda0114d64fc44fca2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0xc995bddbca1ae19788db9f8b61e63385edd3fddf89693b612d5abd1a275974d2\",\"license\":\"MIT\"},\"@uniswap/v3-core-0.8-support/contracts/interfaces/IUniswapV3Pool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport {IUniswapV3PoolImmutables} from './pool/IUniswapV3PoolImmutables.sol';\\nimport {IUniswapV3PoolState} from './pool/IUniswapV3PoolState.sol';\\nimport {IUniswapV3PoolDerivedState} from './pool/IUniswapV3PoolDerivedState.sol';\\nimport {IUniswapV3PoolActions} from './pool/IUniswapV3PoolActions.sol';\\nimport {IUniswapV3PoolOwnerActions} from './pool/IUniswapV3PoolOwnerActions.sol';\\nimport {IUniswapV3PoolErrors} from './pool/IUniswapV3PoolErrors.sol';\\nimport {IUniswapV3PoolEvents} from './pool/IUniswapV3PoolEvents.sol';\\n\\n/// @title The interface for a Uniswap V3 Pool\\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\\n/// to the ERC20 specification\\n/// @dev The pool interface is broken up into many smaller pieces\\ninterface IUniswapV3Pool is\\n    IUniswapV3PoolImmutables,\\n    IUniswapV3PoolState,\\n    IUniswapV3PoolDerivedState,\\n    IUniswapV3PoolActions,\\n    IUniswapV3PoolOwnerActions,\\n    IUniswapV3PoolErrors,\\n    IUniswapV3PoolEvents\\n{\\n\\n}\\n\",\"keccak256\":\"0x4e64844c56061cd90e0a80de73534a9166704c43eed579eb83f90bc2780ce968\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/interfaces/pool/IUniswapV3PoolActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Permissionless pool actions\\n/// @notice Contains pool methods that can be called by anyone\\ninterface IUniswapV3PoolActions {\\n    /// @notice Sets the initial price for the pool\\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\\n    function initialize(uint160 sqrtPriceX96) external;\\n\\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\\n    /// @param recipient The address for which the liquidity will be created\\n    /// @param tickLower The lower tick of the position in which to add liquidity\\n    /// @param tickUpper The upper tick of the position in which to add liquidity\\n    /// @param amount The amount of liquidity to mint\\n    /// @param data Any data that should be passed through to the callback\\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    function mint(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount,\\n        bytes calldata data\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Collects tokens owed to a position\\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\n    /// @param recipient The address which should receive the fees collected\\n    /// @param tickLower The lower tick of the position for which to collect fees\\n    /// @param tickUpper The upper tick of the position for which to collect fees\\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n\\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\n    /// @dev Fees must be collected separately via a call to #collect\\n    /// @param tickLower The lower tick of the position for which to burn liquidity\\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\\n    /// @param amount How much liquidity to burn\\n    /// @return amount0 The amount of token0 sent to the recipient\\n    /// @return amount1 The amount of token1 sent to the recipient\\n    function burn(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Swap token0 for token1, or token1 for token0\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\\n    /// @param recipient The address to receive the output of the swap\\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n    /// @param data Any data to be passed through to the callback\\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\\n    /// @param recipient The address which will receive the token0 and token1 amounts\\n    /// @param amount0 The amount of token0 to send\\n    /// @param amount1 The amount of token1 to send\\n    /// @param data Any data to be passed through to the callback\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n\\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\\n    /// the input observationCardinalityNext.\\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\\n}\\n\",\"keccak256\":\"0x9453dd0e7442188667d01d9b65de3f1e14e9511ff3e303179a15f6fc267f7634\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that is not stored\\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\\n/// blockchain. The functions here may have variable gas costs.\\ninterface IUniswapV3PoolDerivedState {\\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\n    /// you must call it with secondsAgos = [3600, 0].\\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\\n    /// timestamp\\n    function observe(uint32[] calldata secondsAgos)\\n        external\\n        view\\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\\n\\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\\n    /// snapshot is taken and the second snapshot is taken.\\n    /// @param tickLower The lower tick of the range\\n    /// @param tickUpper The upper tick of the range\\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\\n        external\\n        view\\n        returns (\\n            int56 tickCumulativeInside,\\n            uint160 secondsPerLiquidityInsideX128,\\n            uint32 secondsInside\\n        );\\n}\\n\",\"keccak256\":\"0xe603ac5b17ecdee73ba2b27efdf386c257a19c14206e87eee77e2017b742d9e5\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/interfaces/pool/IUniswapV3PoolErrors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Errors emitted by a pool\\n/// @notice Contains all events emitted by the pool\\ninterface IUniswapV3PoolErrors {\\n    error LOK();\\n    error TLU();\\n    error TLM();\\n    error TUM();\\n    error AI();\\n    error M0();\\n    error M1();\\n    error AS();\\n    error IIA();\\n    error L();\\n    error F0();\\n    error F1();\\n}\\n\",\"keccak256\":\"0xf80abf13fb1fafc127ba4e792f240dd8ea7c8c893978cdfd8439c27fae9a037b\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/interfaces/pool/IUniswapV3PoolEvents.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Events emitted by a pool\\n/// @notice Contains all events emitted by the pool\\ninterface IUniswapV3PoolEvents {\\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\\n\\n    /// @notice Emitted when liquidity is minted for a given position\\n    /// @param sender The address that minted the liquidity\\n    /// @param owner The owner of the position and recipient of any minted liquidity\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount The amount of liquidity minted to the position range\\n    /// @param amount0 How much token0 was required for the minted liquidity\\n    /// @param amount1 How much token1 was required for the minted liquidity\\n    event Mint(\\n        address sender,\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted when fees are collected by the owner of a position\\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\\n    /// @param owner The owner of the position for which fees are collected\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount0 The amount of token0 fees collected\\n    /// @param amount1 The amount of token1 fees collected\\n    event Collect(\\n        address indexed owner,\\n        address recipient,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount0,\\n        uint128 amount1\\n    );\\n\\n    /// @notice Emitted when a position's liquidity is removed\\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\\n    /// @param owner The owner of the position for which liquidity is removed\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount The amount of liquidity to remove\\n    /// @param amount0 The amount of token0 withdrawn\\n    /// @param amount1 The amount of token1 withdrawn\\n    event Burn(\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted by the pool for any swaps between token0 and token1\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param recipient The address that received the output of the swap\\n    /// @param amount0 The delta of the token0 balance of the pool\\n    /// @param amount1 The delta of the token1 balance of the pool\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\\n    /// @param liquidity The liquidity of the pool after the swap\\n    /// @param tick The log base 1.0001 of price of the pool after the swap\\n    event Swap(\\n        address indexed sender,\\n        address indexed recipient,\\n        int256 amount0,\\n        int256 amount1,\\n        uint160 sqrtPriceX96,\\n        uint128 liquidity,\\n        int24 tick\\n    );\\n\\n    /// @notice Emitted by the pool for any flashes of token0/token1\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param recipient The address that received the tokens from flash\\n    /// @param amount0 The amount of token0 that was flashed\\n    /// @param amount1 The amount of token1 that was flashed\\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\\n    event Flash(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        uint256 paid0,\\n        uint256 paid1\\n    );\\n\\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\\n    /// just before a mint/swap/burn.\\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\\n    event IncreaseObservationCardinalityNext(\\n        uint16 observationCardinalityNextOld,\\n        uint16 observationCardinalityNextNew\\n    );\\n\\n    /// @notice Emitted when the protocol fee is changed by the pool\\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\\n\\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\\n    /// @param sender The address that collects the protocol fees\\n    /// @param recipient The address that receives the collected protocol fees\\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\\n}\\n\",\"keccak256\":\"0x8071514d0fe5d17d6fbd31c191cdfb703031c24e0ece3621d88ab10e871375cd\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that never changes\\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\\ninterface IUniswapV3PoolImmutables {\\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\\n    /// @return The contract address\\n    function factory() external view returns (address);\\n\\n    /// @notice The first of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token1() external view returns (address);\\n\\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\\n    /// @return The fee\\n    function fee() external view returns (uint24);\\n\\n    /// @notice The pool tick spacing\\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// This value is an int24 to avoid casting even though it is always positive.\\n    /// @return The tick spacing\\n    function tickSpacing() external view returns (int24);\\n\\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n    /// @return The max amount of liquidity per tick\\n    function maxLiquidityPerTick() external view returns (uint128);\\n}\\n\",\"keccak256\":\"0xf6e5d2cd1139c4c276bdbc8e1d2b256e456c866a91f1b868da265c6d2685c3f7\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Permissioned pool actions\\n/// @notice Contains pool methods that may only be called by the factory owner\\ninterface IUniswapV3PoolOwnerActions {\\n    /// @notice Set the denominator of the protocol's % share of the fees\\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\\n\\n    /// @notice Collect the protocol fee accrued to the pool\\n    /// @param recipient The address to which collected protocol fees should be sent\\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\\n    /// @return amount0 The protocol fee collected in token0\\n    /// @return amount1 The protocol fee collected in token1\\n    function collectProtocol(\\n        address recipient,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n}\\n\",\"keccak256\":\"0x759b78a2918af9e99e246dc3af084f654e48ef32bb4e4cb8a966aa3dcaece235\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/interfaces/pool/IUniswapV3PoolState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that can change\\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\\n/// per transaction\\ninterface IUniswapV3PoolState {\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n    /// when accessed externally.\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n    /// @return tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n    /// boundary.\\n    /// @return observationIndex The index of the last oracle observation that was written,\\n    /// @return observationCardinality The current maximum number of observations stored in the pool,\\n    /// @return observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n    /// @return feeProtocol The protocol fee for both tokens of the pool.\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n    /// unlocked Whether the pool is currently locked to reentrancy\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\\n    /// @dev Protocol fees will never exceed uint128 max in either token\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice The currently in range liquidity available to the pool\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\n    /// @return The liquidity at the current price of the pool\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice Look up information about a specific tick in the pool\\n    /// @param tick The tick to look up\\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\\n    /// tick upper\\n    /// @return liquidityNet how much liquidity changes when the pool price crosses the tick,\\n    /// @return feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\\n    /// @return feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\\n    /// @return tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\\n    /// @return secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\\n    /// @return secondsOutside the seconds spent on the other side of the tick from the current tick,\\n    /// @return initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\\n    /// a specific position.\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside0X128,\\n            uint256 feeGrowthOutside1X128,\\n            int56 tickCumulativeOutside,\\n            uint160 secondsPerLiquidityOutsideX128,\\n            uint32 secondsOutside,\\n            bool initialized\\n        );\\n\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    /// @notice Returns the information about a position by the position's key\\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\\n    /// @return liquidity The amount of liquidity in the position,\\n    /// @return feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\\n    /// @return feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\\n    /// @return tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\\n    /// @return tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\\n    function positions(bytes32 key)\\n        external\\n        view\\n        returns (\\n            uint128 liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    /// @notice Returns data about a specific observation index\\n    /// @param index The element of the observations array to fetch\\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n    /// ago, rather than at a specific index in the array.\\n    /// @return blockTimestamp The timestamp of the observation,\\n    /// @return tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n    /// @return secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\\n    /// @return initialized whether the observation has been initialized and the values are safe to use\\n    function observations(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint32 blockTimestamp,\\n            int56 tickCumulative,\\n            uint160 secondsPerLiquidityCumulativeX128,\\n            bool initialized\\n        );\\n}\\n\",\"keccak256\":\"0x44fa2ce1182f6c2f6bead3d1737804bf7e112252ae86e0f2e92f9b8249603f43\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint128.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.0;\\n\\n/// @title FixedPoint128\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\nlibrary FixedPoint128 {\\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x2d1f4f73ae0d8f0a210b8d30084659b57c56ac8f2f96011fca36f00a6d417178\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.0;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x0ba8a9b95a956a4050749c0158e928398c447c91469682ca8a7cc7e77a7fe032\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7825565a4bb2a34a1dc96bbfead755785dfb0df8ef81bd934c43023689685645\",\"license\":\"MIT\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y < 2**255);\\n        z = int256(y);\\n    }\\n}\\n\",\"keccak256\":\"0x4c12bf820c0b011f5490a209960ca34dd8af34660ef9e01de0438393d15e3fd8\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/SqrtPriceMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {SafeCast} from './SafeCast.sol';\\n\\nimport {FullMath} from './FullMath.sol';\\nimport {UnsafeMath} from './UnsafeMath.sol';\\nimport {FixedPoint96} from './FixedPoint96.sol';\\n\\n/// @title Functions based on Q64.96 sqrt price and liquidity\\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\\nlibrary SqrtPriceMath {\\n    using SafeCast for uint256;\\n\\n    /// @notice Gets the next sqrt price given a delta of token0\\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\\n    /// price less in order to not send too much output.\\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amount How much of token0 to add or remove from virtual reserves\\n    /// @param add Whether to add or remove the amount of token0\\n    /// @return The price after adding or removing amount, depending on add\\n    function getNextSqrtPriceFromAmount0RoundingUp(\\n        uint160 sqrtPX96,\\n        uint128 liquidity,\\n        uint256 amount,\\n        bool add\\n    ) internal pure returns (uint160) {\\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\\n        if (amount == 0) return sqrtPX96;\\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\\n\\n        if (add) {\\n            unchecked {\\n                uint256 product;\\n                if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\\n                    uint256 denominator = numerator1 + product;\\n                    if (denominator >= numerator1)\\n                        // always fits in 160 bits\\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\\n                }\\n            }\\n            // denominator is checked for overflow\\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\\n        } else {\\n            unchecked {\\n                uint256 product;\\n                // if the product overflows, we know the denominator underflows\\n                // in addition, we must check that the denominator does not underflow\\n                require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\\n                uint256 denominator = numerator1 - product;\\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\\n            }\\n        }\\n    }\\n\\n    /// @notice Gets the next sqrt price given a delta of token1\\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\\n    /// price less in order to not send too much output.\\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\\n    /// @param add Whether to add, or remove, the amount of token1\\n    /// @return The price after adding or removing `amount`\\n    function getNextSqrtPriceFromAmount1RoundingDown(\\n        uint160 sqrtPX96,\\n        uint128 liquidity,\\n        uint256 amount,\\n        bool add\\n    ) internal pure returns (uint160) {\\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\\n        // in both cases, avoid a mulDiv for most inputs\\n        if (add) {\\n            uint256 quotient = (\\n                amount <= type(uint160).max\\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\\n            );\\n\\n            return (uint256(sqrtPX96) + quotient).toUint160();\\n        } else {\\n            uint256 quotient = (\\n                amount <= type(uint160).max\\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\\n            );\\n\\n            require(sqrtPX96 > quotient);\\n            // always fits 160 bits\\n            unchecked {\\n                return uint160(sqrtPX96 - quotient);\\n            }\\n        }\\n    }\\n\\n    /// @notice Gets the next sqrt price given an input amount of token0 or token1\\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amountIn How much of token0, or token1, is being swapped in\\n    /// @param zeroForOne Whether the amount in is token0 or token1\\n    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\\n    function getNextSqrtPriceFromInput(\\n        uint160 sqrtPX96,\\n        uint128 liquidity,\\n        uint256 amountIn,\\n        bool zeroForOne\\n    ) internal pure returns (uint160 sqrtQX96) {\\n        require(sqrtPX96 > 0);\\n        require(liquidity > 0);\\n\\n        // round to make sure that we don't pass the target price\\n        return\\n            zeroForOne\\n                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\\n                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\\n    }\\n\\n    /// @notice Gets the next sqrt price given an output amount of token0 or token1\\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\\n    /// @param sqrtPX96 The starting price before accounting for the output amount\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amountOut How much of token0, or token1, is being swapped out\\n    /// @param zeroForOne Whether the amount out is token0 or token1\\n    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\\n    function getNextSqrtPriceFromOutput(\\n        uint160 sqrtPX96,\\n        uint128 liquidity,\\n        uint256 amountOut,\\n        bool zeroForOne\\n    ) internal pure returns (uint160 sqrtQX96) {\\n        require(sqrtPX96 > 0);\\n        require(liquidity > 0);\\n\\n        // round to make sure that we pass the target price\\n        return\\n            zeroForOne\\n                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\\n                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\\n    }\\n\\n    /// @notice Gets the amount0 delta between two prices\\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param roundUp Whether to round the amount up or down\\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\\n    function getAmount0Delta(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity,\\n        bool roundUp\\n    ) internal pure returns (uint256 amount0) {\\n        unchecked {\\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\\n\\n            require(sqrtRatioAX96 > 0);\\n\\n            return\\n                roundUp\\n                    ? UnsafeMath.divRoundingUp(\\n                        FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),\\n                        sqrtRatioAX96\\n                    )\\n                    : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\\n        }\\n    }\\n\\n    /// @notice Gets the amount1 delta between two prices\\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param roundUp Whether to round the amount up, or down\\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\\n    function getAmount1Delta(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity,\\n        bool roundUp\\n    ) internal pure returns (uint256 amount1) {\\n        unchecked {\\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n            return\\n                roundUp\\n                    ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\\n                    : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\\n        }\\n    }\\n\\n    /// @notice Helper that gets signed token0 delta\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\\n    function getAmount0Delta(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        int128 liquidity\\n    ) internal pure returns (int256 amount0) {\\n        unchecked {\\n            return\\n                liquidity < 0\\n                    ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\\n                    : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\\n        }\\n    }\\n\\n    /// @notice Helper that gets signed token1 delta\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\\n    function getAmount1Delta(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        int128 liquidity\\n    ) internal pure returns (int256 amount1) {\\n        unchecked {\\n            return\\n                liquidity < 0\\n                    ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\\n                    : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe73eb517e348c084771c6204eb698fce95657901454ad0f394acf5192b709b97\",\"license\":\"BUSL-1.1\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    error T();\\n    error R();\\n\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        unchecked {\\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\\n\\n            uint256 ratio = absTick & 0x1 != 0\\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\\n                : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n        }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        unchecked {\\n            // second inequality must be < because the price can never reach the price at the max tick\\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5c57de03a91cc2ec8939865dbbcb0197bb6c353b711075eefd8e0fca5e102129\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core-0.8-support/contracts/libraries/UnsafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Math functions that do not check inputs or outputs\\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\\nlibrary UnsafeMath {\\n    /// @notice Returns ceil(x / y)\\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\\n    /// @param x The dividend\\n    /// @param y The divisor\\n    /// @return z The quotient, ceil(x / y)\\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            z := add(div(x, y), gt(mod(x, y), 0))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f36d7d16348d8c37fe64fda932018d6e5e8acecd054f0f97d32db62d20c6c88\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-periphery/contracts/interfaces/IMulticall.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\n/// @title Multicall interface\\n/// @notice Enables calling multiple methods in a single call to the contract\\ninterface IMulticall {\\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\\n    /// @param data The encoded function data for each of the calls to make to this contract\\n    /// @return results The results from each of the calls passed in via data\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0xa8f9d0061ee730a522dc4bae6bd5cabb3e997e2c5983da183e912bdca93dfa7b\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IClearingHouse.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport { IGovernable } from './IGovernable.sol';\\n\\nimport { IClearingHouseActions } from './clearinghouse/IClearingHouseActions.sol';\\nimport { IClearingHouseCustomErrors } from './clearinghouse/IClearingHouseCustomErrors.sol';\\nimport { IClearingHouseEnums } from './clearinghouse/IClearingHouseEnums.sol';\\nimport { IClearingHouseEvents } from './clearinghouse/IClearingHouseEvents.sol';\\nimport { IClearingHouseOwnerActions } from './clearinghouse/IClearingHouseOwnerActions.sol';\\nimport { IClearingHouseStructures } from './clearinghouse/IClearingHouseStructures.sol';\\nimport { IClearingHouseSystemActions } from './clearinghouse/IClearingHouseSystemActions.sol';\\nimport { IClearingHouseView } from './clearinghouse/IClearingHouseView.sol';\\n\\ninterface IClearingHouse is\\n    IGovernable,\\n    IClearingHouseEnums,\\n    IClearingHouseStructures,\\n    IClearingHouseActions,\\n    IClearingHouseCustomErrors,\\n    IClearingHouseEvents,\\n    IClearingHouseOwnerActions,\\n    IClearingHouseSystemActions,\\n    IClearingHouseView\\n{}\\n\",\"keccak256\":\"0xefcfad57b4aee9e20f34bb2809f69fcea692f67344e301b321ae60fa79f27c21\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IExtsload.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\n/// @title This is an interface to read contract's state that supports extsload.\\ninterface IExtsload {\\n    /// @notice Returns a value from the storage.\\n    /// @param slot to read from.\\n    /// @return value stored at the slot.\\n    function extsload(bytes32 slot) external view returns (bytes32 value);\\n\\n    /// @notice Returns multiple values from storage.\\n    /// @param slots to read from.\\n    /// @return values stored at the slots.\\n    function extsload(bytes32[] memory slots) external view returns (bytes32[] memory);\\n}\\n\",\"keccak256\":\"0x9b2387dbfb081f98a6d21ed1b7297668cda241fc1cea540fc0127f140a982d17\",\"license\":\"MIT\"},\"contracts/interfaces/IGovernable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface IGovernable {\\n    function governance() external view returns (address);\\n\\n    function governancePending() external view returns (address);\\n\\n    function teamMultisig() external view returns (address);\\n\\n    function teamMultisigPending() external view returns (address);\\n\\n    function initiateGovernanceTransfer(address newGovernancePending) external;\\n\\n    function acceptGovernanceTransfer() external;\\n\\n    function initiateTeamMultisigTransfer(address newTeamMultisigPending) external;\\n\\n    function acceptTeamMultisigTransfer() external;\\n}\\n\",\"keccak256\":\"0x28ac4a7bea6877cc7f831047aea9a26d7d30f787f15b1773e020287d06f02b75\",\"license\":\"MIT\"},\"contracts/interfaces/IInsuranceFund.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IInsuranceFund {\\n    function initialize(\\n        IERC20 settlementToken,\\n        address clearingHouse,\\n        string calldata name,\\n        string calldata symbol\\n    ) external;\\n\\n    function claim(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x8ce253b8c14252cdb8a8607f0014dbd70d168b999c061da4db4959c91660bc87\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface IOracle {\\n    function getTwapPriceX128(uint32 twapDuration) external view returns (uint256 priceX128);\\n}\\n\",\"keccak256\":\"0x0b868e6dbb5dbbe067f65dda1a2c405a124142dbd936deeb4cc995ceb9ab232e\",\"license\":\"MIT\"},\"contracts/interfaces/IVPoolWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport { IUniswapV3Pool } from '@uniswap/v3-core-0.8-support/contracts/interfaces/IUniswapV3Pool.sol';\\n\\nimport { IVQuote } from './IVQuote.sol';\\nimport { IVToken } from './IVToken.sol';\\n\\ninterface IVPoolWrapper {\\n    struct InitializeVPoolWrapperParams {\\n        address clearingHouse; // address of clearing house contract (proxy)\\n        IVToken vToken; // address of vToken contract\\n        IVQuote vQuote; // address of vQuote contract\\n        IUniswapV3Pool vPool; // address of Uniswap V3 Pool contract, created using vToken and vQuote\\n        uint24 liquidityFeePips; // liquidity fee fraction (in 1e6)\\n        uint24 protocolFeePips; // protocol fee fraction (in 1e6)\\n    }\\n\\n    struct SwapResult {\\n        int256 amountSpecified; // amount of tokens/vQuote which were specified in the swap request\\n        int256 vTokenIn; // actual amount of vTokens paid by account to the Pool\\n        int256 vQuoteIn; // actual amount of vQuotes paid by account to the Pool\\n        uint256 liquidityFees; // actual amount of fees paid by account to the Pool\\n        uint256 protocolFees; // actual amount of fees paid by account to the Protocol\\n        uint160 sqrtPriceX96Start; // sqrt price at the beginning of the swap\\n        uint160 sqrtPriceX96End; // sqrt price at the end of the swap\\n    }\\n\\n    struct WrapperValuesInside {\\n        int256 sumAX128; // sum of all the A terms in the pool\\n        int256 sumBInsideX128; // sum of all the B terms in side the tick range in the pool\\n        int256 sumFpInsideX128; // sum of all the Fp terms in side the tick range in the pool\\n        uint256 sumFeeInsideX128; // sum of all the fee terms in side the tick range in the pool\\n    }\\n\\n    /// @notice Emitted whenever a swap takes place\\n    /// @param swapResult the swap result values\\n    event Swap(SwapResult swapResult);\\n\\n    /// @notice Emitted whenever liquidity is added\\n    /// @param tickLower the lower tick of the range\\n    /// @param tickUpper the upper tick of the range\\n    /// @param liquidity the amount of liquidity that was added\\n    /// @param vTokenPrincipal the amount of vToken that was sent to UniswapV3Pool\\n    /// @param vQuotePrincipal the mount of vQuote charged was sent to UniswapV3Pool\\n    event Mint(int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 vTokenPrincipal, uint256 vQuotePrincipal);\\n\\n    /// @notice Emitted whenever liquidity is removed\\n    /// @param tickLower the lower tick of the range\\n    /// @param tickUpper the upper tick of the range\\n    /// @param liquidity the amount of liquidity that was removed\\n    /// @param vTokenPrincipal the amount of vToken that was received from UniswapV3Pool\\n    /// @param vQuotePrincipal the mount of vQuote charged was received from UniswapV3Pool\\n    event Burn(int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 vTokenPrincipal, uint256 vQuotePrincipal);\\n\\n    /// @notice Emitted whenever clearing house enquired about the accrued protocol fees\\n    /// @param amount the amount of accrued protocol fees\\n    event AccruedProtocolFeeCollected(uint256 amount);\\n\\n    /// @notice Emitted when governance updates the liquidity fees\\n    /// @param liquidityFeePips the new liquidity fee ratio\\n    event LiquidityFeeUpdated(uint24 liquidityFeePips);\\n\\n    /// @notice Emitted when governance updates the protocol fees\\n    /// @param protocolFeePips the new protocol fee ratio\\n    event ProtocolFeeUpdated(uint24 protocolFeePips);\\n\\n    /// @notice Emitted when funding rate override is updated\\n    /// @param fundingRateOverrideX128 the new funding rate override value\\n    event FundingRateOverrideUpdated(int256 fundingRateOverrideX128);\\n\\n    function initialize(InitializeVPoolWrapperParams memory params) external;\\n\\n    function vPool() external view returns (IUniswapV3Pool);\\n\\n    function getValuesInside(int24 tickLower, int24 tickUpper)\\n        external\\n        view\\n        returns (WrapperValuesInside memory wrapperValuesInside);\\n\\n    function getExtrapolatedValuesInside(int24 tickLower, int24 tickUpper)\\n        external\\n        view\\n        returns (WrapperValuesInside memory wrapperValuesInside);\\n\\n    function swap(\\n        bool swapVTokenForVQuote, // zeroForOne\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (SwapResult memory swapResult);\\n\\n    function mint(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 liquidity\\n    )\\n        external\\n        returns (\\n            uint256 vTokenPrincipal,\\n            uint256 vQuotePrincipal,\\n            WrapperValuesInside memory wrapperValuesInside\\n        );\\n\\n    function burn(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 liquidity\\n    )\\n        external\\n        returns (\\n            uint256 vTokenPrincipal,\\n            uint256 vQuotePrincipal,\\n            WrapperValuesInside memory wrapperValuesInside\\n        );\\n\\n    function getSumAX128() external view returns (int256);\\n\\n    function getExtrapolatedSumAX128() external view returns (int256);\\n\\n    function liquidityFeePips() external view returns (uint24);\\n\\n    function protocolFeePips() external view returns (uint24);\\n\\n    /// @notice Used by clearing house to update funding rate when clearing house is paused or unpaused.\\n    /// @param useZeroFundingRate: used to discount funding payment during the duration ch was paused.\\n    function updateGlobalFundingState(bool useZeroFundingRate) external;\\n\\n    /// @notice Used by clearing house to know how much protocol fee was collected.\\n    /// @return accruedProtocolFeeLast amount of protocol fees accrued since last collection.\\n    /// @dev Does not do any token transfer, just reduces the state in wrapper by accruedProtocolFeeLast.\\n    ///     Clearing house already has the amount of settlement tokens to send to treasury.\\n    function collectAccruedProtocolFee() external returns (uint256 accruedProtocolFeeLast);\\n}\\n\",\"keccak256\":\"0x5f8ffc93fbd71f02a3da23e4b7f2c8d2b4d1f879fe31e6acdcfa787dffc3f72b\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IVQuote.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IVQuote is IERC20 {\\n    function mint(address account, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n\\n    function authorize(address vPoolWrapper) external;\\n}\\n\",\"keccak256\":\"0x77c3c0e1a7a1b9a10633953ac4824f14007af94c323e545b5ff12ef271416774\",\"license\":\"MIT\"},\"contracts/interfaces/IVToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IVToken is IERC20 {\\n    function mint(address account, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n\\n    function setVPoolWrapper(address) external;\\n}\\n\",\"keccak256\":\"0x0ac091c87193f7a5703954bf6484f3a30310b414cdda75cd81a80df23035dfe2\",\"license\":\"MIT\"},\"contracts/interfaces/clearinghouse/IClearingHouseActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport { IClearingHouseStructures } from './IClearingHouseStructures.sol';\\n\\ninterface IClearingHouseActions is IClearingHouseStructures {\\n    /// @notice creates a new account and adds it to the accounts map\\n    /// @return newAccountId - serial number of the new account created\\n    function createAccount() external returns (uint256 newAccountId);\\n\\n    /// @notice deposits 'amount' of token associated with 'poolId'\\n    /// @param accountId account id\\n    /// @param collateralId truncated address of token to deposit\\n    /// @param amount amount of token to deposit\\n    function updateMargin(\\n        uint256 accountId,\\n        uint32 collateralId,\\n        int256 amount\\n    ) external;\\n\\n    /// @notice creates a new account and deposits 'amount' of token associated with 'poolId'\\n    /// @param collateralId truncated address of collateral token to deposit\\n    /// @param amount amount of token to deposit\\n    /// @return newAccountId - serial number of the new account created\\n    function createAccountAndAddMargin(uint32 collateralId, uint256 amount) external returns (uint256 newAccountId);\\n\\n    /// @notice withdraws 'amount' of settlement token from the profit made\\n    /// @param accountId account id\\n    /// @param amount amount of token to withdraw\\n    function updateProfit(uint256 accountId, int256 amount) external;\\n\\n    /// @notice settles the profit/loss made with the settlement token collateral deposits\\n    /// @param accountId account id\\n    function settleProfit(uint256 accountId) external;\\n\\n    /// @notice swaps token associated with 'poolId' by 'amount' (Long if amount>0 else Short)\\n    /// @param accountId account id\\n    /// @param poolId truncated address of token to withdraw\\n    /// @param swapParams swap parameters\\n    function swapToken(\\n        uint256 accountId,\\n        uint32 poolId,\\n        SwapParams memory swapParams\\n    ) external returns (int256 vTokenAmountOut, int256 vQuoteAmountOut);\\n\\n    /// @notice updates range order of token associated with 'poolId' by 'liquidityDelta' (Adds if amount>0 else Removes)\\n    /// @notice also can be used to update limitOrderType\\n    /// @param accountId account id\\n    /// @param poolId truncated address of token to withdraw\\n    /// @param liquidityChangeParams liquidity change parameters\\n    function updateRangeOrder(\\n        uint256 accountId,\\n        uint32 poolId,\\n        LiquidityChangeParams calldata liquidityChangeParams\\n    ) external returns (int256 vTokenAmountOut, int256 vQuoteAmountOut);\\n\\n    /// @notice keeper call to remove a limit order\\n    /// @dev checks the position of current price relative to limit order and checks limitOrderType\\n    /// @param accountId account id\\n    /// @param poolId truncated address of token to withdraw\\n    /// @param tickLower liquidity change parameters\\n    /// @param tickUpper liquidity change parameters\\n    function removeLimitOrder(\\n        uint256 accountId,\\n        uint32 poolId,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external;\\n\\n    /// @notice keeper call for liquidation of range position\\n    /// @dev removes all the active range positions and gives liquidator a percent of notional amount closed + fixedFee\\n    /// @param accountId account id\\n    function liquidateLiquidityPositions(uint256 accountId) external;\\n\\n    /// @notice keeper call for liquidation of token position\\n    /// @dev transfers the fraction of token position at a discount to current price to liquidators account and gives liquidator some fixedFee\\n    /// @param targetAccountId account id\\n    /// @param poolId truncated address of token to withdraw\\n    /// @return keeperFee - amount of fees transferred to keeper\\n    function liquidateTokenPosition(uint256 targetAccountId, uint32 poolId) external returns (int256 keeperFee);\\n}\\n\",\"keccak256\":\"0x21b3310eeee56ef487f2a636019278dc6a59f9d1e40364989caf9013cee0de55\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/clearinghouse/IClearingHouseCustomErrors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport { IVToken } from '../IVToken.sol';\\n\\nimport { IClearingHouseStructures } from './IClearingHouseStructures.sol';\\n\\ninterface IClearingHouseCustomErrors is IClearingHouseStructures {\\n    /// @notice error to denote invalid account access\\n    /// @param senderAddress address of msg sender\\n    error AccessDenied(address senderAddress);\\n\\n    /// @notice error to denote usage of uninitialized token\\n    /// @param collateralId address of token\\n    error CollateralDoesNotExist(uint32 collateralId);\\n\\n    /// @notice error to denote usage of unsupported collateral token\\n    /// @param collateralId address of token\\n    error CollateralNotAllowedForUse(uint32 collateralId);\\n\\n    /// @notice error to denote unpause is in progress, hence cannot pause\\n    error CannotPauseIfUnpauseInProgress();\\n\\n    /// @notice error to denote pause is in progress, hence cannot unpause\\n    error CannotUnpauseIfPauseInProgress();\\n\\n    /// @notice error to denote incorrect address is supplied while updating collateral settings\\n    /// @param incorrectAddress incorrect address of collateral token\\n    /// @param correctAddress correct address of collateral token\\n    error IncorrectCollateralAddress(IERC20 incorrectAddress, IERC20 correctAddress);\\n\\n    /// @notice error to denote invalid address supplied as a collateral token\\n    /// @param invalidAddress invalid address of collateral token\\n    error InvalidCollateralAddress(address invalidAddress);\\n\\n    /// @notice error to denote invalid token liquidation (fraction to liquidate> 1)\\n    error InvalidTokenLiquidationParameters();\\n\\n    /// @notice this is errored when the enum (uint8) value is out of bounds\\n    /// @param multicallOperationType is the value that is out of bounds\\n    error InvalidMulticallOperationType(MulticallOperationType multicallOperationType);\\n\\n    /// @notice error to denote that keeper fee is negative or zero\\n    error KeeperFeeNotPositive(int256 keeperFee);\\n\\n    /// @notice error to denote low notional value of txn\\n    /// @param notionalValue notional value of txn\\n    error LowNotionalValue(uint256 notionalValue);\\n\\n    /// @notice error to denote that caller is not ragetrade factory\\n    error NotRageTradeFactory();\\n\\n    /// @notice error to denote usage of uninitialized pool\\n    /// @param poolId unitialized truncated address supplied\\n    error PoolDoesNotExist(uint32 poolId);\\n\\n    /// @notice error to denote usage of unsupported pool\\n    /// @param poolId address of token\\n    error PoolNotAllowedForTrade(uint32 poolId);\\n\\n    /// @notice error to denote slippage of txn beyond set threshold\\n    error SlippageBeyondTolerance();\\n\\n    /// @notice error to denote that zero amount is passed and it's prohibited\\n    error ZeroAmount();\\n\\n    /// @notice error to denote an invalid setting for parameters\\n    error InvalidSetting(uint256 errorCode);\\n}\\n\",\"keccak256\":\"0x0d0bafa321810a35b83b36d81507937ed5d132c65ee6ef05c92085bd31dd6ca8\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/clearinghouse/IClearingHouseEnums.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IClearingHouseEnums {\\n    enum LimitOrderType {\\n        NONE,\\n        LOWER_LIMIT,\\n        UPPER_LIMIT\\n    }\\n\\n    enum MulticallOperationType {\\n        UPDATE_MARGIN,\\n        UPDATE_PROFIT,\\n        SWAP_TOKEN,\\n        UPDATE_RANGE_ORDER,\\n        REMOVE_LIMIT_ORDER,\\n        LIQUIDATE_LIQUIDITY_POSITIONS,\\n        LIQUIDATE_TOKEN_POSITION\\n    }\\n}\\n\",\"keccak256\":\"0xf9ad0cde3e59a661f70a3af28cc6f8cdba0bcfdbc2f8df3799a1e17c333db4b2\",\"license\":\"MIT\"},\"contracts/interfaces/clearinghouse/IClearingHouseEvents.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport { IVToken } from '../IVToken.sol';\\n\\nimport { IClearingHouseStructures } from './IClearingHouseStructures.sol';\\n\\ninterface IClearingHouseEvents is IClearingHouseStructures {\\n    /// @notice denotes new account creation\\n    /// @param ownerAddress wallet address of account owner\\n    /// @param accountId serial number of the account\\n    event AccountCreated(address indexed ownerAddress, uint256 accountId);\\n\\n    /// @notice new collateral supported as margin\\n    /// @param cTokenInfo collateral token info\\n    event CollateralSettingsUpdated(IERC20 cToken, CollateralSettings cTokenInfo);\\n\\n    /// @notice maintainance margin ratio of a pool changed\\n    /// @param poolId id of the rage trade pool\\n    /// @param settings new settings\\n    event PoolSettingsUpdated(uint32 poolId, PoolSettings settings);\\n\\n    /// @notice protocol settings changed\\n    /// @param liquidationParams liquidation params\\n    /// @param removeLimitOrderFee fee for remove limit order\\n    /// @param minimumOrderNotional minimum order notional\\n    /// @param minRequiredMargin minimum required margin\\n    event ProtocolSettingsUpdated(\\n        LiquidationParams liquidationParams,\\n        uint256 removeLimitOrderFee,\\n        uint256 minimumOrderNotional,\\n        uint256 minRequiredMargin\\n    );\\n\\n    event PausedUpdated(bool paused);\\n}\\n\",\"keccak256\":\"0x40638408c2cf0484b8d11d937181711eb3ea61368133ed92134cd3a84cdf97e6\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/clearinghouse/IClearingHouseOwnerActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport { IVToken } from '../IVToken.sol';\\n\\nimport { IClearingHouseStructures } from './IClearingHouseStructures.sol';\\n\\ninterface IClearingHouseOwnerActions is IClearingHouseStructures {\\n    /// @notice updates the collataral settings\\n    /// @param cToken collateral token\\n    /// @param collateralSettings settings\\n    function updateCollateralSettings(IERC20 cToken, CollateralSettings memory collateralSettings) external;\\n\\n    /// @notice updates the rage trade pool settings\\n    /// @param poolId rage trade pool id\\n    /// @param newSettings updated rage trade pool settings\\n    function updatePoolSettings(uint32 poolId, PoolSettings calldata newSettings) external;\\n\\n    /// @notice updates the protocol settings\\n    /// @param liquidationParams liquidation params\\n    /// @param removeLimitOrderFee fee for remove limit order\\n    /// @param minimumOrderNotional minimum order notional\\n    /// @param minRequiredMargin minimum required margin\\n    function updateProtocolSettings(\\n        LiquidationParams calldata liquidationParams,\\n        uint256 removeLimitOrderFee,\\n        uint256 minimumOrderNotional,\\n        uint256 minRequiredMargin\\n    ) external;\\n\\n    /// @notice withdraws protocol fees collected in the supplied wrappers to team multisig\\n    /// @param numberOfPoolsToUpdateInThisTx number of pools to collect fees from\\n    function withdrawProtocolFee(uint256 numberOfPoolsToUpdateInThisTx) external;\\n}\\n\",\"keccak256\":\"0x1aad0d196e372bca92b21b75013916fea6fdfd74ea000b9909cc4aa305364642\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/clearinghouse/IClearingHouseStructures.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport { IUniswapV3Pool } from '@uniswap/v3-core-0.8-support/contracts/interfaces/IUniswapV3Pool.sol';\\n\\nimport { IOracle } from '../IOracle.sol';\\nimport { IVToken } from '../IVToken.sol';\\nimport { IVPoolWrapper } from '../IVPoolWrapper.sol';\\n\\nimport { IClearingHouseEnums } from './IClearingHouseEnums.sol';\\n\\ninterface IClearingHouseStructures is IClearingHouseEnums {\\n    struct BalanceAdjustments {\\n        int256 vQuoteIncrease; // specifies the increase in vQuote balance\\n        int256 vTokenIncrease; // specifies the increase in token balance\\n        int256 traderPositionIncrease; // specifies the increase in trader position\\n    }\\n\\n    struct Collateral {\\n        IERC20 token; // address of the collateral token\\n        CollateralSettings settings; // collateral settings, changable by governance later\\n    }\\n\\n    struct CollateralSettings {\\n        IOracle oracle; // address of oracle which gives price to be used for collateral\\n        uint32 twapDuration; // duration of the twap in seconds\\n        bool isAllowedForDeposit; // whether the collateral is allowed to be deposited at the moment\\n    }\\n\\n    struct CollateralDepositView {\\n        IERC20 collateral; // address of the collateral token\\n        uint256 balance; // balance of the collateral in the account\\n    }\\n\\n    struct LiquidityChangeParams {\\n        int24 tickLower; // tick lower of the range\\n        int24 tickUpper; // tick upper of the range\\n        int128 liquidityDelta; // positive to add liquidity, negative to remove liquidity\\n        uint160 sqrtPriceCurrent; // hint for virtual price, to prevent sandwitch attack\\n        uint16 slippageToleranceBps; // slippage tolerance in bps, to prevent sandwitch attack\\n        bool closeTokenPosition; // whether to close the token position generated due to the liquidity change\\n        LimitOrderType limitOrderType; // limit order type\\n        bool settleProfit; // whether to settle profit against USDC margin\\n    }\\n\\n    struct LiquidityPositionView {\\n        int24 tickLower; // tick lower of the range\\n        int24 tickUpper; // tick upper of the range\\n        uint128 liquidity; // liquidity in the range by the account\\n        int256 vTokenAmountIn; // amount of token supplied by the account, to calculate net position\\n        int256 sumALastX128; // checkpoint of the term A in funding payment math\\n        int256 sumBInsideLastX128; // checkpoint of the term B in funding payment math\\n        int256 sumFpInsideLastX128; // checkpoint of the term Fp in funding payment math\\n        uint256 sumFeeInsideLastX128; // checkpoint of the trading fees\\n        LimitOrderType limitOrderType; // limit order type\\n    }\\n\\n    struct LiquidationParams {\\n        uint16 rangeLiquidationFeeFraction; // fraction of net token position rm from the range to be charged as liquidation fees (in 1e5)\\n        uint16 tokenLiquidationFeeFraction; // fraction of traded amount of vquote to be charged as liquidation fees (in 1e5)\\n        uint16 closeFactorMMThresholdBps; // fraction the MM threshold for partial liquidation (in 1e4)\\n        uint16 partialLiquidationCloseFactorBps; // fraction the % of position to be liquidated if partial liquidation should occur (in 1e4)\\n        uint16 insuranceFundFeeShareBps; // fraction of the fee share for insurance fund out of the total liquidation fee (in 1e4)\\n        uint16 liquidationSlippageSqrtToleranceBps; // fraction of the max sqrt price slippage threshold (in 1e4) (can be set to - actual price slippage tolerance / 2)\\n        uint64 maxRangeLiquidationFees; // maximum range liquidation fees (in settlement token amount decimals)\\n        uint64 minNotionalLiquidatable; // minimum notional value of position for it to be eligible for partial liquidation (in settlement token amount decimals)\\n    }\\n\\n    struct MulticallOperation {\\n        MulticallOperationType operationType; // operation type\\n        bytes data; // abi encoded data for the operation\\n    }\\n\\n    struct Pool {\\n        IVToken vToken; // address of the vToken, poolId = vToken.truncate()\\n        IUniswapV3Pool vPool; // address of the UniswapV3Pool(token0=vToken, token1=vQuote, fee=500)\\n        IVPoolWrapper vPoolWrapper; // wrapper address\\n        PoolSettings settings; // pool settings, which can be updated by governance later\\n    }\\n\\n    struct PoolSettings {\\n        uint16 initialMarginRatioBps; // margin ratio (1e4) considered for create/update position, removing margin or profit\\n        uint16 maintainanceMarginRatioBps; // margin ratio (1e4) considered for liquidations by keeper\\n        uint16 maxVirtualPriceDeviationRatioBps; // maximum deviation (1e4) from the current virtual price\\n        uint32 twapDuration; // twap duration (seconds) for oracle\\n        bool isAllowedForTrade; // whether the pool is allowed to be traded at the moment\\n        bool isCrossMargined; // whether cross margined is done for positions of this pool\\n        IOracle oracle; // spot price feed twap oracle for this pool\\n    }\\n\\n    struct SwapParams {\\n        int256 amount; // amount of tokens/vQuote to swap\\n        uint160 sqrtPriceLimit; // threshold sqrt price which should not be crossed\\n        bool isNotional; // whether the amount represents vQuote amount\\n        bool isPartialAllowed; // whether to end swap (partial) when sqrtPriceLimit is reached, instead of reverting\\n        bool settleProfit; // whether to settle profit against USDC margin\\n    }\\n\\n    struct TickRange {\\n        int24 tickLower;\\n        int24 tickUpper;\\n    }\\n\\n    struct VTokenPositionView {\\n        uint32 poolId; // id of the pool of which this token position is for\\n        int256 balance; // vTokenLong - vTokenShort\\n        int256 netTraderPosition; // net position due to trades and liquidity change carries\\n        int256 sumALastX128; // checkoint of the term A in funding payment math\\n        LiquidityPositionView[] liquidityPositions; // liquidity positions of the account in the pool\\n    }\\n}\\n\",\"keccak256\":\"0x2898873034245bbb873b239ea1fe46b528897bc0018ccf46c2630f8f50e5cb25\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/clearinghouse/IClearingHouseSystemActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport { IInsuranceFund } from '../IInsuranceFund.sol';\\nimport { IOracle } from '../IOracle.sol';\\nimport { IVQuote } from '../IVQuote.sol';\\nimport { IVToken } from '../IVToken.sol';\\n\\nimport { IClearingHouseStructures } from './IClearingHouseStructures.sol';\\n\\ninterface IClearingHouseSystemActions is IClearingHouseStructures {\\n    /// @notice initializes clearing house contract\\n    /// @param rageTradeFactoryAddress rage trade factory address\\n    /// @param defaultCollateralToken address of default collateral token\\n    /// @param defaultCollateralTokenOracle address of default collateral token oracle\\n    /// @param insuranceFund address of insurance fund\\n    /// @param vQuote address of vQuote\\n    function initialize(\\n        address rageTradeFactoryAddress,\\n        address initialGovernance,\\n        address initialTeamMultisig,\\n        IERC20 defaultCollateralToken,\\n        IOracle defaultCollateralTokenOracle,\\n        IInsuranceFund insuranceFund,\\n        IVQuote vQuote\\n    ) external;\\n\\n    function registerPool(Pool calldata poolInfo) external;\\n}\\n\",\"keccak256\":\"0x55af54c49f58ce14276954987014f03e878933ec0b51dca03e3cd2a2b99bd8d5\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/clearinghouse/IClearingHouseView.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport { IClearingHouseStructures } from './IClearingHouseStructures.sol';\\nimport { IExtsload } from '../IExtsload.sol';\\n\\ninterface IClearingHouseView is IClearingHouseStructures, IExtsload {\\n    /// @notice Gets the market value and required margin of an account\\n    /// @dev This method can be used to check if an account is under water or not.\\n    ///     If accountMarketValue < requiredMargin then liquidation can take place.\\n    /// @param accountId the account id\\n    /// @param isInitialMargin true is initial margin, false is maintainance margin\\n    /// @return accountMarketValue the market value of the account, due to collateral and positions\\n    /// @return requiredMargin margin needed due to positions\\n    function getAccountMarketValueAndRequiredMargin(uint256 accountId, bool isInitialMargin)\\n        external\\n        view\\n        returns (int256 accountMarketValue, int256 requiredMargin);\\n\\n    /// @notice Gets the net profit of an account\\n    /// @param accountId the account id\\n    /// @return accountNetProfit the net profit of the account\\n    function getAccountNetProfit(uint256 accountId) external view returns (int256 accountNetProfit);\\n\\n    /// @notice Gets the net position of an account\\n    /// @param accountId the account id\\n    /// @param poolId the id of the pool (vETH, ... etc)\\n    /// @return netPosition the net position of the account\\n    function getAccountNetTokenPosition(uint256 accountId, uint32 poolId) external view returns (int256 netPosition);\\n\\n    /// @notice Gets the real twap price from the respective oracle of the given poolId\\n    /// @param poolId the id of the pool\\n    /// @return realPriceX128 the real price of the pool\\n    function getRealTwapPriceX128(uint32 poolId) external view returns (uint256 realPriceX128);\\n\\n    /// @notice Gets the virtual twap price from the respective oracle of the given poolId\\n    /// @param poolId the id of the pool\\n    /// @return virtualPriceX128 the virtual price of the pool\\n    function getVirtualTwapPriceX128(uint32 poolId) external view returns (uint256 virtualPriceX128);\\n}\\n\",\"keccak256\":\"0xd9810b0098f0bc1999c4116f8125b4b2d20ff675c1f2a75c55dd1406fa6b0ecd\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/Account.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport { FixedPoint128 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint128.sol';\\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\\nimport { SafeCast } from '@uniswap/v3-core-0.8-support/contracts/libraries/SafeCast.sol';\\n\\nimport { AddressHelper } from './AddressHelper.sol';\\nimport { CollateralDeposit } from './CollateralDeposit.sol';\\nimport { SignedFullMath } from './SignedFullMath.sol';\\nimport { SignedMath } from './SignedMath.sol';\\nimport { LiquidityPositionSet } from './LiquidityPositionSet.sol';\\nimport { LiquidityPosition } from './LiquidityPosition.sol';\\nimport { Protocol } from './Protocol.sol';\\nimport { VTokenPosition } from './VTokenPosition.sol';\\nimport { VTokenPositionSet } from './VTokenPositionSet.sol';\\n\\nimport { IClearingHouseStructures } from '../interfaces/clearinghouse/IClearingHouseStructures.sol';\\nimport { IClearingHouseEnums } from '../interfaces/clearinghouse/IClearingHouseEnums.sol';\\nimport { IVQuote } from '../interfaces/IVQuote.sol';\\nimport { IVToken } from '../interfaces/IVToken.sol';\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/// @title Cross margined account functions\\n/// @dev This library is deployed and used as an external library by ClearingHouse contract.\\nlibrary Account {\\n    using AddressHelper for address;\\n    using FullMath for uint256;\\n    using SafeCast for uint256;\\n    using SignedFullMath for int256;\\n    using SignedMath for int256;\\n\\n    using Account for Account.Info;\\n    using CollateralDeposit for CollateralDeposit.Set;\\n    using LiquidityPositionSet for LiquidityPosition.Set;\\n    using Protocol for Protocol.Info;\\n    using VTokenPosition for VTokenPosition.Info;\\n    using VTokenPositionSet for VTokenPosition.Set;\\n\\n    /// @notice account info for user\\n    /// @param owner specifies the account owner\\n    /// @param tokenPositions is set of all open token positions\\n    /// @param collateralDeposits is set of all deposits\\n    struct Info {\\n        uint96 id;\\n        address owner;\\n        VTokenPosition.Set tokenPositions;\\n        CollateralDeposit.Set collateralDeposits;\\n        uint256[100] _emptySlots; // reserved for adding variables when upgrading logic\\n    }\\n\\n    /**\\n     *  Errors\\n     */\\n\\n    /// @notice error to denote that there is not enough margin for the transaction to go through\\n    /// @param accountMarketValue shows the account market value after the transaction is executed\\n    /// @param totalRequiredMargin shows the total required margin after the transaction is executed\\n    error InvalidTransactionNotEnoughMargin(int256 accountMarketValue, int256 totalRequiredMargin);\\n\\n    /// @notice error to denote that there is not enough profit during profit withdrawal\\n    /// @param totalProfit shows the value of positions at the time of execution after removing amount specified\\n    error InvalidTransactionNotEnoughProfit(int256 totalProfit);\\n\\n    /// @notice error to denote that there is enough margin, hence the liquidation is invalid\\n    /// @param accountMarketValue shows the account market value before liquidation\\n    /// @param totalRequiredMargin shows the total required margin before liquidation\\n    error InvalidLiquidationAccountAboveWater(int256 accountMarketValue, int256 totalRequiredMargin);\\n\\n    /// @notice error to denote that there are active ranges present during token liquidation, hence the liquidation is invalid\\n    /// @param poolId shows the poolId for which range is active\\n    error InvalidLiquidationActiveRangePresent(uint32 poolId);\\n\\n    /// @notice denotes withdrawal of profit in settlement token\\n    /// @param accountId serial number of the account\\n    /// @param amount amount of profit withdrawn\\n    event ProfitUpdated(uint256 indexed accountId, int256 amount);\\n\\n    /**\\n     *  Events\\n     */\\n\\n    /// @notice denotes add or remove of margin\\n    /// @param accountId serial number of the account\\n    /// @param collateralId token in which margin is deposited\\n    /// @param amount amount of tokens deposited\\n    event MarginUpdated(uint256 indexed accountId, uint32 indexed collateralId, int256 amount, bool isSettleProfit);\\n\\n    /// @notice denotes range position liquidation event\\n    /// @dev all range positions are liquidated and the current tokens inside the range are added in as token positions to the account\\n    /// @param accountId serial number of the account\\n    /// @param keeperAddress address of keeper who performed the liquidation\\n    /// @param liquidationFee total liquidation fee charged to the account\\n    /// @param keeperFee total liquidaiton fee paid to the keeper (positive only)\\n    /// @param insuranceFundFee total liquidaiton fee paid to the insurance fund (can be negative in case the account is not enought to cover the fee)\\n    event LiquidityPositionsLiquidated(\\n        uint256 indexed accountId,\\n        address indexed keeperAddress,\\n        int256 liquidationFee,\\n        int256 keeperFee,\\n        int256 insuranceFundFee,\\n        int256 accountMarketValueFinal\\n    );\\n\\n    /// @notice denotes token position liquidation event\\n    /// @dev the selected token position is take from the current account and moved to liquidatorAccount at a discounted prive to current pool price\\n    /// @param accountId serial number of the account\\n    /// @param poolId id of the rage trade pool for whose position was liquidated\\n    /// @param keeperFee total liquidaiton fee paid to keeper\\n    /// @param insuranceFundFee total liquidaiton fee paid to the insurance fund (can be negative in case the account is not enough to cover the fee)\\n    event TokenPositionLiquidated(\\n        uint256 indexed accountId,\\n        uint32 indexed poolId,\\n        int256 keeperFee,\\n        int256 insuranceFundFee,\\n        int256 accountMarketValueFinal\\n    );\\n\\n    /**\\n     *  External methods\\n     */\\n\\n    /// @notice changes deposit balance of 'vToken' by 'amount'\\n    /// @param account account to deposit balance into\\n    /// @param collateralId collateral id of the token\\n    /// @param amount amount of token to deposit or withdraw\\n    /// @param protocol set of all constants and token addresses\\n    /// @param checkMargin true to check if margin is available else false\\n    function updateMargin(\\n        Account.Info storage account,\\n        uint32 collateralId,\\n        int256 amount,\\n        Protocol.Info storage protocol,\\n        bool checkMargin\\n    ) external {\\n        _updateMargin(account, collateralId, amount, protocol, checkMargin, false);\\n    }\\n\\n    /// @notice updates 'amount' of profit generated in settlement token\\n    /// @param account account to remove profit from\\n    /// @param amount amount of profit(settlement token) to add/remove\\n    /// @param protocol set of all constants and token addresses\\n    /// @param checkMargin true to check if margin is available else false\\n    function updateProfit(\\n        Account.Info storage account,\\n        int256 amount,\\n        Protocol.Info storage protocol,\\n        bool checkMargin\\n    ) external {\\n        _updateProfit(account, amount, protocol, checkMargin);\\n    }\\n\\n    function settleProfit(Account.Info storage account, Protocol.Info storage protocol) external {\\n        _settleProfit(account, protocol);\\n    }\\n\\n    /// @notice swaps 'vToken' of token amount equal to 'swapParams.amount'\\n    /// @notice if vTokenAmount>0 then the swap is a long or close short and if vTokenAmount<0 then swap is a short or close long\\n    /// @notice isNotional specifies whether the amount represents token amount (false) or vQuote amount(true)\\n    /// @notice isPartialAllowed specifies whether to revert (false) or to execute a partial swap (true)\\n    /// @notice sqrtPriceLimit threshold sqrt price which if crossed then revert or execute partial swap\\n    /// @param account account to swap tokens for\\n    /// @param poolId id of the pool to swap tokens for\\n    /// @param swapParams parameters for the swap (Includes - amount, sqrtPriceLimit, isNotional, isPartialAllowed)\\n    /// @param protocol set of all constants and token addresses\\n    /// @param checkMargin true to check if margin is available else false\\n    /// @return vTokenAmountOut amount of vToken after swap (user receiving then +ve, user paying then -ve)\\n    /// @return vQuoteAmountOut amount of vQuote after swap (user receiving then +ve, user paying then -ve)\\n    function swapToken(\\n        Account.Info storage account,\\n        uint32 poolId,\\n        IClearingHouseStructures.SwapParams memory swapParams,\\n        Protocol.Info storage protocol,\\n        bool checkMargin\\n    ) external returns (int256 vTokenAmountOut, int256 vQuoteAmountOut) {\\n        // make a swap. vQuoteIn and vTokenAmountOut (in and out wrt uniswap).\\n        // mints erc20 tokens in callback and send to the pool\\n        (vTokenAmountOut, vQuoteAmountOut) = account.tokenPositions.swapToken(account.id, poolId, swapParams, protocol);\\n\\n        if (swapParams.settleProfit) {\\n            account._settleProfit(protocol);\\n        }\\n        // after all the stuff, account should be above water\\n        if (checkMargin) account._checkIfMarginAvailable(true, protocol);\\n    }\\n\\n    /// @notice changes range liquidity 'vToken' of market value equal to 'vTokenNotional'\\n    /// @notice if 'liquidityDelta'>0 then liquidity is added and if 'liquidityChange'<0 then liquidity is removed\\n    /// @notice the liquidity change is reverted if the sqrt price at the time of execution is beyond 'slippageToleranceBps' of 'sqrtPriceCurrent' supplied\\n    /// @notice whenever liquidity change is done the external token position is taken out. If 'closeTokenPosition' is true this is swapped out else it is added to the current token position\\n    /// @param account account to change liquidity\\n    /// @param poolId id of the rage trade pool\\n    /// @param liquidityChangeParams parameters including lower tick, upper tick, liquidity delta, sqrtPriceCurrent, slippageToleranceBps, closeTokenPosition, limit order type\\n    /// @param protocol set of all constants and token addresses\\n    function liquidityChange(\\n        Account.Info storage account,\\n        uint32 poolId,\\n        IClearingHouseStructures.LiquidityChangeParams memory liquidityChangeParams,\\n        Protocol.Info storage protocol,\\n        bool checkMargin\\n    )\\n        external\\n        returns (\\n            int256 vTokenAmountOut,\\n            int256 vQuoteAmountOut,\\n            uint256 notionalValueAbs\\n        )\\n    {\\n        // mint/burn tokens + fee + funding payment\\n        (vTokenAmountOut, vQuoteAmountOut) = account.tokenPositions.liquidityChange(\\n            account.id,\\n            poolId,\\n            liquidityChangeParams,\\n            protocol\\n        );\\n\\n        if (liquidityChangeParams.settleProfit) {\\n            account._settleProfit(protocol);\\n        }\\n        // after all the stuff, account should be above water\\n        if (checkMargin) account._checkIfMarginAvailable(true, protocol);\\n\\n        notionalValueAbs = protocol.getNotionalValue(poolId, vTokenAmountOut, vQuoteAmountOut);\\n    }\\n\\n    /// @notice liquidates all range positions in case the account is under water\\n    ///     charges a liquidation fee to the account and pays partially to the insurance fund and rest to the keeper.\\n    /// @dev insurance fund covers the remaining fee if the account market value is not enough\\n    /// @param account account to liquidate\\n    /// @param protocol set of all constants and token addresses\\n    /// @return keeperFee amount of liquidation fee paid to keeper\\n    /// @return insuranceFundFee amount of liquidation fee paid to insurance fund\\n    /// @return accountMarketValue account market value before liquidation\\n    function liquidateLiquidityPositions(Account.Info storage account, Protocol.Info storage protocol)\\n        external\\n        returns (\\n            int256 keeperFee,\\n            int256 insuranceFundFee,\\n            int256 accountMarketValue\\n        )\\n    {\\n        // check basis maintanace margin\\n        int256 totalRequiredMargin;\\n        uint256 notionalAmountClosed;\\n\\n        (accountMarketValue, totalRequiredMargin) = account._getAccountValueAndRequiredMargin(false, protocol);\\n\\n        // check and revert if account is above water\\n        if (accountMarketValue > totalRequiredMargin) {\\n            revert InvalidLiquidationAccountAboveWater(accountMarketValue, totalRequiredMargin);\\n        }\\n        // liquidate all liquidity positions\\n        notionalAmountClosed = account.tokenPositions.liquidateLiquidityPositions(account.id, protocol);\\n\\n        // compute liquidation fees\\n        (keeperFee, insuranceFundFee) = _computeLiquidationFees(\\n            accountMarketValue,\\n            notionalAmountClosed,\\n            true,\\n            protocol.liquidationParams\\n        );\\n\\n        account._updateVQuoteBalance(-(keeperFee + insuranceFundFee));\\n    }\\n\\n    /// @notice liquidates token position specified by 'poolId' in case account is underwater\\n    ///     charges a liquidation fee to the account and pays partially to the insurance fund and rest to the keeper.\\n    /// @dev closes position uptil a specified slippage threshold in protocol.liquidationParams\\n    /// @dev insurance fund covers the remaining fee if the account market value is not enough\\n    /// @dev if there is range position this reverts (liquidators are supposed to liquidate range positions first)\\n    /// @param account account to liquidate\\n    /// @param poolId id of the pool to liquidate\\n    /// @param protocol set of all constants and token addresses\\n    /// @return keeperFee amount of liquidation fee paid to keeper\\n    /// @return insuranceFundFee amount of liquidation fee paid to insurance fund\\n    function liquidateTokenPosition(\\n        Account.Info storage account,\\n        uint32 poolId,\\n        Protocol.Info storage protocol\\n    ) external returns (int256 keeperFee, int256 insuranceFundFee) {\\n        bool isPartialLiquidation;\\n\\n        // check if there is range position and revert\\n        if (account.tokenPositions.isTokenRangeActive(poolId)) revert InvalidLiquidationActiveRangePresent(poolId);\\n\\n        {\\n            (int256 accountMarketValue, int256 totalRequiredMargin) = account._getAccountValueAndRequiredMargin(\\n                false,\\n                protocol\\n            );\\n\\n            // check and revert if account is above water\\n            if (accountMarketValue > totalRequiredMargin) {\\n                revert InvalidLiquidationAccountAboveWater(accountMarketValue, totalRequiredMargin);\\n            } else if (\\n                // check if account is underwater but within partial liquidation threshold\\n                accountMarketValue >\\n                totalRequiredMargin.mulDiv(protocol.liquidationParams.closeFactorMMThresholdBps, 1e4)\\n            ) {\\n                isPartialLiquidation = true;\\n            }\\n        }\\n\\n        int256 tokensToTrade;\\n        {\\n            // get the net token position and tokensToTrade = -tokenPosition\\n            // since no ranges are supposed to be there so only tokenPosition is in vTokenPositionSet\\n            VTokenPosition.Info storage vTokenPosition = account.tokenPositions.getTokenPosition(poolId, false);\\n            tokensToTrade = -vTokenPosition.balance;\\n            uint256 tokenNotionalValue = tokensToTrade.absUint().mulDiv(\\n                protocol.getCachedVirtualTwapPriceX128(poolId),\\n                FixedPoint128.Q128\\n            );\\n\\n            // check if the token position is less than a certain notional value\\n            // if so then liquidate the whole position even if partial liquidation is allowed\\n            // otherwise do partial liquidation\\n            if (isPartialLiquidation && tokenNotionalValue > protocol.liquidationParams.minNotionalLiquidatable) {\\n                tokensToTrade = tokensToTrade.mulDiv(protocol.liquidationParams.partialLiquidationCloseFactorBps, 1e4);\\n            }\\n        }\\n\\n        int256 accountMarketValueFinal;\\n        {\\n            uint160 sqrtPriceLimit;\\n            {\\n                // calculate sqrt price limit based on slippage threshold\\n                uint160 sqrtTwapPrice = protocol.getVirtualTwapSqrtPriceX96(poolId);\\n                if (tokensToTrade > 0) {\\n                    sqrtPriceLimit = uint256(sqrtTwapPrice)\\n                        .mulDiv(1e4 + protocol.liquidationParams.liquidationSlippageSqrtToleranceBps, 1e4)\\n                        .toUint160();\\n                } else {\\n                    sqrtPriceLimit = uint256(sqrtTwapPrice)\\n                        .mulDiv(1e4 - protocol.liquidationParams.liquidationSlippageSqrtToleranceBps, 1e4)\\n                        .toUint160();\\n                }\\n            }\\n\\n            // close position uptil sqrt price limit\\n            (, int256 vQuoteAmountSwapped) = account.tokenPositions.swapToken(\\n                account.id,\\n                poolId,\\n                IClearingHouseStructures.SwapParams({\\n                    amount: tokensToTrade,\\n                    sqrtPriceLimit: sqrtPriceLimit,\\n                    isNotional: false,\\n                    isPartialAllowed: true,\\n                    settleProfit: false\\n                }),\\n                protocol\\n            );\\n\\n            // get the account market value after closing the position\\n            accountMarketValueFinal = account._getAccountValue(protocol);\\n\\n            // compute liquidation fees\\n            (keeperFee, insuranceFundFee) = _computeLiquidationFees(\\n                accountMarketValueFinal,\\n                vQuoteAmountSwapped.absUint(),\\n                false,\\n                protocol.liquidationParams\\n            );\\n        }\\n\\n        // deduct liquidation fees from account\\n        account._updateVQuoteBalance(-(keeperFee + insuranceFundFee));\\n\\n        emit TokenPositionLiquidated(account.id, poolId, keeperFee, insuranceFundFee, accountMarketValueFinal);\\n    }\\n\\n    /// @notice removes limit order based on the current price position (keeper call)\\n    /// @param account account to liquidate\\n    /// @param poolId id of the pool for the range\\n    /// @param tickLower lower tick index for the range\\n    /// @param tickUpper upper tick index for the range\\n    /// @param protocol platform constants\\n    function removeLimitOrder(\\n        Account.Info storage account,\\n        uint32 poolId,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint256 limitOrderFee,\\n        Protocol.Info storage protocol\\n    ) external {\\n        account.tokenPositions.removeLimitOrder(account.id, poolId, tickLower, tickUpper, protocol);\\n\\n        account._updateVQuoteBalance(-int256(limitOrderFee));\\n    }\\n\\n    /**\\n     *  External view methods\\n     */\\n\\n    /// @notice returns market value for the account positions based on current market conditions\\n    /// @param account account to check\\n    /// @param protocol set of all constants and token addresses\\n    /// @return accountPositionProfits total market value of all the positions (token ) and deposits\\n    function getAccountPositionProfits(Account.Info storage account, Protocol.Info storage protocol)\\n        external\\n        view\\n        returns (int256 accountPositionProfits)\\n    {\\n        return account._getAccountPositionProfits(protocol);\\n    }\\n\\n    /// @notice returns market value and required margin for the account based on current market conditions\\n    /// @dev (In case requiredMargin < minRequiredMargin then requiredMargin = minRequiredMargin)\\n    /// @param account account to check\\n    /// @param isInitialMargin true to use initial margin factor and false to use maintainance margin factor for calcualtion of required margin\\n    /// @param protocol set of all constants and token addresses\\n    /// @return accountMarketValue total market value of all the positions (token ) and deposits\\n    /// @return totalRequiredMargin total margin required to keep the account above selected margin requirement (intial/maintainance)\\n    function getAccountValueAndRequiredMargin(\\n        Account.Info storage account,\\n        bool isInitialMargin,\\n        Protocol.Info storage protocol\\n    ) external view returns (int256 accountMarketValue, int256 totalRequiredMargin) {\\n        return account._getAccountValueAndRequiredMargin(isInitialMargin, protocol);\\n    }\\n\\n    /// @notice checks if market value > required margin else revert with InvalidTransactionNotEnoughMargin\\n    /// @param account account to check\\n    /// @param isInitialMargin true to use initialMarginFactor and false to use maintainance margin factor for calcualtion of required margin\\n    /// @param protocol set of all constants and token addresses\\n    function checkIfMarginAvailable(\\n        Account.Info storage account,\\n        bool isInitialMargin,\\n        Protocol.Info storage protocol\\n    ) external view {\\n        (int256 accountMarketValue, int256 totalRequiredMargin) = account._getAccountValueAndRequiredMargin(\\n            isInitialMargin,\\n            protocol\\n        );\\n        if (accountMarketValue < totalRequiredMargin)\\n            revert InvalidTransactionNotEnoughMargin(accountMarketValue, totalRequiredMargin);\\n    }\\n\\n    /// @notice checks if profit is available to withdraw settlement token (token value of all positions > 0) else revert with InvalidTransactionNotEnoughProfit\\n    /// @param account account to check\\n    /// @param protocol set of all constants and token addresses\\n    function checkIfProfitAvailable(Account.Info storage account, Protocol.Info storage protocol) external view {\\n        _checkIfProfitAvailable(account, protocol);\\n    }\\n\\n    /// @notice gets information about all the collateral and positions in the account\\n    /// @param account ref to the account state\\n    /// @param protocol ref to the protocol state\\n    /// @return owner of the account\\n    /// @return vQuoteBalance amount of vQuote in the account\\n    /// @return collateralDeposits list of all the collateral amounts\\n    /// @return tokenPositions list of all the token and liquidity positions\\n    function getInfo(Account.Info storage account, Protocol.Info storage protocol)\\n        external\\n        view\\n        returns (\\n            address owner,\\n            int256 vQuoteBalance,\\n            IClearingHouseStructures.CollateralDepositView[] memory collateralDeposits,\\n            IClearingHouseStructures.VTokenPositionView[] memory tokenPositions\\n        )\\n    {\\n        owner = account.owner;\\n        collateralDeposits = account.collateralDeposits.getInfo(protocol);\\n        (vQuoteBalance, tokenPositions) = account.tokenPositions.getInfo();\\n    }\\n\\n    /// @notice gets the net position of the account for a given pool\\n    /// @param account ref to the account state\\n    /// @param poolId id of the pool\\n    /// @param protocol ref to the protocol state\\n    /// @return netPosition net position of the account for the pool\\n    function getNetPosition(\\n        Account.Info storage account,\\n        uint32 poolId,\\n        Protocol.Info storage protocol\\n    ) external view returns (int256 netPosition) {\\n        return account.tokenPositions.getNetPosition(poolId, protocol);\\n    }\\n\\n    /**\\n     *  Internal methods\\n     */\\n\\n    function updateAccountPoolPrices(Account.Info storage account, Protocol.Info storage protocol) internal {\\n        account.tokenPositions.updateOpenPoolPrices(protocol);\\n    }\\n\\n    /// @notice settles profit or loss for the account\\n    /// @param account ref to the account state\\n    /// @param protocol ref to the protocol state\\n    function _settleProfit(Account.Info storage account, Protocol.Info storage protocol) internal {\\n        int256 profits = account._getAccountPositionProfits(protocol);\\n        uint32 settlementCollateralId = AddressHelper.truncate(protocol.settlementToken);\\n        if (profits > 0) {\\n            account._updateProfit(-profits, protocol, false);\\n            account._updateMargin({\\n                collateralId: settlementCollateralId,\\n                amount: profits,\\n                protocol: protocol,\\n                checkMargin: false,\\n                isSettleProfit: true\\n            });\\n        } else if (profits < 0) {\\n            uint256 balance = account.collateralDeposits.getBalance(settlementCollateralId);\\n            uint256 profitAbsUint = uint256(-profits);\\n            uint256 balanceToUpdate = balance > profitAbsUint ? profitAbsUint : balance;\\n            if (balanceToUpdate > 0) {\\n                account._updateMargin({\\n                    collateralId: settlementCollateralId,\\n                    amount: -balanceToUpdate.toInt256(),\\n                    protocol: protocol,\\n                    checkMargin: false,\\n                    isSettleProfit: true\\n                });\\n                account._updateProfit(balanceToUpdate.toInt256(), protocol, false);\\n            }\\n        }\\n    }\\n\\n    /// @notice updates 'amount' of profit generated in settlement token\\n    /// @param account account to remove profit from\\n    /// @param amount amount of profit(settlement token) to add/remove\\n    /// @param protocol set of all constants and token addresses\\n    /// @param checkMargin true to check if margin is available else false\\n    function _updateProfit(\\n        Account.Info storage account,\\n        int256 amount,\\n        Protocol.Info storage protocol,\\n        bool checkMargin\\n    ) internal {\\n        account._updateVQuoteBalance(amount);\\n\\n        if (checkMargin && amount < 0) {\\n            account._checkIfProfitAvailable(protocol);\\n            account._checkIfMarginAvailable(true, protocol);\\n        }\\n\\n        emit ProfitUpdated(account.id, amount);\\n    }\\n\\n    /// @notice changes deposit balance of 'vToken' by 'amount'\\n    /// @param account account to deposit balance into\\n    /// @param collateralId collateral id of the token\\n    /// @param amount amount of token to deposit or withdraw\\n    /// @param protocol set of all constants and token addresses\\n    /// @param checkMargin true to check if margin is available else false\\n    function _updateMargin(\\n        Account.Info storage account,\\n        uint32 collateralId,\\n        int256 amount,\\n        Protocol.Info storage protocol,\\n        bool checkMargin,\\n        bool isSettleProfit\\n    ) internal {\\n        if (amount > 0) {\\n            account.collateralDeposits.increaseBalance(collateralId, uint256(amount));\\n        } else {\\n            account.collateralDeposits.decreaseBalance(collateralId, uint256(-amount));\\n            if (checkMargin) account._checkIfMarginAvailable(true, protocol);\\n        }\\n\\n        emit MarginUpdated(account.id, collateralId, amount, isSettleProfit);\\n    }\\n\\n    /// @notice updates the vQuote balance for 'account' by 'amount'\\n    /// @param account pointer to 'account' struct\\n    /// @param amount amount of balance to update\\n    /// @return balanceAdjustments vToken and vQuote balance changes of the account\\n    function _updateVQuoteBalance(Account.Info storage account, int256 amount)\\n        internal\\n        returns (IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments)\\n    {\\n        balanceAdjustments = IClearingHouseStructures.BalanceAdjustments(amount, 0, 0);\\n        account.tokenPositions.vQuoteBalance += balanceAdjustments.vQuoteIncrease;\\n    }\\n\\n    /**\\n     *  Internal view methods\\n     */\\n\\n    /// @notice ensures that the account has enough margin to cover the required margin\\n    /// @param account ref to the account state\\n    /// @param protocol ref to the protocol state\\n    function _checkIfMarginAvailable(\\n        Account.Info storage account,\\n        bool isInitialMargin,\\n        Protocol.Info storage protocol\\n    ) internal view {\\n        (int256 accountMarketValue, int256 totalRequiredMargin) = account._getAccountValueAndRequiredMargin(\\n            isInitialMargin,\\n            protocol\\n        );\\n        if (accountMarketValue < totalRequiredMargin)\\n            revert InvalidTransactionNotEnoughMargin(accountMarketValue, totalRequiredMargin);\\n    }\\n\\n    /// @notice ensures that the account has non negative profit\\n    /// @param account ref to the account state\\n    /// @param protocol ref to the protocol state\\n    function _checkIfProfitAvailable(Account.Info storage account, Protocol.Info storage protocol) internal view {\\n        int256 totalPositionValue = account._getAccountPositionProfits(protocol);\\n        if (totalPositionValue < 0) revert InvalidTransactionNotEnoughProfit(totalPositionValue);\\n    }\\n\\n    /// @notice gets the amount of account's position profits\\n    /// @param account ref to the account state\\n    /// @param protocol ref to the protocol state\\n    function _getAccountPositionProfits(Account.Info storage account, Protocol.Info storage protocol)\\n        internal\\n        view\\n        returns (int256 accountPositionProfits)\\n    {\\n        accountPositionProfits = account.tokenPositions.getAccountMarketValue(protocol);\\n    }\\n\\n    /// @notice gets market value for the account based on current market conditions\\n    /// @param account ref to the account state\\n    /// @param protocol set of all constants and token addresses\\n    /// @return accountMarketValue total market value of all the positions (token ) and deposits\\n    function _getAccountValue(Account.Info storage account, Protocol.Info storage protocol)\\n        internal\\n        view\\n        returns (int256 accountMarketValue)\\n    {\\n        accountMarketValue = account._getAccountPositionProfits(protocol);\\n        accountMarketValue += account.collateralDeposits.marketValue(protocol);\\n        return (accountMarketValue);\\n    }\\n\\n    /// @notice gets market value and req margin for the account based on current market conditions\\n    /// @param account ref to the account state\\n    /// @param isInitialMargin true to use initialMarginFactor and false to use maintainance margin factor for calcualtion of required margin\\n    /// @param protocol set of all constants and token addresses\\n    /// @return accountMarketValue total market value of all the positions (token) and deposits\\n    /// @return totalRequiredMargin total required margin for the account\\n    function _getAccountValueAndRequiredMargin(\\n        Account.Info storage account,\\n        bool isInitialMargin,\\n        Protocol.Info storage protocol\\n    ) internal view returns (int256 accountMarketValue, int256 totalRequiredMargin) {\\n        accountMarketValue = account._getAccountValue(protocol);\\n\\n        totalRequiredMargin = account.tokenPositions.getRequiredMargin(isInitialMargin, protocol);\\n        if (!account.tokenPositions.isEmpty()) {\\n            totalRequiredMargin = totalRequiredMargin < int256(protocol.minRequiredMargin)\\n                ? int256(protocol.minRequiredMargin)\\n                : totalRequiredMargin;\\n        }\\n        return (accountMarketValue, totalRequiredMargin);\\n    }\\n\\n    /// @notice checks if 'account' is initialized\\n    /// @param account pointer to 'account' struct\\n    function _isInitialized(Account.Info storage account) internal view returns (bool) {\\n        return !account.owner.isZero();\\n    }\\n\\n    /**\\n     *  Internal pure methods\\n     */\\n\\n    /// @notice computes keeper fee and insurance fund fee in case of liquidity position liquidation\\n    /// @dev keeperFee = liquidationFee*(1-insuranceFundFeeShare)\\n    /// @dev insuranceFundFee = accountMarketValue - keeperFee (if accountMarketValue is not enough to cover the fees) else insurancFundFee = liquidationFee - keeperFee\\n    /// @param accountMarketValue market value of account\\n    /// @param notionalAmountClosed notional value of position closed\\n    /// @param isRangeLiquidation - true for range liquidation and false for token liquidation\\n    /// @param liquidationParams parameters including insuranceFundFeeShareBps\\n    /// @return keeperFee map of vTokens allowed on the platform\\n    /// @return insuranceFundFee poolwrapper for token\\n    function _computeLiquidationFees(\\n        int256 accountMarketValue,\\n        uint256 notionalAmountClosed,\\n        bool isRangeLiquidation,\\n        IClearingHouseStructures.LiquidationParams memory liquidationParams\\n    ) internal pure returns (int256 keeperFee, int256 insuranceFundFee) {\\n        uint256 liquidationFee;\\n\\n        if (isRangeLiquidation) {\\n            liquidationFee = notionalAmountClosed.mulDiv(liquidationParams.rangeLiquidationFeeFraction, 1e5);\\n            if (liquidationParams.maxRangeLiquidationFees < liquidationFee)\\n                liquidationFee = liquidationParams.maxRangeLiquidationFees;\\n        } else {\\n            liquidationFee = notionalAmountClosed.mulDiv(liquidationParams.tokenLiquidationFeeFraction, 1e5);\\n        }\\n\\n        int256 liquidationFeeInt = liquidationFee.toInt256();\\n\\n        keeperFee = liquidationFeeInt.mulDiv(1e4 - liquidationParams.insuranceFundFeeShareBps, 1e4);\\n        if (accountMarketValue - liquidationFeeInt < 0) {\\n            insuranceFundFee = accountMarketValue - keeperFee;\\n        } else {\\n            insuranceFundFee = liquidationFeeInt - keeperFee;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x64e2fafb0b8e346baded62ab407edea1bcc6526bb35a1edadd9a79fcf02f7706\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/AddressHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport { IVToken } from '../interfaces/IVToken.sol';\\n\\n/// @title Address helper functions\\nlibrary AddressHelper {\\n    /// @notice converts address to uint32, using the least significant 32 bits\\n    /// @param addr Address to convert\\n    /// @return truncated last 4 bytes of the address\\n    function truncate(address addr) internal pure returns (uint32 truncated) {\\n        assembly {\\n            truncated := and(addr, 0xffffffff)\\n        }\\n    }\\n\\n    /// @notice converts IERC20 contract to uint32\\n    /// @param addr contract\\n    /// @return truncated last 4 bytes of the address\\n    function truncate(IERC20 addr) internal pure returns (uint32 truncated) {\\n        return truncate(address(addr));\\n    }\\n\\n    /// @notice checks if two addresses are equal\\n    /// @param a first address\\n    /// @param b second address\\n    /// @return true if addresses are equal\\n    function eq(address a, address b) internal pure returns (bool) {\\n        return a == b;\\n    }\\n\\n    /// @notice checks if addresses of two IERC20 contracts are equal\\n    /// @param a first contract\\n    /// @param b second contract\\n    /// @return true if addresses are equal\\n    function eq(IERC20 a, IERC20 b) internal pure returns (bool) {\\n        return eq(address(a), address(b));\\n    }\\n\\n    /// @notice checks if an address is zero\\n    /// @param a address to check\\n    /// @return true if address is zero\\n    function isZero(address a) internal pure returns (bool) {\\n        return a == address(0);\\n    }\\n\\n    /// @notice checks if address of an IERC20 contract is zero\\n    /// @param a contract to check\\n    /// @return true if address is zero\\n    function isZero(IERC20 a) internal pure returns (bool) {\\n        return isZero(address(a));\\n    }\\n}\\n\",\"keccak256\":\"0xe4a82de57fe35749b5baf34991cea5356c55dc015d58514a758adafe28af8686\",\"license\":\"MIT\"},\"contracts/libraries/BatchedLoop.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { Math } from '@openzeppelin/contracts/utils/math/Math.sol';\\n\\n/// @title Batched Loop Library\\n/// @notice Aids to perform a lengthy loop in seperate txs\\nlibrary BatchedLoop {\\n    uint256 constant NULL = 0;\\n\\n    struct Info {\\n        uint256 progress; // of array element to resume the progress from\\n    }\\n\\n    /// @notice Resumes the loop from where it left of previously\\n    /// @param loop: the loop object to resume (this is storage ref and val is mutated)\\n    /// @param startAt: the index to start from\\n    /// @param endBefore: the index to end at\\n    /// @param batchSize: number of iterations to perform in this batch\\n    /// @param execute: the function to execute for each iteration\\n    /// @dev translates to: for(uint i = startAt; i < endBefore; i++) { execute(i); }\\n    function iterate(\\n        BatchedLoop.Info storage loop,\\n        uint256 startAt,\\n        uint256 endBefore,\\n        uint256 batchSize,\\n        function(uint256) execute\\n    ) internal returns (bool completed) {\\n        // resume the loop from the stored progress else use startAt\\n        uint256 from = loop.progress;\\n        if (from == NULL) from = startAt;\\n\\n        // use endBefore if batchSize is zero, else calculate end index\\n        uint256 to = batchSize == NULL ? endBefore : Math.min(from + batchSize, endBefore);\\n\\n        // executes upto (to - 1)\\n        while (from < to) {\\n            execute(from);\\n            from++;\\n        }\\n\\n        if (completed = (to == endBefore)) {\\n            // if loop was completed then reset the progress\\n            loop.progress = NULL;\\n        } else {\\n            // store the progress if partial execution of the loop\\n            loop.progress = to;\\n        }\\n    }\\n\\n    /// @notice Checks if the loop is in progress\\n    /// @param loop: the loop object\\n    /// @return true if the loop is in progress else false\\n    function isInProgress(BatchedLoop.Info storage loop) internal view returns (bool) {\\n        return loop.progress != NULL;\\n    }\\n}\\n\",\"keccak256\":\"0xd3a852c38f34d78ba8a17f9d48f3b2f4410c779c4cd05db57b4563d5c6b391d2\",\"license\":\"MIT\"},\"contracts/libraries/Bisection.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/// @title Bisection Method\\n/// @notice https://en.wikipedia.org/wiki/Bisection_method\\nlibrary Bisection {\\n    error SolutionOutOfBounds(uint256 y_target, uint160 x_lower, uint160 x_upper);\\n\\n    /// @notice Finds the solution to the equation f(x) = y_target using the bisection method\\n    /// @param f: strictly increasing function f: uint160 -> uint256\\n    /// @param y_target: the target value of f(x)\\n    /// @param x_lower: the lower bound for x\\n    /// @param x_upper: the upper bound for x\\n    /// @return x_target: the rounded down solution to the equation f(x) = y_target\\n    function findSolution(\\n        function(uint160) pure returns (uint256) f,\\n        uint256 y_target,\\n        uint160 x_lower,\\n        uint160 x_upper\\n    ) internal pure returns (uint160) {\\n        // compute y at the bounds\\n        uint256 y_lower = f(x_lower);\\n        uint256 y_upper = f(x_upper);\\n\\n        // if y is out of the bounds then revert\\n        if (y_target < y_lower || y_target > y_upper) revert SolutionOutOfBounds(y_target, x_lower, x_upper);\\n\\n        // bisect repeatedly until the solution is within an error of 1 unit\\n        uint256 y_mid;\\n        uint160 x_mid;\\n        while (x_upper - x_lower > 1) {\\n            x_mid = x_lower + (x_upper - x_lower) / 2;\\n            y_mid = f(x_mid);\\n            if (y_mid > y_target) {\\n                x_upper = x_mid;\\n                y_upper = y_mid;\\n            } else {\\n                x_lower = x_mid;\\n                y_lower = y_mid;\\n            }\\n        }\\n\\n        // at this point, x_upper - x_lower is either 0 or 1\\n        // if it is 1 then check if x_upper is the solution, else return x_lower as the rounded down solution\\n        return x_lower != x_upper && f(x_upper) == y_target ? x_upper : x_lower;\\n    }\\n}\\n\",\"keccak256\":\"0xae30dfb5c8806a894fd086f494cd19bb7019c8bc865522b5ec407b7d71b8e4bc\",\"license\":\"MIT\"},\"contracts/libraries/Block.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface ArbSys {\\n    /**\\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\n     * @return block number as int\\n     */\\n    function arbBlockNumber() external view returns (uint256);\\n}\\n\\n/// @title Library for getting block number for the current chain\\nlibrary Block {\\n    /// @notice Get block number\\n    /// @return block number as uint32\\n    function number() internal view returns (uint32) {\\n        uint256 chainId = block.chainid;\\n        if (chainId == 42161 || chainId == 421611 || chainId == 421612) {\\n            return uint32(ArbSys(address(100)).arbBlockNumber());\\n        } else {\\n            return uint32(block.number);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x19d3884d36aa0f25572b23843633a8b018509e37c7b75852b163a94cfc3aca4a\",\"license\":\"MIT\"},\"contracts/libraries/CollateralDeposit.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport { FixedPoint128 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint128.sol';\\nimport { SafeCast } from '@uniswap/v3-core-0.8-support/contracts/libraries/SafeCast.sol';\\n\\nimport { Protocol } from './Protocol.sol';\\nimport { AddressHelper } from './AddressHelper.sol';\\nimport { SignedFullMath } from './SignedFullMath.sol';\\nimport { Uint32L8ArrayLib } from './Uint32L8Array.sol';\\n\\nimport { IClearingHouseStructures } from '../interfaces/clearinghouse/IClearingHouseStructures.sol';\\n\\n/// @title Collateral deposit set functions\\nlibrary CollateralDeposit {\\n    using AddressHelper for address;\\n    using SafeCast for uint256;\\n    using SignedFullMath for int256;\\n    using Uint32L8ArrayLib for uint32[8];\\n\\n    error InsufficientCollateralBalance();\\n\\n    struct Set {\\n        // Fixed length array of collateralId = collateralAddress.truncate()\\n        // Supports upto 8 different collaterals in an account.\\n        // Collision is possible, i.e. collateralAddress1.truncate() == collateralAddress2.truncate()\\n        // However the possibility is 1/2**32, which is negligible.\\n        // There are checks that prevent use of a different collateralAddress for a given collateralId.\\n        // If there is a geniune collision, a wrapper for the ERC20 token can deployed such that\\n        // there are no collisions with wrapper and the wrapped ERC20 can be used as collateral.\\n        uint32[8] active; // array of collateralIds\\n        mapping(uint32 => uint256) deposits; // collateralId => deposit amount\\n        uint256[100] _emptySlots; // reserved for adding variables when upgrading logic\\n    }\\n\\n    function getBalance(CollateralDeposit.Set storage set, uint32 collateralId) internal view returns (uint256) {\\n        return set.deposits[collateralId];\\n    }\\n\\n    /// @notice Increase the deposit amount of a given collateralId\\n    /// @param set CollateralDepositSet of the account\\n    /// @param collateralId The collateralId of the collateral to increase the deposit amount of\\n    /// @param amount The amount to increase the deposit amount of the collateral by\\n    function increaseBalance(\\n        CollateralDeposit.Set storage set,\\n        uint32 collateralId,\\n        uint256 amount\\n    ) internal {\\n        set.active.include(collateralId);\\n\\n        set.deposits[collateralId] += amount;\\n    }\\n\\n    /// @notice Decrease the deposit amount of a given collateralId\\n    /// @param set CollateralDepositSet of the account\\n    /// @param collateralId The collateralId of the collateral to decrease the deposit amount of\\n    /// @param amount The amount to decrease the deposit amount of the collateral by\\n    function decreaseBalance(\\n        CollateralDeposit.Set storage set,\\n        uint32 collateralId,\\n        uint256 amount\\n    ) internal {\\n        if (set.deposits[collateralId] < amount) revert InsufficientCollateralBalance();\\n        set.deposits[collateralId] -= amount;\\n\\n        if (set.deposits[collateralId] == 0) {\\n            set.active.exclude(collateralId);\\n        }\\n    }\\n\\n    /// @notice Get the market value of all the collateral deposits in settlementToken denomination\\n    /// @param set CollateralDepositSet of the account\\n    /// @param protocol Global protocol state\\n    /// @return The market value of all the collateral deposits in settlementToken denomination\\n    function marketValue(CollateralDeposit.Set storage set, Protocol.Info storage protocol)\\n        internal\\n        view\\n        returns (int256)\\n    {\\n        int256 accountMarketValue;\\n        for (uint8 i = 0; i < set.active.length; i++) {\\n            uint32 collateralId = set.active[i];\\n\\n            if (collateralId == 0) break;\\n            IClearingHouseStructures.Collateral storage collateral = protocol.collaterals[collateralId];\\n\\n            accountMarketValue += set.deposits[collateralId].toInt256().mulDiv(\\n                collateral.settings.oracle.getTwapPriceX128(collateral.settings.twapDuration),\\n                FixedPoint128.Q128\\n            );\\n        }\\n        return accountMarketValue;\\n    }\\n\\n    /// @notice Get information about all the collateral deposits\\n    /// @param set CollateralDepositSet of the account\\n    /// @param protocol Global protocol state\\n    /// @return collateralDeposits Information about all the collateral deposits\\n    function getInfo(CollateralDeposit.Set storage set, Protocol.Info storage protocol)\\n        internal\\n        view\\n        returns (IClearingHouseStructures.CollateralDepositView[] memory collateralDeposits)\\n    {\\n        uint256 numberOfTokenPositions = set.active.numberOfNonZeroElements();\\n        collateralDeposits = new IClearingHouseStructures.CollateralDepositView[](numberOfTokenPositions);\\n\\n        for (uint256 i = 0; i < numberOfTokenPositions; i++) {\\n            collateralDeposits[i].collateral = protocol.collaterals[set.active[i]].token;\\n            collateralDeposits[i].balance = set.deposits[set.active[i]];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa0444f3ae1a5555e1d31ab25d0df8e61d4760295c325ae63ca244efc72dede99\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/FundingPayment.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport { FixedPoint128 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint128.sol';\\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\\n\\nimport { SafeCast } from './SafeCast.sol';\\nimport { SignedFullMath } from './SignedFullMath.sol';\\n\\n/// @title Funding payment functions\\n/// @notice Funding Payment Logic used to distribute the FP bill paid by traders among the LPs in the liquidity range\\nlibrary FundingPayment {\\n    using FullMath for uint256;\\n    using SafeCast for uint256;\\n    using SignedFullMath for int256;\\n\\n    struct Info {\\n        // FR * P * dt\\n        int256 sumAX128;\\n        // trade token amount / liquidity\\n        int256 sumBX128;\\n        // sum(a * sumB)\\n        int256 sumFpX128;\\n        // time when state was last updated\\n        uint48 timestampLast;\\n    }\\n\\n    event FundingPaymentStateUpdated(\\n        FundingPayment.Info fundingPayment,\\n        int256 fundingRateX128,\\n        uint256 virtualPriceX128\\n    );\\n\\n    /// @notice Calculates the funding rate based on prices\\n    /// @param realPriceX128 spot price of token\\n    /// @param virtualPriceX128 futures price of token\\n    function getFundingRate(uint256 realPriceX128, uint256 virtualPriceX128)\\n        internal\\n        pure\\n        returns (int256 fundingRateX128)\\n    {\\n        int256 priceDeltaX128 = virtualPriceX128.toInt256() - realPriceX128.toInt256();\\n        return priceDeltaX128.mulDiv(FixedPoint128.Q128, realPriceX128) / 1 days;\\n    }\\n\\n    /// @notice Used to update the state of the funding payment whenever a trade takes place\\n    /// @param info pointer to the funding payment state\\n    /// @param vTokenAmount trade token amount\\n    /// @param liquidity active liquidity in the range during the trade (step)\\n    /// @param blockTimestamp timestamp of current block\\n    /// @param fundingRateX128 the constant funding rate to apply for the duration between timestampLast and blockTimestamp\\n    /// @param virtualPriceX128 futures price of token\\n    function update(\\n        FundingPayment.Info storage info,\\n        int256 vTokenAmount,\\n        uint256 liquidity,\\n        uint48 blockTimestamp,\\n        int256 fundingRateX128,\\n        uint256 virtualPriceX128\\n    ) internal {\\n        int256 a = nextAX128(info.timestampLast, blockTimestamp, fundingRateX128, virtualPriceX128);\\n        info.sumFpX128 += a.mulDivRoundingDown(info.sumBX128, int256(FixedPoint128.Q128));\\n        info.sumAX128 += a;\\n        info.sumBX128 += vTokenAmount.mulDiv(int256(FixedPoint128.Q128), int256(liquidity));\\n        info.timestampLast = blockTimestamp;\\n\\n        emit FundingPaymentStateUpdated(info, fundingRateX128, virtualPriceX128);\\n    }\\n\\n    /// @notice Used to get the rate of funding payment for the duration between last trade and this trade\\n    /// @dev Positive A value means at this duration, longs pay shorts. Negative means shorts pay longs.\\n    /// @param timestampLast start timestamp of duration\\n    /// @param blockTimestamp end timestamp of duration\\n    /// @param virtualPriceX128 futures price of token\\n    /// @param fundingRateX128 the constant funding rate to apply for the duration between timestampLast and blockTimestamp\\n    /// @return aX128 value called \\\"a\\\" (see funding payment math documentation)\\n    function nextAX128(\\n        uint48 timestampLast,\\n        uint48 blockTimestamp,\\n        int256 fundingRateX128,\\n        uint256 virtualPriceX128\\n    ) internal pure returns (int256 aX128) {\\n        return fundingRateX128.mulDiv(virtualPriceX128, FixedPoint128.Q128) * int48(blockTimestamp - timestampLast);\\n    }\\n\\n    function extrapolatedSumAX128(\\n        int256 sumAX128,\\n        uint48 timestampLast,\\n        uint48 blockTimestamp,\\n        int256 fundingRateX128,\\n        uint256 virtualPriceX128\\n    ) internal pure returns (int256) {\\n        return sumAX128 + nextAX128(timestampLast, blockTimestamp, fundingRateX128, virtualPriceX128);\\n    }\\n\\n    /// @notice Extrapolates (updates) the value of sumFp by adding the missing component to it using sumAGlobalX128\\n    /// @param sumAX128 sumA value that is recorded from global at some point in time\\n    /// @param sumBX128 sumB value that is recorded from global at same point in time as sumA\\n    /// @param sumFpX128 sumFp value that is recorded from global at same point in time as sumA and sumB\\n    /// @param sumAGlobalX128 latest sumA value (taken from global), used to extrapolate the sumFp\\n    function extrapolatedSumFpX128(\\n        int256 sumAX128,\\n        int256 sumBX128,\\n        int256 sumFpX128,\\n        int256 sumAGlobalX128\\n    ) internal pure returns (int256) {\\n        return sumFpX128 + sumBX128.mulDiv(sumAGlobalX128 - sumAX128, int256(FixedPoint128.Q128));\\n    }\\n\\n    /// @notice Positive bill is charged from LPs, Negative bill is rewarded to LPs\\n    /// @param sumAX128 latest value of sumA (to be taken from global state)\\n    /// @param sumFpInsideX128 latest value of sumFp inside range (to be computed using global state + tick state)\\n    /// @param sumALastX128 value of sumA when LP updated their liquidity last time\\n    /// @param sumBInsideLastX128 value of sumB inside range when LP updated their liquidity last time\\n    /// @param sumFpInsideLastX128 value of sumFp inside range when LP updated their liquidity last time\\n    /// @param liquidity amount of liquidity which was constant for LP in the time duration\\n    /// @return amount of vQuote tokens that should be charged if positive\\n    function bill(\\n        int256 sumAX128,\\n        int256 sumFpInsideX128,\\n        int256 sumALastX128,\\n        int256 sumBInsideLastX128,\\n        int256 sumFpInsideLastX128,\\n        uint256 liquidity\\n    ) internal pure returns (int256) {\\n        return\\n            (sumFpInsideX128 - extrapolatedSumFpX128(sumALastX128, sumBInsideLastX128, sumFpInsideLastX128, sumAX128))\\n                .mulDivRoundingDown(liquidity, FixedPoint128.Q128);\\n    }\\n\\n    /// @notice Positive bill is charged from Traders, Negative bill is rewarded to Traders\\n    /// @param sumAX128 latest value of sumA (to be taken from global state)\\n    /// @param sumALastX128 value of sumA when trader updated their netTraderPosition\\n    /// @param netTraderPosition oken amount which should be constant for time duration since sumALastX128 was recorded\\n    /// @return amount of vQuote tokens that should be charged if positive\\n    function bill(\\n        int256 sumAX128,\\n        int256 sumALastX128,\\n        int256 netTraderPosition\\n    ) internal pure returns (int256) {\\n        return netTraderPosition.mulDiv((sumAX128 - sumALastX128), int256(FixedPoint128.Q128));\\n    }\\n}\\n\",\"keccak256\":\"0x7b189aa450af422d069760e170f6631fb48333e0664806aa5cb833a6bc68d339\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/LiquidityPosition.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport { SqrtPriceMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/SqrtPriceMath.sol';\\nimport { TickMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/TickMath.sol';\\nimport { SafeCast } from '@uniswap/v3-core-0.8-support/contracts/libraries/SafeCast.sol';\\nimport { FixedPoint96 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint96.sol';\\n\\nimport { FixedPoint128 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint128.sol';\\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\\nimport { IUniswapV3Pool } from '@uniswap/v3-core-0.8-support/contracts/interfaces/IUniswapV3Pool.sol';\\n\\nimport { PriceMath } from './PriceMath.sol';\\nimport { Protocol } from './Protocol.sol';\\nimport { SignedFullMath } from './SignedFullMath.sol';\\nimport { UniswapV3PoolHelper } from './UniswapV3PoolHelper.sol';\\nimport { FundingPayment } from './FundingPayment.sol';\\n\\nimport { IClearingHouseStructures } from '../interfaces/clearinghouse/IClearingHouseStructures.sol';\\nimport { IClearingHouseEnums } from '../interfaces/clearinghouse/IClearingHouseEnums.sol';\\nimport { IVPoolWrapper } from '../interfaces/IVPoolWrapper.sol';\\n\\n/// @title Liquidity position functions\\nlibrary LiquidityPosition {\\n    using FullMath for uint256;\\n    using PriceMath for uint160;\\n    using SafeCast for uint256;\\n    using SignedFullMath for int256;\\n    using UniswapV3PoolHelper for IUniswapV3Pool;\\n\\n    using LiquidityPosition for LiquidityPosition.Info;\\n    using Protocol for Protocol.Info;\\n\\n    struct Set {\\n        // multiple per pool because it's non-fungible, allows for 4 billion LP positions lifetime\\n        uint48[5] active;\\n        // concat(tickLow,tickHigh)\\n        mapping(uint48 => LiquidityPosition.Info) positions;\\n        uint256[100] _emptySlots; // reserved for adding variables when upgrading logic\\n    }\\n\\n    struct Info {\\n        //Extra boolean to check if it is limit order and uint to track limit price.\\n        IClearingHouseEnums.LimitOrderType limitOrderType;\\n        // the tick range of the position;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        // the liquidity of the position\\n        uint128 liquidity;\\n        int256 vTokenAmountIn;\\n        // funding payment checkpoints\\n        int256 sumALastX128;\\n        int256 sumBInsideLastX128;\\n        int256 sumFpInsideLastX128;\\n        // fee growth inside\\n        uint256 sumFeeInsideLastX128;\\n        uint256[100] _emptySlots; // reserved for adding variables when upgrading logic\\n    }\\n\\n    error LP_AlreadyInitialized();\\n    error LP_IneligibleLimitOrderRemoval();\\n\\n    /// @notice denotes liquidity add/remove\\n    /// @param accountId serial number of the account\\n    /// @param poolId address of token whose position was taken\\n    /// @param tickLower lower tick of the range updated\\n    /// @param tickUpper upper tick of the range updated\\n    /// @param liquidityDelta change in liquidity value\\n    /// @param limitOrderType the type of range position\\n    /// @param vTokenAmountOut amount of tokens that account received (positive) or paid (negative)\\n    /// @param vQuoteAmountOut amount of vQuote tokens that account received (positive) or paid (negative)\\n    event LiquidityChanged(\\n        uint256 indexed accountId,\\n        uint32 indexed poolId,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int128 liquidityDelta,\\n        IClearingHouseEnums.LimitOrderType limitOrderType,\\n        int256 vTokenAmountOut,\\n        int256 vQuoteAmountOut,\\n        uint160 sqrtPriceX96\\n    );\\n\\n    /// @param accountId serial number of the account\\n    /// @param poolId address of token for which funding was paid\\n    /// @param tickLower lower tick of the range for which funding was paid\\n    /// @param tickUpper upper tick of the range for which funding was paid\\n    /// @param amount amount of funding paid (negative) or received (positive)\\n    /// @param sumALastX128 val of sum of the term A in funding payment math, when op took place\\n    /// @param sumBInsideLastX128 val of sum of the term B in funding payment math, when op took place\\n    /// @param sumFpInsideLastX128 val of sum of the term Fp in funding payment math, when op took place\\n    /// @param sumFeeInsideLastX128 val of sum of the term Fee in wrapper, when op took place\\n    event LiquidityPositionFundingPaymentRealized(\\n        uint256 indexed accountId,\\n        uint32 indexed poolId,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int256 amount,\\n        int256 sumALastX128,\\n        int256 sumBInsideLastX128,\\n        int256 sumFpInsideLastX128,\\n        uint256 sumFeeInsideLastX128\\n    );\\n\\n    /// @notice denotes fee payment for a range / token position\\n    /// @dev for a token position tickLower = tickUpper = 0\\n    /// @param accountId serial number of the account\\n    /// @param poolId address of token for which fee was paid\\n    /// @param tickLower lower tick of the range for which fee was paid\\n    /// @param tickUpper upper tick of the range for which fee was paid\\n    /// @param amount amount of fee paid (negative) or received (positive)\\n    event LiquidityPositionEarningsRealized(\\n        uint256 indexed accountId,\\n        uint32 indexed poolId,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int256 amount\\n    );\\n\\n    /**\\n     *  Internal methods\\n     */\\n\\n    /// @notice initializes a new LiquidityPosition.Info struct\\n    /// @dev Reverts if the position is already initialized\\n    /// @param position storage pointer of the position to initialize\\n    /// @param tickLower lower tick of the range\\n    /// @param tickUpper upper tick of the range\\n    function initialize(\\n        LiquidityPosition.Info storage position,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal {\\n        if (position.isInitialized()) {\\n            revert LP_AlreadyInitialized();\\n        }\\n\\n        position.tickLower = tickLower;\\n        position.tickUpper = tickUpper;\\n    }\\n\\n    /// @notice changes liquidity for a position, informs pool wrapper and does necessary bookkeeping\\n    /// @param position storage ref of the position to update\\n    /// @param accountId serial number of the account, used to emit event\\n    /// @param poolId id of the pool for which position was updated\\n    /// @param liquidityDelta change in liquidity value\\n    /// @param balanceAdjustments memory ref to the balance adjustments struct\\n    /// @param protocol ref to the protocol state\\n    function liquidityChange(\\n        LiquidityPosition.Info storage position,\\n        uint256 accountId,\\n        uint32 poolId,\\n        int128 liquidityDelta,\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments,\\n        Protocol.Info storage protocol\\n    ) internal {\\n        int256 vTokenPrincipal;\\n        int256 vQuotePrincipal;\\n\\n        IVPoolWrapper wrapper = protocol.vPoolWrapper(poolId);\\n        IVPoolWrapper.WrapperValuesInside memory wrapperValuesInside;\\n\\n        // calls wrapper to mint/burn liquidity\\n        if (liquidityDelta > 0) {\\n            uint256 vTokenPrincipal_;\\n            uint256 vQuotePrincipal_;\\n            (vTokenPrincipal_, vQuotePrincipal_, wrapperValuesInside) = wrapper.mint(\\n                position.tickLower,\\n                position.tickUpper,\\n                uint128(liquidityDelta)\\n            );\\n            vTokenPrincipal = vTokenPrincipal_.toInt256();\\n            vQuotePrincipal = vQuotePrincipal_.toInt256();\\n        } else {\\n            uint256 vTokenPrincipal_;\\n            uint256 vQuotePrincipal_;\\n            (vTokenPrincipal_, vQuotePrincipal_, wrapperValuesInside) = wrapper.burn(\\n                position.tickLower,\\n                position.tickUpper,\\n                uint128(-liquidityDelta)\\n            );\\n            vTokenPrincipal = -vTokenPrincipal_.toInt256();\\n            vQuotePrincipal = -vQuotePrincipal_.toInt256();\\n        }\\n\\n        // calculate funding payment and liquidity fees then update checkpoints\\n        position.update(accountId, poolId, wrapperValuesInside, balanceAdjustments);\\n\\n        // adjust in the token acounts\\n        balanceAdjustments.vQuoteIncrease -= vQuotePrincipal;\\n        balanceAdjustments.vTokenIncrease -= vTokenPrincipal;\\n\\n        // emit the event\\n        uint160 sqrtPriceCurrent = protocol.vPool(poolId).sqrtPriceCurrent();\\n        emitLiquidityChangeEvent(\\n            position,\\n            accountId,\\n            poolId,\\n            liquidityDelta,\\n            sqrtPriceCurrent,\\n            -vTokenPrincipal,\\n            -vQuotePrincipal\\n        );\\n\\n        // update trader position increase\\n        int256 vTokenAmountCurrent;\\n        {\\n            (vTokenAmountCurrent, ) = position.vTokenAmountsInRange(sqrtPriceCurrent, false);\\n            balanceAdjustments.traderPositionIncrease += (vTokenAmountCurrent - position.vTokenAmountIn);\\n        }\\n\\n        uint128 liquidityNew = position.liquidity;\\n        if (liquidityDelta > 0) {\\n            liquidityNew += uint128(liquidityDelta);\\n        } else if (liquidityDelta < 0) {\\n            liquidityNew -= uint128(-liquidityDelta);\\n        }\\n\\n        if (liquidityNew != 0) {\\n            // update state\\n            position.liquidity = liquidityNew;\\n            position.vTokenAmountIn = vTokenAmountCurrent + vTokenPrincipal;\\n        } else {\\n            // clear all the state\\n            position.liquidity = 0;\\n            position.vTokenAmountIn = 0;\\n            position.sumALastX128 = 0;\\n            position.sumBInsideLastX128 = 0;\\n            position.sumFpInsideLastX128 = 0;\\n            position.sumFeeInsideLastX128 = 0;\\n        }\\n    }\\n\\n    /// @notice updates the position with latest checkpoints, and realises fees and fp\\n    /// @dev fees and funding payment are not immediately adjusted in token balance state,\\n    ///     balanceAdjustments struct is used to pass the necessary values to caller.\\n    /// @param position storage ref of the position to update\\n    /// @param accountId serial number of the account, used to emit event\\n    /// @param poolId id of the pool for which position was updated\\n    /// @param wrapperValuesInside range checkpoint values from the wrapper\\n    /// @param balanceAdjustments memory ref to the balance adjustments struct\\n    function update(\\n        LiquidityPosition.Info storage position,\\n        uint256 accountId,\\n        uint32 poolId,\\n        IVPoolWrapper.WrapperValuesInside memory wrapperValuesInside,\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments\\n    ) internal {\\n        int256 fundingPayment = position.unrealizedFundingPayment(\\n            wrapperValuesInside.sumAX128,\\n            wrapperValuesInside.sumFpInsideX128\\n        );\\n        balanceAdjustments.vQuoteIncrease += fundingPayment;\\n\\n        int256 unrealizedLiquidityFee = position.unrealizedFees(wrapperValuesInside.sumFeeInsideX128).toInt256();\\n        balanceAdjustments.vQuoteIncrease += unrealizedLiquidityFee;\\n\\n        // updating checkpoints\\n        position.sumALastX128 = wrapperValuesInside.sumAX128;\\n        position.sumBInsideLastX128 = wrapperValuesInside.sumBInsideX128;\\n        position.sumFpInsideLastX128 = wrapperValuesInside.sumFpInsideX128;\\n        position.sumFeeInsideLastX128 = wrapperValuesInside.sumFeeInsideX128;\\n\\n        emit LiquidityPositionFundingPaymentRealized(\\n            accountId,\\n            poolId,\\n            position.tickLower,\\n            position.tickUpper,\\n            fundingPayment,\\n            wrapperValuesInside.sumAX128,\\n            wrapperValuesInside.sumBInsideX128,\\n            wrapperValuesInside.sumFpInsideX128,\\n            wrapperValuesInside.sumFeeInsideX128\\n        );\\n\\n        emit LiquidityPositionEarningsRealized(\\n            accountId,\\n            poolId,\\n            position.tickLower,\\n            position.tickUpper,\\n            unrealizedLiquidityFee\\n        );\\n    }\\n\\n    /**\\n     *  Internal view methods\\n     */\\n\\n    /// @notice ensures that limit order removal is valid, else reverts\\n    /// @param info storage ref of the position to check\\n    /// @param currentTick current tick in the pool\\n    function checkValidLimitOrderRemoval(LiquidityPosition.Info storage info, int24 currentTick) internal view {\\n        if (\\n            !((currentTick >= info.tickUpper &&\\n                info.limitOrderType == IClearingHouseEnums.LimitOrderType.UPPER_LIMIT) ||\\n                (currentTick <= info.tickLower &&\\n                    info.limitOrderType == IClearingHouseEnums.LimitOrderType.LOWER_LIMIT))\\n        ) {\\n            revert LP_IneligibleLimitOrderRemoval();\\n        }\\n    }\\n\\n    /// @notice checks if the position is initialized\\n    /// @param info storage ref of the position to check\\n    /// @return true if the position is initialized\\n    function isInitialized(LiquidityPosition.Info storage info) internal view returns (bool) {\\n        return info.tickLower != 0 || info.tickUpper != 0;\\n    }\\n\\n    /// @notice calculates the long side risk for the position\\n    /// @param position storage ref of the position to check\\n    /// @param valuationSqrtPriceX96 valuation sqrt price in x96\\n    /// @return long side risk\\n    function longSideRisk(LiquidityPosition.Info storage position, uint160 valuationSqrtPriceX96)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint160 sqrtPriceLowerX96 = TickMath.getSqrtRatioAtTick(position.tickLower);\\n        uint160 sqrtPriceUpperX96 = TickMath.getSqrtRatioAtTick(position.tickUpper);\\n        uint256 longPositionExecutionPriceX128;\\n        {\\n            uint160 sqrtPriceUpperMinX96 = valuationSqrtPriceX96 <= sqrtPriceUpperX96\\n                ? valuationSqrtPriceX96\\n                : sqrtPriceUpperX96;\\n            uint160 sqrtPriceLowerMinX96 = valuationSqrtPriceX96 <= sqrtPriceLowerX96\\n                ? valuationSqrtPriceX96\\n                : sqrtPriceLowerX96;\\n            longPositionExecutionPriceX128 = uint256(sqrtPriceLowerMinX96).mulDiv(sqrtPriceUpperMinX96, 1 << 64);\\n        }\\n\\n        uint256 maxNetLongPosition;\\n        {\\n            uint256 maxLongTokens = SqrtPriceMath.getAmount0Delta(\\n                sqrtPriceLowerX96,\\n                sqrtPriceUpperX96,\\n                position.liquidity,\\n                true\\n            );\\n            //\\n            if (position.vTokenAmountIn >= 0) {\\n                //maxLongTokens in range should always be >= amount that got added to range, equality occurs when range was added at pCurrent = pHigh\\n                assert(maxLongTokens >= uint256(position.vTokenAmountIn));\\n                maxNetLongPosition = maxLongTokens - uint256(position.vTokenAmountIn);\\n            } else maxNetLongPosition = maxLongTokens + uint256(-1 * position.vTokenAmountIn);\\n        }\\n\\n        return maxNetLongPosition.mulDiv(longPositionExecutionPriceX128, FixedPoint128.Q128);\\n    }\\n\\n    /// @notice calculates the market value for the position using a provided price\\n    /// @param position storage ref of the position to check\\n    /// @param valuationSqrtPriceX96 valuation sqrt price to be used\\n    /// @param wrapper address of the pool wrapper\\n    /// @return marketValue_ the market value of the position\\n    function marketValue(\\n        LiquidityPosition.Info storage position,\\n        uint160 valuationSqrtPriceX96,\\n        IVPoolWrapper wrapper\\n    ) internal view returns (int256 marketValue_) {\\n        {\\n            (int256 vTokenAmount, int256 vQuoteAmount) = position.vTokenAmountsInRange(valuationSqrtPriceX96, false);\\n            uint256 priceX128 = valuationSqrtPriceX96.toPriceX128();\\n            marketValue_ = vTokenAmount.mulDiv(priceX128, FixedPoint128.Q128) + vQuoteAmount;\\n        }\\n        // adding fees\\n        IVPoolWrapper.WrapperValuesInside memory wrapperValuesInside = wrapper.getExtrapolatedValuesInside(\\n            position.tickLower,\\n            position.tickUpper\\n        );\\n        marketValue_ += position.unrealizedFees(wrapperValuesInside.sumFeeInsideX128).toInt256();\\n        marketValue_ += position.unrealizedFundingPayment(\\n            wrapperValuesInside.sumAX128,\\n            wrapperValuesInside.sumFpInsideX128\\n        );\\n    }\\n\\n    /// @notice calculates the max net position for the position\\n    /// @param position storage ref of the position to check\\n    /// @return maxNetPosition the max net position of the position\\n    function maxNetPosition(LiquidityPosition.Info storage position) internal view returns (uint256) {\\n        uint160 sqrtPriceLowerX96 = TickMath.getSqrtRatioAtTick(position.tickLower);\\n        uint160 sqrtPriceUpperX96 = TickMath.getSqrtRatioAtTick(position.tickUpper);\\n\\n        if (position.vTokenAmountIn >= 0)\\n            return\\n                SqrtPriceMath.getAmount0Delta(sqrtPriceLowerX96, sqrtPriceUpperX96, position.liquidity, true) -\\n                uint256(position.vTokenAmountIn);\\n        else\\n            return\\n                SqrtPriceMath.getAmount0Delta(sqrtPriceLowerX96, sqrtPriceUpperX96, position.liquidity, true) +\\n                uint256(-1 * position.vTokenAmountIn);\\n    }\\n\\n    /// @notice calculates the current net position for the position\\n    /// @param position storage ref of the position to check\\n    /// @param sqrtPriceCurrent the current sqrt price, used to calculate net position\\n    /// @return netTokenPosition the current net position of the position\\n    function netPosition(LiquidityPosition.Info storage position, uint160 sqrtPriceCurrent)\\n        internal\\n        view\\n        returns (int256 netTokenPosition)\\n    {\\n        int256 vTokenAmountCurrent;\\n        (vTokenAmountCurrent, ) = position.vTokenAmountsInRange(sqrtPriceCurrent, false);\\n        netTokenPosition = (vTokenAmountCurrent - position.vTokenAmountIn);\\n    }\\n\\n    /// @notice calculates the current virtual token amounts for the position\\n    /// @param position storage ref of the position to check\\n    /// @param sqrtPriceCurrent the current sqrt price, used to calculate virtual token amounts\\n    /// @param roundUp whether to round up the token amounts, purpose to charge user more and give less\\n    /// @return vTokenAmount the current vToken amount\\n    /// @return vQuoteAmount the current vQuote amount\\n    function vTokenAmountsInRange(\\n        LiquidityPosition.Info storage position,\\n        uint160 sqrtPriceCurrent,\\n        bool roundUp\\n    ) internal view returns (int256 vTokenAmount, int256 vQuoteAmount) {\\n        uint160 sqrtPriceLowerX96 = TickMath.getSqrtRatioAtTick(position.tickLower);\\n        uint160 sqrtPriceUpperX96 = TickMath.getSqrtRatioAtTick(position.tickUpper);\\n\\n        // If price is outside the range, then consider it at the ends\\n        // for calculation of amounts\\n        uint160 sqrtPriceMiddleX96 = sqrtPriceCurrent;\\n        if (sqrtPriceCurrent < sqrtPriceLowerX96) {\\n            sqrtPriceMiddleX96 = sqrtPriceLowerX96;\\n        } else if (sqrtPriceCurrent > sqrtPriceUpperX96) {\\n            sqrtPriceMiddleX96 = sqrtPriceUpperX96;\\n        }\\n\\n        vTokenAmount = SqrtPriceMath\\n            .getAmount0Delta(sqrtPriceMiddleX96, sqrtPriceUpperX96, position.liquidity, roundUp)\\n            .toInt256();\\n        vQuoteAmount = SqrtPriceMath\\n            .getAmount1Delta(sqrtPriceLowerX96, sqrtPriceMiddleX96, position.liquidity, roundUp)\\n            .toInt256();\\n    }\\n\\n    /// @notice returns vQuoteIncrease due to unrealised funding payment for the liquidity position (+ve means receiving and -ve means giving)\\n    /// @param position storage ref of the position to check\\n    /// @param sumAX128 the sumA value from the pool wrapper\\n    /// @param sumFpInsideX128 the sumFp in the position's range from the pool wrapper\\n    /// @return vQuoteIncrease the amount of vQuote that should be added to the account's vQuote balance\\n    function unrealizedFundingPayment(\\n        LiquidityPosition.Info storage position,\\n        int256 sumAX128,\\n        int256 sumFpInsideX128\\n    ) internal view returns (int256 vQuoteIncrease) {\\n        // subtract the bill from the account's vQuote balance\\n        vQuoteIncrease = -FundingPayment.bill(\\n            sumAX128,\\n            sumFpInsideX128,\\n            position.sumALastX128,\\n            position.sumBInsideLastX128,\\n            position.sumFpInsideLastX128,\\n            position.liquidity\\n        );\\n    }\\n\\n    /// @notice calculates the unrealised lp fees for the position\\n    /// @param position storage ref of the position to check\\n    /// @param sumFeeInsideX128 the global sumFee in the position's range from the pool wrapper\\n    /// @return vQuoteIncrease the amount of vQuote that should be added to the account's vQuote balance\\n    function unrealizedFees(LiquidityPosition.Info storage position, uint256 sumFeeInsideX128)\\n        internal\\n        view\\n        returns (uint256 vQuoteIncrease)\\n    {\\n        vQuoteIncrease = (sumFeeInsideX128 - position.sumFeeInsideLastX128).mulDiv(\\n            position.liquidity,\\n            FixedPoint128.Q128\\n        );\\n    }\\n\\n    function emitLiquidityChangeEvent(\\n        LiquidityPosition.Info storage position,\\n        uint256 accountId,\\n        uint32 poolId,\\n        int128 liquidityDelta,\\n        uint160 sqrtPriceX96,\\n        int256 vTokenAmountOut,\\n        int256 vQuoteAmountOut\\n    ) internal {\\n        emit LiquidityChanged(\\n            accountId,\\n            poolId,\\n            position.tickLower,\\n            position.tickUpper,\\n            liquidityDelta,\\n            position.limitOrderType,\\n            vTokenAmountOut,\\n            vQuoteAmountOut,\\n            sqrtPriceX96\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xdd835fed27adf6c4168843bbfa7074d29fd5b0cc25cee891b20bf353b18e985a\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/LiquidityPositionSet.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport { LiquidityPosition } from './LiquidityPosition.sol';\\nimport { Protocol } from './Protocol.sol';\\nimport { Uint48Lib } from './Uint48.sol';\\nimport { Uint48L5ArrayLib } from './Uint48L5Array.sol';\\n\\nimport { IClearingHouseStructures } from '../interfaces/clearinghouse/IClearingHouseStructures.sol';\\nimport { IVPoolWrapper } from '../interfaces/IVPoolWrapper.sol';\\n\\n/// @title Liquidity position set functions\\nlibrary LiquidityPositionSet {\\n    using LiquidityPosition for LiquidityPosition.Info;\\n    using LiquidityPositionSet for LiquidityPosition.Set;\\n    using Protocol for Protocol.Info;\\n    using Uint48Lib for int24;\\n    using Uint48Lib for uint48;\\n    using Uint48L5ArrayLib for uint48[5];\\n\\n    error LPS_IllegalTicks(int24 tickLower, int24 tickUpper);\\n    error LPS_DeactivationFailed(int24 tickLower, int24 tickUpper, uint256 liquidity);\\n    error LPS_InactiveRange();\\n\\n    /// @notice denotes token position change due to liquidity add/remove\\n    /// @param accountId serial number of the account\\n    /// @param poolId address of token whose position was taken\\n    /// @param tickLower lower tick of the range updated\\n    /// @param tickUpper upper tick of the range updated\\n    /// @param vTokenAmountOut amount of tokens that account received (positive) or paid (negative)\\n    event TokenPositionChangedDueToLiquidityChanged(\\n        uint256 indexed accountId,\\n        uint32 indexed poolId,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int256 vTokenAmountOut\\n    );\\n\\n    /**\\n     *  Internal methods\\n     */\\n\\n    /// @notice activates a position by initializing it and adding it to the set\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param tickLower lower tick of the range to be activated\\n    /// @param tickUpper upper tick of the range to be activated\\n    /// @return position storage ref of the activated position\\n    function activate(\\n        LiquidityPosition.Set storage set,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal returns (LiquidityPosition.Info storage position) {\\n        if (tickLower > tickUpper) {\\n            revert LPS_IllegalTicks(tickLower, tickUpper);\\n        }\\n\\n        uint48 positionId;\\n        set.active.include(positionId = tickLower.concat(tickUpper));\\n        position = set.positions[positionId];\\n\\n        if (!position.isInitialized()) {\\n            position.initialize(tickLower, tickUpper);\\n        }\\n    }\\n\\n    /// @notice deactivates a position by removing it from the set\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param position storage ref to the position to be deactivated\\n    function deactivate(LiquidityPosition.Set storage set, LiquidityPosition.Info storage position) internal {\\n        if (position.liquidity != 0) {\\n            revert LPS_DeactivationFailed(position.tickLower, position.tickUpper, position.liquidity);\\n        }\\n\\n        set.active.exclude(position.tickLower.concat(position.tickUpper));\\n    }\\n\\n    /// @notice changes liquidity of a position in the set\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param accountId serial number of the account\\n    /// @param poolId truncated address of vToken\\n    /// @param liquidityChangeParams parameters of the liquidity change\\n    /// @param balanceAdjustments adjustments to made to the account's balance later\\n    /// @param protocol ref to the state of the protocol\\n    function liquidityChange(\\n        LiquidityPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        IClearingHouseStructures.LiquidityChangeParams memory liquidityChangeParams,\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments,\\n        Protocol.Info storage protocol\\n    ) internal {\\n        LiquidityPosition.Info storage position = set.activate(\\n            liquidityChangeParams.tickLower,\\n            liquidityChangeParams.tickUpper\\n        );\\n\\n        position.limitOrderType = liquidityChangeParams.limitOrderType;\\n\\n        set.liquidityChange(\\n            accountId,\\n            poolId,\\n            position,\\n            liquidityChangeParams.liquidityDelta,\\n            balanceAdjustments,\\n            protocol\\n        );\\n    }\\n\\n    /// @notice changes liquidity of a position in the set\\n    /// @param accountId serial number of the account\\n    /// @param poolId truncated address of vToken\\n    /// @param position storage ref to the position to be changed\\n    /// @param liquidityDelta amount of liquidity to be added or removed\\n    /// @param balanceAdjustments adjustments to made to the account's balance later\\n    /// @param protocol ref to the state of the protocol\\n    function liquidityChange(\\n        LiquidityPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        LiquidityPosition.Info storage position,\\n        int128 liquidityDelta,\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments,\\n        Protocol.Info storage protocol\\n    ) internal {\\n        position.liquidityChange(accountId, poolId, liquidityDelta, balanceAdjustments, protocol);\\n\\n        emit TokenPositionChangedDueToLiquidityChanged(\\n            accountId,\\n            poolId,\\n            position.tickLower,\\n            position.tickUpper,\\n            balanceAdjustments.vTokenIncrease\\n        );\\n\\n        if (position.liquidity == 0) {\\n            set.deactivate(position);\\n        }\\n    }\\n\\n    /// @notice removes liquidity from a position in the set\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param accountId serial number of the account\\n    /// @param poolId truncated address of vToken\\n    /// @param position storage ref to the position to be closed\\n    /// @param balanceAdjustments adjustments to made to the account's balance later\\n    /// @param protocol ref to the state of the protocol\\n    function closeLiquidityPosition(\\n        LiquidityPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        LiquidityPosition.Info storage position,\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments,\\n        Protocol.Info storage protocol\\n    ) internal {\\n        set.liquidityChange(accountId, poolId, position, -int128(position.liquidity), balanceAdjustments, protocol);\\n    }\\n\\n    /// @notice removes liquidity from a position in the set\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param accountId serial number of the account\\n    /// @param poolId truncated address of vToken\\n    /// @param currentTick current tick of the pool\\n    /// @param tickLower lower tick of the range to be closed\\n    /// @param tickUpper upper tick of the range to be closed\\n    /// @param balanceAdjustments adjustments to made to the account's balance later\\n    /// @param protocol ref to the state of the protocol\\n    function removeLimitOrder(\\n        LiquidityPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        int24 currentTick,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments,\\n        Protocol.Info storage protocol\\n    ) internal {\\n        LiquidityPosition.Info storage position = set.getLiquidityPosition(tickLower, tickUpper);\\n        position.checkValidLimitOrderRemoval(currentTick);\\n        set.closeLiquidityPosition(accountId, poolId, position, balanceAdjustments, protocol);\\n    }\\n\\n    /// @notice removes liquidity from all the positions in the set\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param accountId serial number of the account\\n    /// @param poolId truncated address of vToken\\n    /// @param balanceAdjustments adjustments to made to the account's balance later\\n    /// @param protocol ref to the state of the protocol\\n    function closeAllLiquidityPositions(\\n        LiquidityPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments,\\n        Protocol.Info storage protocol\\n    ) internal {\\n        LiquidityPosition.Info storage position;\\n\\n        while (set.active[0] != 0) {\\n            IClearingHouseStructures.BalanceAdjustments memory balanceAdjustmentsCurrent;\\n\\n            position = set.positions[set.active[0]];\\n\\n            set.closeLiquidityPosition(accountId, poolId, position, balanceAdjustmentsCurrent, protocol);\\n\\n            balanceAdjustments.vQuoteIncrease += balanceAdjustmentsCurrent.vQuoteIncrease;\\n            balanceAdjustments.vTokenIncrease += balanceAdjustmentsCurrent.vTokenIncrease;\\n            balanceAdjustments.traderPositionIncrease += balanceAdjustmentsCurrent.traderPositionIncrease;\\n        }\\n    }\\n\\n    /**\\n     *  Internal view methods\\n     */\\n\\n    /// @notice gets the liquidity position of a tick range\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param tickLower lower tick of the range to be closed\\n    /// @param tickUpper upper tick of the range to be closed\\n    /// @return position liquidity position of the tick range\\n    function getLiquidityPosition(\\n        LiquidityPosition.Set storage set,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal view returns (LiquidityPosition.Info storage position) {\\n        if (tickLower > tickUpper) {\\n            revert LPS_IllegalTicks(tickLower, tickUpper);\\n        }\\n\\n        uint48 positionId = Uint48Lib.concat(tickLower, tickUpper);\\n        position = set.positions[positionId];\\n\\n        if (!position.isInitialized()) revert LPS_InactiveRange();\\n        return position;\\n    }\\n\\n    /// @notice gets information about all the liquidity position\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @return liquidityPositions Information about all the liquidity position for the pool\\n    function getInfo(LiquidityPosition.Set storage set)\\n        internal\\n        view\\n        returns (IClearingHouseStructures.LiquidityPositionView[] memory liquidityPositions)\\n    {\\n        uint256 numberOfTokenPositions = set.active.numberOfNonZeroElements();\\n        liquidityPositions = new IClearingHouseStructures.LiquidityPositionView[](numberOfTokenPositions);\\n\\n        for (uint256 i = 0; i < numberOfTokenPositions; i++) {\\n            liquidityPositions[i].limitOrderType = set.positions[set.active[i]].limitOrderType;\\n            liquidityPositions[i].tickLower = set.positions[set.active[i]].tickLower;\\n            liquidityPositions[i].tickUpper = set.positions[set.active[i]].tickUpper;\\n            liquidityPositions[i].liquidity = set.positions[set.active[i]].liquidity;\\n            liquidityPositions[i].vTokenAmountIn = set.positions[set.active[i]].vTokenAmountIn;\\n            liquidityPositions[i].sumALastX128 = set.positions[set.active[i]].sumALastX128;\\n            liquidityPositions[i].sumBInsideLastX128 = set.positions[set.active[i]].sumBInsideLastX128;\\n            liquidityPositions[i].sumFpInsideLastX128 = set.positions[set.active[i]].sumFpInsideLastX128;\\n            liquidityPositions[i].sumFeeInsideLastX128 = set.positions[set.active[i]].sumFeeInsideLastX128;\\n        }\\n    }\\n\\n    /// @notice gets the net position due to all the liquidity positions\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param sqrtPriceCurrent current sqrt price of the pool\\n    /// @return netPosition due to all the liquidity positions\\n    function getNetPosition(LiquidityPosition.Set storage set, uint160 sqrtPriceCurrent)\\n        internal\\n        view\\n        returns (int256 netPosition)\\n    {\\n        uint256 numberOfTokenPositions = set.active.numberOfNonZeroElements();\\n\\n        for (uint256 i = 0; i < numberOfTokenPositions; i++) {\\n            netPosition += set.positions[set.active[i]].netPosition(sqrtPriceCurrent);\\n        }\\n    }\\n\\n    /// @notice checks whether the liquidity position set is empty\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @return true if the liquidity position set is empty\\n    function isEmpty(LiquidityPosition.Set storage set) internal view returns (bool) {\\n        return set.active.isEmpty();\\n    }\\n\\n    /// @notice checks whether for given ticks, a liquidity position is active\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param tickLower lower tick of the range\\n    /// @param tickUpper upper tick of the range\\n    /// @return true if the liquidity position is active\\n    function isPositionActive(\\n        LiquidityPosition.Set storage set,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal view returns (bool) {\\n        return set.active.exists(tickLower.concat(tickUpper));\\n    }\\n\\n    /// @notice gets the total long side risk for all the active liquidity positions\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param valuationPriceX96 price used to value the vToken asset\\n    /// @return risk the net long side risk for all the active liquidity positions\\n    function longSideRisk(LiquidityPosition.Set storage set, uint160 valuationPriceX96)\\n        internal\\n        view\\n        returns (uint256 risk)\\n    {\\n        for (uint256 i = 0; i < set.active.length; i++) {\\n            uint48 id = set.active[i];\\n            if (id == 0) break;\\n            risk += set.positions[id].longSideRisk(valuationPriceX96);\\n        }\\n    }\\n\\n    /// @notice gets the total market value of all the active liquidity positions\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @param sqrtPriceCurrent price used to value the vToken asset\\n    /// @param poolId the id of the pool\\n    /// @param protocol ref to the state of the protocol\\n    /// @return marketValue_ the total market value of all the active liquidity positions\\n    function marketValue(\\n        LiquidityPosition.Set storage set,\\n        uint160 sqrtPriceCurrent,\\n        uint32 poolId,\\n        Protocol.Info storage protocol\\n    ) internal view returns (int256 marketValue_) {\\n        marketValue_ = set.marketValue(sqrtPriceCurrent, protocol.vPoolWrapper(poolId));\\n    }\\n\\n    /// @notice Get the total market value of all active liquidity positions in the set.\\n    /// @param set: Collection of active liquidity positions\\n    /// @param sqrtPriceCurrent: Current price of the virtual asset\\n    /// @param wrapper: address of the wrapper contract, passed once to avoid multiple sloads for wrapper\\n    function marketValue(\\n        LiquidityPosition.Set storage set,\\n        uint160 sqrtPriceCurrent,\\n        IVPoolWrapper wrapper\\n    ) internal view returns (int256 marketValue_) {\\n        for (uint256 i = 0; i < set.active.length; i++) {\\n            uint48 id = set.active[i];\\n            if (id == 0) break;\\n            marketValue_ += set.positions[id].marketValue(sqrtPriceCurrent, wrapper);\\n        }\\n    }\\n\\n    /// @notice gets the max net position possible due to all the liquidity positions\\n    /// @param set storage ref to the account's set of liquidity positions of a pool\\n    /// @return risk the max net position possible due to all the liquidity positions\\n    function maxNetPosition(LiquidityPosition.Set storage set) internal view returns (uint256 risk) {\\n        for (uint256 i = 0; i < set.active.length; i++) {\\n            uint48 id = set.active[i];\\n            if (id == 0) break;\\n            risk += set.positions[id].maxNetPosition();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x20552c4941db1f89a751daa063774d5daa0a8dbad241e43bf1abf91f6e653d5c\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/PriceMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\\nimport { FixedPoint96 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint96.sol';\\nimport { TickMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/TickMath.sol';\\n\\nimport { Bisection } from './Bisection.sol';\\n\\n/// @title Price math functions\\nlibrary PriceMath {\\n    using FullMath for uint256;\\n\\n    error IllegalSqrtPrice(uint160 sqrtPriceX96);\\n\\n    /// @notice Computes the square of a sqrtPriceX96 value\\n    /// @param sqrtPriceX96: the square root of the input price in Q96 format\\n    /// @return priceX128 : input price in Q128 format\\n    function toPriceX128(uint160 sqrtPriceX96) internal pure returns (uint256 priceX128) {\\n        if (sqrtPriceX96 < TickMath.MIN_SQRT_RATIO || sqrtPriceX96 >= TickMath.MAX_SQRT_RATIO) {\\n            revert IllegalSqrtPrice(sqrtPriceX96);\\n        }\\n\\n        priceX128 = _toPriceX128(sqrtPriceX96);\\n    }\\n\\n    /// @notice computes the square of a sqrtPriceX96 value\\n    /// @param sqrtPriceX96: input price in Q128 format\\n    function _toPriceX128(uint160 sqrtPriceX96) private pure returns (uint256 priceX128) {\\n        priceX128 = uint256(sqrtPriceX96).mulDiv(sqrtPriceX96, 1 << 64);\\n    }\\n\\n    /// @notice computes the square root of a priceX128 value\\n    /// @param priceX128: input price in Q128 format\\n    /// @return sqrtPriceX96 : the square root of the input price in Q96 format\\n    function toSqrtPriceX96(uint256 priceX128) internal pure returns (uint160 sqrtPriceX96) {\\n        // Uses bisection method to find solution to the equation toPriceX128(x) = priceX128\\n        sqrtPriceX96 = Bisection.findSolution(\\n            _toPriceX128,\\n            priceX128,\\n            /// @dev sqrtPriceX96 is always bounded by MIN_SQRT_RATIO and MAX_SQRT_RATIO.\\n            ///     If solution falls outside of these bounds, findSolution method reverts\\n            TickMath.MIN_SQRT_RATIO,\\n            TickMath.MAX_SQRT_RATIO - 1\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x88bb3e3cb05a8474c5e69c26e2c29bf382a82a4d460f79674ae407114463c3b7\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/Protocol.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport { IUniswapV3Pool } from '@uniswap/v3-core-0.8-support/contracts/interfaces/IUniswapV3Pool.sol';\\n\\nimport { Math } from '@openzeppelin/contracts/utils/math/Math.sol';\\n\\nimport { FixedPoint128 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint128.sol';\\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\\n\\nimport { IClearingHouseStructures } from '../interfaces/clearinghouse/IClearingHouseStructures.sol';\\nimport { IVQuote } from '../interfaces/IVQuote.sol';\\nimport { IVToken } from '../interfaces/IVToken.sol';\\nimport { IVPoolWrapper } from '../interfaces/IVPoolWrapper.sol';\\n\\nimport { PriceMath } from './PriceMath.sol';\\nimport { SafeCast } from './SafeCast.sol';\\nimport { SignedMath } from './SignedMath.sol';\\nimport { SignedFullMath } from './SignedFullMath.sol';\\nimport { UniswapV3PoolHelper } from './UniswapV3PoolHelper.sol';\\nimport { Block } from './Block.sol';\\nimport { SafeCast } from './SafeCast.sol';\\n\\n/// @title Protocol storage functions\\n/// @dev This is used as main storage interface containing protocol info\\nlibrary Protocol {\\n    using FullMath for uint256;\\n    using PriceMath for uint160;\\n    using PriceMath for uint256;\\n    using SignedMath for int256;\\n    using SignedFullMath for int256;\\n    using SafeCast for uint256;\\n    using UniswapV3PoolHelper for IUniswapV3Pool;\\n    using SafeCast for uint256;\\n\\n    using Protocol for Protocol.Info;\\n\\n    struct PriceCache {\\n        uint32 updateBlockNumber;\\n        uint224 virtualPriceX128;\\n        uint224 realPriceX128;\\n        bool isDeviationBreached;\\n    }\\n    struct Info {\\n        // poolId => PoolInfo\\n        mapping(uint32 => IClearingHouseStructures.Pool) pools;\\n        // collateralId => CollateralInfo\\n        mapping(uint32 => IClearingHouseStructures.Collateral) collaterals;\\n        // iterable and increasing list of pools (used for admin functions)\\n        uint32[] poolIds;\\n        // settlement token (default collateral)\\n        IERC20 settlementToken;\\n        // virtual quote token (sort of fake USDC), is always token1 in uniswap pools\\n        IVQuote vQuote;\\n        // accounting settings\\n        IClearingHouseStructures.LiquidationParams liquidationParams;\\n        uint256 minRequiredMargin;\\n        uint256 removeLimitOrderFee;\\n        uint256 minimumOrderNotional;\\n        // price cache\\n        mapping(uint32 => PriceCache) priceCache;\\n        // reserved for adding slots in future\\n        uint256[100] _emptySlots;\\n    }\\n\\n    function updatePoolPriceCache(Protocol.Info storage protocol, uint32 poolId) internal {\\n        uint32 blockNumber = Block.number();\\n\\n        PriceCache storage poolPriceCache = protocol.priceCache[poolId];\\n        if (poolPriceCache.updateBlockNumber == blockNumber) {\\n            return;\\n        }\\n\\n        uint256 realPriceX128 = protocol.getRealTwapPriceX128(poolId);\\n        uint256 virtualPriceX128 = protocol.getVirtualTwapPriceX128(poolId);\\n\\n        // In case the price is breaching the Q224 limit, we do not cache it\\n        uint256 Q224 = 1 << 224;\\n        if (realPriceX128 >= Q224 || virtualPriceX128 >= Q224) {\\n            return;\\n        }\\n\\n        uint16 maxDeviationBps = protocol.pools[poolId].settings.maxVirtualPriceDeviationRatioBps;\\n        if (\\n            // if virtual price is too off from real price then screw that, we'll just use real price\\n            (int256(realPriceX128) - int256(virtualPriceX128)).absUint() > realPriceX128.mulDiv(maxDeviationBps, 1e4)\\n        ) {\\n            poolPriceCache.isDeviationBreached = true;\\n        } else {\\n            poolPriceCache.isDeviationBreached = false;\\n        }\\n        poolPriceCache.realPriceX128 = realPriceX128.toUint224();\\n        poolPriceCache.virtualPriceX128 = virtualPriceX128.toUint224();\\n        poolPriceCache.updateBlockNumber = blockNumber;\\n    }\\n\\n    /// @notice gets the uniswap v3 pool address for a poolId\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @return UniswapV3Pool contract object\\n    function vPool(Protocol.Info storage protocol, uint32 poolId) internal view returns (IUniswapV3Pool) {\\n        return protocol.pools[poolId].vPool;\\n    }\\n\\n    /// @notice gets the wrapper address for a poolId\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @return VPoolWrapper contract object\\n    function vPoolWrapper(Protocol.Info storage protocol, uint32 poolId) internal view returns (IVPoolWrapper) {\\n        return protocol.pools[poolId].vPoolWrapper;\\n    }\\n\\n    /// @notice gets the virtual twap sqrt price for a poolId\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @return sqrtPriceX96 virtual twap sqrt price\\n    function getVirtualTwapSqrtPriceX96(Protocol.Info storage protocol, uint32 poolId)\\n        internal\\n        view\\n        returns (uint160 sqrtPriceX96)\\n    {\\n        IClearingHouseStructures.Pool storage pool = protocol.pools[poolId];\\n        return pool.vPool.twapSqrtPrice(pool.settings.twapDuration);\\n    }\\n\\n    /// @notice gets the virtual current sqrt price for a poolId\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @return sqrtPriceX96 virtual current sqrt price\\n    function getVirtualCurrentSqrtPriceX96(Protocol.Info storage protocol, uint32 poolId)\\n        internal\\n        view\\n        returns (uint160 sqrtPriceX96)\\n    {\\n        return protocol.pools[poolId].vPool.sqrtPriceCurrent();\\n    }\\n\\n    /// @notice gets the virtual current tick for a poolId\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @return tick virtual current tick\\n    function getVirtualCurrentTick(Protocol.Info storage protocol, uint32 poolId) internal view returns (int24 tick) {\\n        return protocol.pools[poolId].vPool.tickCurrent();\\n    }\\n\\n    /// @notice gets the virtual twap price for a poolId\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @return priceX128 virtual twap price\\n    function getVirtualTwapPriceX128(Protocol.Info storage protocol, uint32 poolId)\\n        internal\\n        view\\n        returns (uint256 priceX128)\\n    {\\n        return protocol.getVirtualTwapSqrtPriceX96(poolId).toPriceX128();\\n    }\\n\\n    /// @notice gets the virtual current price for a poolId\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @return priceX128 virtual current price\\n    function getVirtualCurrentPriceX128(Protocol.Info storage protocol, uint32 poolId)\\n        internal\\n        view\\n        returns (uint256 priceX128)\\n    {\\n        return protocol.getVirtualCurrentSqrtPriceX96(poolId).toPriceX128();\\n    }\\n\\n    /// @notice gets the real twap price for a poolId\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @return priceX128 virtual twap price\\n    function getRealTwapPriceX128(Protocol.Info storage protocol, uint32 poolId)\\n        internal\\n        view\\n        returns (uint256 priceX128)\\n    {\\n        IClearingHouseStructures.Pool storage pool = protocol.pools[poolId];\\n        return pool.settings.oracle.getTwapPriceX128(pool.settings.twapDuration);\\n    }\\n\\n    /// @notice gets the twap prices with deviation check for a poolId\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @return realPriceX128 the real price\\n    /// @return virtualPriceX128 the virtual price if under deviation else real price\\n    function getTwapPricesWithDeviationCheck(Protocol.Info storage protocol, uint32 poolId)\\n        internal\\n        view\\n        returns (uint256 realPriceX128, uint256 virtualPriceX128)\\n    {\\n        realPriceX128 = protocol.getRealTwapPriceX128(poolId);\\n        virtualPriceX128 = protocol.getVirtualTwapPriceX128(poolId);\\n\\n        uint16 maxDeviationBps = protocol.pools[poolId].settings.maxVirtualPriceDeviationRatioBps;\\n        uint256 priceDeltaX128 = realPriceX128 > virtualPriceX128\\n            ? realPriceX128 - virtualPriceX128\\n            : virtualPriceX128 - realPriceX128;\\n        if (priceDeltaX128 > realPriceX128.mulDiv(maxDeviationBps, 1e4)) {\\n            // if virtual price is too off from real price then screw that, we'll just use real price\\n            virtualPriceX128 = realPriceX128;\\n        }\\n        return (realPriceX128, virtualPriceX128);\\n    }\\n\\n    function getCachedVirtualTwapPriceX128(Protocol.Info storage protocol, uint32 poolId)\\n        internal\\n        view\\n        returns (uint256 priceX128)\\n    {\\n        uint32 blockNumber = Block.number();\\n\\n        PriceCache storage poolPriceCache = protocol.priceCache[poolId];\\n        if (poolPriceCache.updateBlockNumber == blockNumber) {\\n            return poolPriceCache.virtualPriceX128;\\n        } else {\\n            return protocol.getVirtualTwapPriceX128(poolId);\\n        }\\n    }\\n\\n    function getCachedTwapPricesWithDeviationCheck(Protocol.Info storage protocol, uint32 poolId)\\n        internal\\n        view\\n        returns (uint256 realPriceX128, uint256 virtualPriceX128)\\n    {\\n        uint32 blockNumber = Block.number();\\n\\n        PriceCache storage poolPriceCache = protocol.priceCache[poolId];\\n        if (poolPriceCache.updateBlockNumber == blockNumber) {\\n            if (poolPriceCache.isDeviationBreached) {\\n                return (poolPriceCache.realPriceX128, poolPriceCache.realPriceX128);\\n            } else {\\n                return (poolPriceCache.realPriceX128, poolPriceCache.virtualPriceX128);\\n            }\\n        } else {\\n            return protocol.getTwapPricesWithDeviationCheck(poolId);\\n        }\\n    }\\n\\n    function getCachedRealTwapPriceX128(Protocol.Info storage protocol, uint32 poolId)\\n        internal\\n        view\\n        returns (uint256 priceX128)\\n    {\\n        uint32 blockNumber = Block.number();\\n\\n        PriceCache storage poolPriceCache = protocol.priceCache[poolId];\\n        if (poolPriceCache.updateBlockNumber == blockNumber) {\\n            return poolPriceCache.realPriceX128;\\n        } else {\\n            return protocol.getRealTwapPriceX128(poolId);\\n        }\\n    }\\n\\n    /// @notice gets the margin ratio for a poolId\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @param isInitialMargin whether to use initial margin or maintainance margin\\n    /// @return margin rato in bps\\n    function getMarginRatioBps(\\n        Protocol.Info storage protocol,\\n        uint32 poolId,\\n        bool isInitialMargin\\n    ) internal view returns (uint16) {\\n        if (isInitialMargin) {\\n            return protocol.pools[poolId].settings.initialMarginRatioBps;\\n        } else {\\n            return protocol.pools[poolId].settings.maintainanceMarginRatioBps;\\n        }\\n    }\\n\\n    /// @notice checks if the pool is cross margined\\n    /// @param protocol ref to the protocol state\\n    /// @param poolId the poolId of the pool\\n    /// @return bool whether the pool is cross margined\\n    function isPoolCrossMargined(Protocol.Info storage protocol, uint32 poolId) internal view returns (bool) {\\n        return protocol.pools[poolId].settings.isCrossMargined;\\n    }\\n\\n    /// @notice Gives notional value of the given vToken and vQuote amounts\\n    /// @param protocol platform constants\\n    /// @param poolId id of the rage trade pool\\n    /// @param vTokenAmount amount of tokens\\n    /// @param vQuoteAmount amount of base\\n    /// @return notionalValue for the given token and vQuote amounts\\n    function getNotionalValue(\\n        Protocol.Info storage protocol,\\n        uint32 poolId,\\n        int256 vTokenAmount,\\n        int256 vQuoteAmount\\n    ) internal view returns (uint256 notionalValue) {\\n        return\\n            vTokenAmount.absUint().mulDiv(protocol.getCachedVirtualTwapPriceX128(poolId), FixedPoint128.Q128) +\\n            vQuoteAmount.absUint();\\n    }\\n\\n    /// @notice Gives notional value of the given token amount\\n    /// @param protocol platform constants\\n    /// @param poolId id of the rage trade pool\\n    /// @param vTokenAmount amount of tokens\\n    /// @return notionalValue for the given token and vQuote amounts\\n    function getNotionalValue(\\n        Protocol.Info storage protocol,\\n        uint32 poolId,\\n        int256 vTokenAmount\\n    ) internal view returns (uint256 notionalValue) {\\n        return protocol.getNotionalValue(poolId, vTokenAmount, 0);\\n    }\\n}\\n\",\"keccak256\":\"0x274ddcd8f199b7505377bdeda516d4de0db10dd03222bcdf7eb8fb94ca4092a0\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/// @title Safe cast functions\\nlibrary SafeCast {\\n    error SafeCast_Int128Overflow(uint128 value);\\n\\n    function toInt128(uint128 y) internal pure returns (int128 z) {\\n        unchecked {\\n            if (y >= 2**127) revert SafeCast_Int128Overflow(y);\\n            z = int128(y);\\n        }\\n    }\\n\\n    error SafeCast_Int256Overflow(uint256 value);\\n\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            if (y >= 2**255) revert SafeCast_Int256Overflow(y);\\n            z = int256(y);\\n        }\\n    }\\n\\n    error SafeCast_UInt224Overflow(uint256 value);\\n\\n    function toUint224(uint256 y) internal pure returns (uint224 z) {\\n        if (y > 2**224) revert SafeCast_UInt224Overflow(y);\\n        z = uint224(y);\\n    }\\n}\\n\",\"keccak256\":\"0xdc96976b23016f06a21a9db7e01c509dff6c9f6ebbdca3dba0043cdfae3405eb\",\"license\":\"MIT\"},\"contracts/libraries/SignedFullMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\\nimport { SafeCast } from '@uniswap/v3-core-0.8-support/contracts/libraries/SafeCast.sol';\\n\\nimport { SignedMath } from './SignedMath.sol';\\n\\n/// @title Signed full math functions\\nlibrary SignedFullMath {\\n    using SafeCast for uint256;\\n    using SignedMath for int256;\\n\\n    /// @notice uses full math on signed int and two unsigned ints\\n    /// @param a: signed int\\n    /// @param b: unsigned int to be multiplied by\\n    /// @param denominator: unsigned int to be divided by\\n    /// @return result of a * b / denominator\\n    function mulDiv(\\n        int256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (int256 result) {\\n        result = FullMath.mulDiv(a < 0 ? uint256(-1 * a) : uint256(a), b, denominator).toInt256();\\n        if (a < 0) {\\n            result = -result;\\n        }\\n    }\\n\\n    /// @notice uses full math on three signed ints\\n    /// @param a: signed int\\n    /// @param b: signed int to be multiplied by\\n    /// @param denominator: signed int to be divided by\\n    /// @return result of a * b / denominator\\n    function mulDiv(\\n        int256 a,\\n        int256 b,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        bool resultPositive = true;\\n        uint256 _a;\\n        uint256 _b;\\n        uint256 _denominator;\\n\\n        (_a, resultPositive) = a.extractSign(resultPositive);\\n        (_b, resultPositive) = b.extractSign(resultPositive);\\n        (_denominator, resultPositive) = denominator.extractSign(resultPositive);\\n\\n        result = FullMath.mulDiv(_a, _b, _denominator).toInt256();\\n        if (!resultPositive) {\\n            result = -result;\\n        }\\n    }\\n\\n    /// @notice rounds down towards negative infinity\\n    /// @dev in Solidity -3/2 is -1. But this method result is -2\\n    /// @param a: signed int\\n    /// @param b: unsigned int to be multiplied by\\n    /// @param denominator: unsigned int to be divided by\\n    /// @return result of a * b / denominator rounded towards negative infinity\\n    function mulDivRoundingDown(\\n        int256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (int256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (result < 0 && _hasRemainder(a.absUint(), b, denominator)) {\\n            result += -1;\\n        }\\n    }\\n\\n    /// @notice rounds down towards negative infinity\\n    /// @dev in Solidity -3/2 is -1. But this method result is -2\\n    /// @param a: signed int\\n    /// @param b: signed int to be multiplied by\\n    /// @param denominator: signed int to be divided by\\n    /// @return result of a * b / denominator rounded towards negative infinity\\n    function mulDivRoundingDown(\\n        int256 a,\\n        int256 b,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (result < 0 && _hasRemainder(a.absUint(), b.absUint(), denominator.absUint())) {\\n            result += -1;\\n        }\\n    }\\n\\n    /// @notice checks if full multiplication of a & b would have a remainder if divided by denominator\\n    /// @param a: multiplicand\\n    /// @param b: multiplier\\n    /// @param denominator: divisor\\n    /// @return hasRemainder true if there is a remainder, false otherwise\\n    function _hasRemainder(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) private pure returns (bool hasRemainder) {\\n        assembly {\\n            let remainder := mulmod(a, b, denominator)\\n            if gt(remainder, 0) {\\n                hasRemainder := 1\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6b5879e3d8f8c0ef8583034f007af7f5d566bc512ea15ab0a26eeeed1092ede3\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nint256 constant ONE = 1;\\n\\n/// @title Signed math functions\\nlibrary SignedMath {\\n    /// @notice gives the absolute value of a signed int\\n    /// @param value signed int\\n    /// @return absolute value of signed int\\n    function abs(int256 value) internal pure returns (int256) {\\n        return value > 0 ? value : -value;\\n    }\\n\\n    /// @notice gives the absolute value of a signed int\\n    /// @param value signed int\\n    /// @return absolute value of signed int as unsigned int\\n    function absUint(int256 value) internal pure returns (uint256) {\\n        return uint256(abs(value));\\n    }\\n\\n    /// @notice gives the sign of a signed int\\n    /// @param value signed int\\n    /// @return -1 if negative, 1 if non-negative\\n    function sign(int256 value) internal pure returns (int256) {\\n        return value >= 0 ? ONE : -ONE;\\n    }\\n\\n    /// @notice converts a signed integer into an unsigned integer and inverts positive bool if negative\\n    /// @param a signed int\\n    /// @param positive initial value of positive bool\\n    /// @return _a absolute value of int provided\\n    /// @return bool xor of the positive boolean and sign of the provided int\\n    function extractSign(int256 a, bool positive) internal pure returns (uint256 _a, bool) {\\n        if (a < 0) {\\n            positive = !positive;\\n            _a = uint256(-a);\\n        } else {\\n            _a = uint256(a);\\n        }\\n        return (_a, positive);\\n    }\\n\\n    /// @notice extracts the sign of a signed int\\n    /// @param a signed int\\n    /// @return _a unsigned int\\n    /// @return bool sign of the provided int\\n    function extractSign(int256 a) internal pure returns (uint256 _a, bool) {\\n        return extractSign(a, true);\\n    }\\n\\n    /// @notice returns the max of two int256 numbers\\n    /// @param a first number\\n    /// @param b second number\\n    /// @return c = max of a and b\\n    function max(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (a > b) c = a;\\n        else c = b;\\n    }\\n}\\n\",\"keccak256\":\"0xe8218625e89406a3695c78794ec72eea5c3a4db9ef677ce6c36037d5f0431258\",\"license\":\"MIT\"},\"contracts/libraries/Uint32L8Array.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/// @title Uint32 length 8 array functions\\n/// @dev Fits in one storage slot\\nlibrary Uint32L8ArrayLib {\\n    using Uint32L8ArrayLib for uint32[8];\\n\\n    uint8 constant LENGTH = 8;\\n\\n    error U32L8_IllegalElement(uint32 element);\\n    error U32L8_NoSpaceLeftToInsert(uint32 element);\\n\\n    /// @notice Inserts an element in the array\\n    /// @dev Replaces a zero value in the array with element\\n    /// @param array Array to modify\\n    /// @param element Element to insert\\n    function include(uint32[8] storage array, uint32 element) internal {\\n        if (element == 0) {\\n            revert U32L8_IllegalElement(0);\\n        }\\n\\n        uint256 emptyIndex = LENGTH; // LENGTH is an invalid index\\n        for (uint256 i; i < LENGTH; i++) {\\n            if (array[i] == element) {\\n                // if element already exists in the array, do nothing\\n                return;\\n            }\\n            // if we found an empty slot, remember it\\n            if (array[i] == uint32(0)) {\\n                emptyIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // if empty index is still LENGTH, there is no space left to insert\\n        if (emptyIndex == LENGTH) {\\n            revert U32L8_NoSpaceLeftToInsert(element);\\n        }\\n\\n        array[emptyIndex] = element;\\n    }\\n\\n    /// @notice Excludes the element from the array\\n    /// @dev If element exists, it swaps with last element and makes last element zero\\n    /// @param array Array to modify\\n    /// @param element Element to remove\\n    function exclude(uint32[8] storage array, uint32 element) internal {\\n        if (element == 0) {\\n            revert U32L8_IllegalElement(0);\\n        }\\n\\n        uint256 elementIndex = LENGTH; // LENGTH is an invalid index\\n        uint256 i;\\n\\n        for (; i < LENGTH; i++) {\\n            if (array[i] == element) {\\n                // element index in the array\\n                elementIndex = i;\\n            }\\n            if (array[i] == 0) {\\n                // last non-zero element\\n                i = i > 0 ? i - 1 : 0;\\n                break;\\n            }\\n        }\\n\\n        // if array is full, i == LENGTH\\n        // hence swapping with element at last index\\n        i = i == LENGTH ? LENGTH - 1 : i;\\n\\n        if (elementIndex != LENGTH) {\\n            if (i == elementIndex) {\\n                // if element is last element, simply make it zero\\n                array[elementIndex] = 0;\\n            } else {\\n                // move last to element's place and empty lastIndex slot\\n                (array[elementIndex], array[i]) = (array[i], 0);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns the index of the element in the array\\n    /// @param array Array to perform search on\\n    /// @param element Element to search\\n    /// @return index if exists or LENGTH otherwise\\n    function indexOf(uint32[8] storage array, uint32 element) internal view returns (uint8) {\\n        for (uint8 i; i < LENGTH; i++) {\\n            if (array[i] == element) {\\n                return i;\\n            }\\n        }\\n        return LENGTH; // LENGTH is an invalid index\\n    }\\n\\n    /// @notice Checks whether the element exists in the array\\n    /// @param array Array to perform search on\\n    /// @param element Element to search\\n    /// @return True if element is found, false otherwise\\n    function exists(uint32[8] storage array, uint32 element) internal view returns (bool) {\\n        return array.indexOf(element) != LENGTH; // LENGTH is an invalid index\\n    }\\n\\n    /// @notice Returns length of array (number of non-zero elements)\\n    /// @param array Array to perform search on\\n    /// @return Length of array\\n    function numberOfNonZeroElements(uint32[8] storage array) internal view returns (uint256) {\\n        for (uint8 i; i < LENGTH; i++) {\\n            if (array[i] == 0) {\\n                return i;\\n            }\\n        }\\n        return LENGTH;\\n    }\\n\\n    /// @notice Checks whether the array is empty or not\\n    /// @param array Array to perform search on\\n    /// @return True if the set does not have any token position active\\n    function isEmpty(uint32[8] storage array) internal view returns (bool) {\\n        return array[0] == 0;\\n    }\\n}\\n\",\"keccak256\":\"0x19d249c0ea7212d517f47603e41606eb0d17f60b64b8d6750f36f578e9d4ea88\",\"license\":\"MIT\"},\"contracts/libraries/Uint48.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\n/// @title Uint48 concating functions\\nlibrary Uint48Lib {\\n    /// @notice Packs two int24 values into uint48\\n    /// @dev Used for concating two ticks into 48 bits value\\n    /// @param val1 First 24 bits value\\n    /// @param val2 Second 24 bits value\\n    /// @return concatenated value\\n    function concat(int24 val1, int24 val2) internal pure returns (uint48 concatenated) {\\n        assembly {\\n            concatenated := add(shl(24, val1), and(val2, 0x000000ffffff))\\n        }\\n    }\\n\\n    /// @notice Unpacks uint48 into two int24 values\\n    /// @dev Used for unpacking 48 bits value into two 24 bits values\\n    /// @param concatenated 48 bits value\\n    /// @return val1 First 24 bits value\\n    /// @return val2 Second 24 bits value\\n    function unconcat(uint48 concatenated) internal pure returns (int24 val1, int24 val2) {\\n        assembly {\\n            val2 := concatenated\\n            val1 := shr(24, concatenated)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x68c948293e2c5ee54c07b65af3a3713c5ddc9d2ae68dbc4ada6757773046f475\",\"license\":\"MIT\"},\"contracts/libraries/Uint48L5Array.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/// @title Uint48 length 5 array functions\\n/// @dev Fits in one storage slot\\nlibrary Uint48L5ArrayLib {\\n    using Uint48L5ArrayLib for uint48[5];\\n\\n    uint8 constant LENGTH = 5;\\n\\n    error U48L5_IllegalElement(uint48 element);\\n    error U48L5_NoSpaceLeftToInsert(uint48 element);\\n\\n    /// @notice Inserts an element in the array\\n    /// @dev Replaces a zero value in the array with element\\n    /// @param array Array to modify\\n    /// @param element Element to insert\\n    function include(uint48[5] storage array, uint48 element) internal {\\n        if (element == 0) {\\n            revert U48L5_IllegalElement(0);\\n        }\\n\\n        uint256 emptyIndex = LENGTH; // LENGTH is an invalid index\\n        for (uint256 i; i < LENGTH; i++) {\\n            if (array[i] == element) {\\n                // if element already exists in the array, do nothing\\n                return;\\n            }\\n            // if we found an empty slot, remember it\\n            if (array[i] == uint48(0)) {\\n                emptyIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // if empty index is still LENGTH, there is no space left to insert\\n        if (emptyIndex == LENGTH) {\\n            revert U48L5_NoSpaceLeftToInsert(element);\\n        }\\n\\n        array[emptyIndex] = element;\\n    }\\n\\n    /// @notice Excludes the element from the array\\n    /// @dev If element exists, it swaps with last element and makes last element zero\\n    /// @param array Array to modify\\n    /// @param element Element to remove\\n    function exclude(uint48[5] storage array, uint48 element) internal {\\n        if (element == 0) {\\n            revert U48L5_IllegalElement(0);\\n        }\\n\\n        uint256 elementIndex = LENGTH; // LENGTH is an invalid index\\n        uint256 i;\\n\\n        for (; i < LENGTH; i++) {\\n            if (array[i] == element) {\\n                // element index in the array\\n                elementIndex = i;\\n            }\\n            if (array[i] == 0) {\\n                // last non-zero element\\n                i = i > 0 ? i - 1 : 0;\\n                break;\\n            }\\n        }\\n\\n        // if array is full, i == LENGTH\\n        // hence swapping with element at last index\\n        i = i == LENGTH ? LENGTH - 1 : i;\\n\\n        if (elementIndex != LENGTH) {\\n            if (i == elementIndex) {\\n                // if element is last element, simply make it zero\\n                array[elementIndex] = 0;\\n            } else {\\n                // move last to element's place and empty lastIndex slot\\n                (array[elementIndex], array[i]) = (array[i], 0);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns the index of the element in the array\\n    /// @param array Array to perform search on\\n    /// @param element Element to search\\n    /// @return index if exists or LENGTH otherwise\\n    function indexOf(uint48[5] storage array, uint48 element) internal view returns (uint8) {\\n        for (uint8 i; i < LENGTH; i++) {\\n            if (array[i] == element) {\\n                return i;\\n            }\\n        }\\n        return LENGTH; // LENGTH is an invalid index\\n    }\\n\\n    /// @notice Checks whether the element exists in the array\\n    /// @param array Array to perform search on\\n    /// @param element Element to search\\n    /// @return True if element is found, false otherwise\\n    function exists(uint48[5] storage array, uint48 element) internal view returns (bool) {\\n        return array.indexOf(element) != LENGTH; // LENGTH is an invalid index\\n    }\\n\\n    /// @notice Returns length of array (number of non-zero elements)\\n    /// @param array Array to perform search on\\n    /// @return Length of array\\n    function numberOfNonZeroElements(uint48[5] storage array) internal view returns (uint256) {\\n        for (uint8 i; i < LENGTH; i++) {\\n            if (array[i] == 0) {\\n                return i;\\n            }\\n        }\\n        return LENGTH;\\n    }\\n\\n    /// @notice Checks whether the array is empty or not\\n    /// @param array Array to perform search on\\n    /// @return True if the set does not have any token position active\\n    function isEmpty(uint48[5] storage array) internal view returns (bool) {\\n        return array[0] == 0;\\n    }\\n}\\n\",\"keccak256\":\"0x31b9d020b860bda93859895fac5cb619c791a8e370d59ebb9fa4f1d81edbc070\",\"license\":\"MIT\"},\"contracts/libraries/UniswapV3PoolHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport { TickMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/TickMath.sol';\\n\\nimport { IUniswapV3Pool } from '@uniswap/v3-core-0.8-support/contracts/interfaces/IUniswapV3Pool.sol';\\n\\n/// @title UniswapV3Pool helper functions\\nlibrary UniswapV3PoolHelper {\\n    using UniswapV3PoolHelper for IUniswapV3Pool;\\n\\n    error UV3PH_OracleConsultFailed();\\n\\n    /// @notice Get the pool's current tick\\n    /// @param v3Pool The uniswap v3 pool contract\\n    /// @return tick the current tick\\n    function tickCurrent(IUniswapV3Pool v3Pool) internal view returns (int24 tick) {\\n        (, tick, , , , , ) = v3Pool.slot0();\\n    }\\n\\n    /// @notice Get the pool's current sqrt price\\n    /// @param v3Pool The uniswap v3 pool contract\\n    /// @return sqrtPriceX96 the current sqrt price\\n    function sqrtPriceCurrent(IUniswapV3Pool v3Pool) internal view returns (uint160 sqrtPriceX96) {\\n        (sqrtPriceX96, , , , , , ) = v3Pool.slot0();\\n    }\\n\\n    /// @notice Get twap price for uniswap v3 pool\\n    /// @param v3Pool The uniswap v3 pool contract\\n    /// @param twapDuration The twap period\\n    /// @return sqrtPriceX96 the twap price\\n    function twapSqrtPrice(IUniswapV3Pool v3Pool, uint32 twapDuration) internal view returns (uint160 sqrtPriceX96) {\\n        int24 _twapTick = v3Pool.twapTick(twapDuration);\\n        sqrtPriceX96 = TickMath.getSqrtRatioAtTick(_twapTick);\\n    }\\n\\n    /// @notice Get twap tick for uniswap v3 pool\\n    /// @param v3Pool The uniswap v3 pool contract\\n    /// @param twapDuration The twap period\\n    /// @return _twapTick the twap tick\\n    function twapTick(IUniswapV3Pool v3Pool, uint32 twapDuration) internal view returns (int24 _twapTick) {\\n        if (twapDuration == 0) {\\n            return v3Pool.tickCurrent();\\n        }\\n\\n        uint32[] memory secondAgos = new uint32[](2);\\n        secondAgos[0] = twapDuration;\\n        secondAgos[1] = 0;\\n\\n        // this call will fail if period is bigger than MaxObservationPeriod\\n        try v3Pool.observe(secondAgos) returns (int56[] memory tickCumulatives, uint160[] memory) {\\n            int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\\n            int24 timeWeightedAverageTick = int24(tickCumulativesDelta / int56(uint56(twapDuration)));\\n\\n            // Always round to negative infinity\\n            if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(twapDuration)) != 0)) {\\n                timeWeightedAverageTick--;\\n            }\\n            return timeWeightedAverageTick;\\n        } catch {\\n            // if for some reason v3Pool.observe fails, fallback to the current tick\\n            (, _twapTick, , , , , ) = v3Pool.slot0();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7c14ffade5bbb417584a69e08cf4005abde9af5c24e70042db815a6bad2e7b29\",\"license\":\"GPL-2.0-or-later\"},\"contracts/libraries/VTokenPosition.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\\nimport { FixedPoint128 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint128.sol';\\nimport { IUniswapV3Pool } from '@uniswap/v3-core-0.8-support/contracts/interfaces/IUniswapV3Pool.sol';\\n\\nimport { FundingPayment } from './FundingPayment.sol';\\nimport { LiquidityPosition } from './LiquidityPosition.sol';\\nimport { LiquidityPositionSet } from './LiquidityPositionSet.sol';\\nimport { Protocol } from './Protocol.sol';\\nimport { SignedFullMath } from './SignedFullMath.sol';\\nimport { UniswapV3PoolHelper } from './UniswapV3PoolHelper.sol';\\n\\nimport { IVPoolWrapper } from '../interfaces/IVPoolWrapper.sol';\\n\\n/// @title VToken position functions\\nlibrary VTokenPosition {\\n    using FullMath for uint256;\\n    using SignedFullMath for int256;\\n    using UniswapV3PoolHelper for IUniswapV3Pool;\\n\\n    using LiquidityPosition for LiquidityPosition.Info;\\n    using LiquidityPositionSet for LiquidityPosition.Set;\\n    using Protocol for Protocol.Info;\\n\\n    enum RISK_SIDE {\\n        LONG,\\n        SHORT\\n    }\\n\\n    struct Set {\\n        // Fixed length array of poolId = vTokenAddress.truncate()\\n        // Open positions in 8 different pairs at same time.\\n        // Collision between poolId is not possible.\\n        uint32[8] active; // array of poolIds\\n        mapping(uint32 => VTokenPosition.Info) positions; // poolId => Position\\n        int256 vQuoteBalance;\\n        uint256[100] _emptySlots; // reserved for adding variables when upgrading logic\\n    }\\n\\n    struct Info {\\n        int256 balance; // vTokenLong - vTokenShort\\n        int256 netTraderPosition;\\n        int256 sumALastX128;\\n        // this is moved from accounts to here because of the in margin available check\\n        // the loop needs to be done over liquidity positions of same token only\\n        LiquidityPosition.Set liquidityPositions;\\n        uint256[100] _emptySlots; // reserved for adding variables when upgrading logic\\n    }\\n\\n    /// @notice Gives the market value of the supplied token position\\n    /// @param position token position\\n    /// @param priceX128 price in Q128\\n    /// @param wrapper pool wrapper corresponding to position\\n    /// @return value market value with 6 decimals\\n    function marketValue(\\n        VTokenPosition.Info storage position,\\n        uint256 priceX128,\\n        IVPoolWrapper wrapper\\n    ) internal view returns (int256 value) {\\n        value = position.balance.mulDiv(priceX128, FixedPoint128.Q128);\\n        value += unrealizedFundingPayment(position, wrapper);\\n    }\\n\\n    /// @notice returns the market value of the supplied token position\\n    /// @param position token position\\n    /// @param priceX128 price in Q128\\n    /// @param poolId id of the rage trade pool\\n    /// @param protocol ref to the protocol state\\n    function marketValue(\\n        VTokenPosition.Info storage position,\\n        uint32 poolId,\\n        uint256 priceX128,\\n        Protocol.Info storage protocol\\n    ) internal view returns (int256 value) {\\n        return marketValue(position, priceX128, protocol.vPoolWrapper(poolId));\\n    }\\n\\n    /// @notice returns the market value of the supplied token position\\n    /// @param position token position\\n    /// @param poolId id of the rage trade pool\\n    /// @param protocol ref to the protocol state\\n    function marketValue(\\n        VTokenPosition.Info storage position,\\n        uint32 poolId,\\n        Protocol.Info storage protocol\\n    ) internal view returns (int256) {\\n        uint256 priceX128 = protocol.getCachedVirtualTwapPriceX128(poolId);\\n        return marketValue(position, poolId, priceX128, protocol);\\n    }\\n\\n    function riskSide(VTokenPosition.Info storage position) internal view returns (RISK_SIDE) {\\n        return position.balance > 0 ? RISK_SIDE.LONG : RISK_SIDE.SHORT;\\n    }\\n\\n    /// @notice returns the vQuoteIncrease due to unrealized funding payment for the trader position (+ve means receiving and -ve means paying)\\n    /// @param position token position\\n    /// @param wrapper pool wrapper corresponding to position\\n    /// @return unrealizedFpBill funding to be realized (+ve means receive and -ve means pay)\\n    function unrealizedFundingPayment(VTokenPosition.Info storage position, IVPoolWrapper wrapper)\\n        internal\\n        view\\n        returns (int256)\\n    {\\n        int256 extrapolatedSumAX128 = wrapper.getExtrapolatedSumAX128();\\n        int256 vQuoteIncrease = -FundingPayment.bill(\\n            extrapolatedSumAX128,\\n            position.sumALastX128,\\n            position.netTraderPosition\\n        );\\n        return vQuoteIncrease;\\n    }\\n\\n    /// @notice gets the account's net position for a given poolId\\n    /// @param position token position\\n    /// @param poolId id of the rage trade pool\\n    /// @param protocol ref to the protocol state\\n    /// @return net position\\n    function getNetPosition(\\n        VTokenPosition.Info storage position,\\n        uint32 poolId,\\n        Protocol.Info storage protocol\\n    ) internal view returns (int256) {\\n        return\\n            position.netTraderPosition +\\n            position.liquidityPositions.getNetPosition(protocol.vPool(poolId).sqrtPriceCurrent());\\n    }\\n}\\n\",\"keccak256\":\"0x9fbaf7aa199362453c1805021018327619e102df5131410a6872bea6965462fa\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/VTokenPositionSet.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport { FixedPoint128 } from '@uniswap/v3-core-0.8-support/contracts/libraries/FixedPoint128.sol';\\nimport { SafeCast } from '@uniswap/v3-core-0.8-support/contracts/libraries/SafeCast.sol';\\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\\n\\nimport { AddressHelper } from './AddressHelper.sol';\\nimport { LiquidityPosition } from './LiquidityPosition.sol';\\nimport { LiquidityPositionSet } from './LiquidityPositionSet.sol';\\nimport { Protocol } from './Protocol.sol';\\nimport { PriceMath } from './PriceMath.sol';\\nimport { SignedFullMath } from './SignedFullMath.sol';\\nimport { SignedMath } from './SignedMath.sol';\\nimport { VTokenPosition } from './VTokenPosition.sol';\\nimport { Uint32L8ArrayLib } from './Uint32L8Array.sol';\\n\\nimport { IClearingHouseStructures } from '../interfaces/clearinghouse/IClearingHouseStructures.sol';\\nimport { IVPoolWrapper } from '../interfaces/IVPoolWrapper.sol';\\nimport { IVToken } from '../interfaces/IVToken.sol';\\n\\n/// @title VToken position set functions\\nlibrary VTokenPositionSet {\\n    using AddressHelper for address;\\n    using FullMath for uint256;\\n    using PriceMath for uint256;\\n    using SafeCast for uint256;\\n    using SignedFullMath for int256;\\n    using SignedMath for int256;\\n    using Uint32L8ArrayLib for uint32[8];\\n\\n    using LiquidityPositionSet for LiquidityPosition.Set;\\n    using Protocol for Protocol.Info;\\n    using VTokenPosition for VTokenPosition.Info;\\n    using VTokenPositionSet for VTokenPosition.Set;\\n\\n    error VPS_IncorrectUpdate();\\n    error VPS_DeactivationFailed(uint32 poolId);\\n    error VPS_TokenInactive(uint32 poolId);\\n\\n    /// @notice denotes token position change\\n    /// @param accountId serial number of the account\\n    /// @param poolId truncated address of vtoken whose position was taken\\n    /// @param vTokenAmountOut amount of tokens that account received (positive) or paid (negative)\\n    /// @param vQuoteAmountOut amount of vQuote tokens that account received (positive) or paid (negative)\\n    /// @param sqrtPriceX96Start shows the sqrtPriceX96 at the start of trade execution, can be 0 if not on v3Pool\\n    /// @param sqrtPriceX96End shows the sqrtPriceX96 at the end of trade execution, can be 0 if not on v3Pool\\n    event TokenPositionChanged(\\n        uint256 indexed accountId,\\n        uint32 indexed poolId,\\n        int256 vTokenAmountOut,\\n        int256 vQuoteAmountOut,\\n        uint160 sqrtPriceX96Start,\\n        uint160 sqrtPriceX96End\\n    );\\n\\n    /// @notice denotes funding payment for a range / token position\\n    /// @param accountId serial number of the account\\n    /// @param poolId address of token for which funding was paid\\n    /// @param amount amount of funding paid (negative) or received (positive)\\n    /// @param sumALastX128 val of sum of the term A in funding payment math, when op took place\\n    event TokenPositionFundingPaymentRealized(\\n        uint256 indexed accountId,\\n        uint32 indexed poolId,\\n        int256 amount,\\n        int256 sumALastX128\\n    );\\n\\n    /**\\n     *  Internal methods\\n     */\\n\\n    /// @notice activates token with address 'vToken' if not already active\\n    /// @param set VTokenPositionSet\\n    /// @param poolId id of the rage trade pool\\n    function activate(VTokenPosition.Set storage set, uint32 poolId) internal {\\n        set.active.include(poolId);\\n    }\\n\\n    /// @notice deactivates token with address 'vToken'\\n    /// @dev ensures that the balance is 0 and there are not range positions active otherwise throws an error\\n    /// @param set VTokenPositionSet\\n    /// @param poolId id of the rage trade pool\\n    function deactivate(VTokenPosition.Set storage set, uint32 poolId) internal {\\n        if (set.positions[poolId].balance != 0 || !set.positions[poolId].liquidityPositions.isEmpty()) {\\n            revert VPS_DeactivationFailed(poolId);\\n        }\\n\\n        set.active.exclude(poolId);\\n    }\\n\\n    /// @notice updates token balance, net trader position and vQuote balance\\n    /// @dev realizes funding payment to vQuote balance\\n    /// @dev activates the token if not already active\\n    /// @dev deactivates the token if the balance = 0 and there are no range positions active\\n    /// @dev IMP: ensure that the global states are updated using zeroSwap or directly through some interaction with pool wrapper\\n    /// @param set VTokenPositionSet\\n    /// @param balanceAdjustments platform constants\\n    /// @param poolId id of the rage trade pool\\n    /// @param accountId account identifier, used for emitting event\\n    /// @param protocol platform constants\\n    function update(\\n        VTokenPosition.Set storage set,\\n        uint256 accountId,\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments,\\n        uint32 poolId,\\n        Protocol.Info storage protocol\\n    ) internal {\\n        set.realizeFundingPayment(accountId, poolId, protocol);\\n        set.active.include(poolId);\\n\\n        VTokenPosition.Info storage _VTokenPosition = set.positions[poolId];\\n        _VTokenPosition.balance += balanceAdjustments.vTokenIncrease;\\n        _VTokenPosition.netTraderPosition += balanceAdjustments.traderPositionIncrease;\\n\\n        set.vQuoteBalance += balanceAdjustments.vQuoteIncrease;\\n\\n        if (_VTokenPosition.balance == 0 && _VTokenPosition.liquidityPositions.active[0] == 0) {\\n            set.deactivate(poolId);\\n        }\\n    }\\n\\n    /// @notice realizes funding payment to vQuote balance\\n    /// @param set VTokenPositionSet\\n    /// @param poolId id of the rage trade pool\\n    /// @param accountId account identifier, used for emitting event\\n    /// @param protocol platform constants\\n    function realizeFundingPayment(\\n        VTokenPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        Protocol.Info storage protocol\\n    ) internal {\\n        set.realizeFundingPayment(accountId, poolId, protocol.pools[poolId].vPoolWrapper);\\n    }\\n\\n    /// @notice realizes funding payment to vQuote balance\\n    /// @param set VTokenPositionSet\\n    /// @param poolId id of the rage trade pool\\n    /// @param accountId account identifier, used for emitting event\\n    /// @param wrapper VPoolWrapper to override the set wrapper\\n    function realizeFundingPayment(\\n        VTokenPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        IVPoolWrapper wrapper\\n    ) internal {\\n        VTokenPosition.Info storage position = set.positions[poolId];\\n        int256 extrapolatedSumAX128 = wrapper.getSumAX128();\\n\\n        int256 fundingPayment = position.unrealizedFundingPayment(wrapper);\\n        set.vQuoteBalance += fundingPayment;\\n\\n        position.sumALastX128 = extrapolatedSumAX128;\\n\\n        emit TokenPositionFundingPaymentRealized(accountId, poolId, fundingPayment, extrapolatedSumAX128);\\n    }\\n\\n    /// @notice swaps tokens (Long and Short) with input in token amount / vQuote amount\\n    /// @param set VTokenPositionSet\\n    /// @param accountId account identifier, used for emitting event\\n    /// @param poolId id of the rage trade pool\\n    /// @param swapParams parameters for swap\\n    /// @param protocol platform constants\\n    /// @return vTokenAmountOut - token amount coming out of pool\\n    /// @return vQuoteAmountOut - vQuote amount coming out of pool\\n    function swapToken(\\n        VTokenPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        IClearingHouseStructures.SwapParams memory swapParams,\\n        Protocol.Info storage protocol\\n    ) internal returns (int256 vTokenAmountOut, int256 vQuoteAmountOut) {\\n        return set.swapToken(accountId, poolId, swapParams, protocol.vPoolWrapper(poolId), protocol);\\n    }\\n\\n    /// @notice swaps tokens (Long and Short) with input in token amount\\n    /// @dev activates inactive vToe\\n    /// @param set VTokenPositionSet\\n    /// @param accountId account identifier, used for emitting event\\n    /// @param poolId id of the rage trade pool\\n    /// @param vTokenAmount amount of the token\\n    /// @param protocol platform constants\\n    /// @return vTokenAmountOut - token amount coming out of pool\\n    /// @return vQuoteAmountOut - vQuote amount coming out of pool\\n    function swapTokenAmount(\\n        VTokenPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        int256 vTokenAmount,\\n        Protocol.Info storage protocol\\n    ) internal returns (int256 vTokenAmountOut, int256 vQuoteAmountOut) {\\n        return\\n            set.swapToken(\\n                accountId,\\n                poolId,\\n                /// @dev 0 means no price limit and false means amount mentioned is token amount\\n                IClearingHouseStructures.SwapParams({\\n                    amount: vTokenAmount,\\n                    sqrtPriceLimit: 0,\\n                    isNotional: false,\\n                    isPartialAllowed: false,\\n                    settleProfit: false\\n                }),\\n                protocol.vPoolWrapper(poolId),\\n                protocol\\n            );\\n    }\\n\\n    /// @notice swaps tokens (Long and Short) with input in token amount / vQuote amount\\n    /// @param set VTokenPositionSet\\n    /// @param accountId account identifier, used for emitting event\\n    /// @param poolId id of the rage trade pool\\n    /// @param swapParams parameters for swap\\n    /// @param wrapper VPoolWrapper to override the set wrapper\\n    /// @param protocol platform constants\\n    /// @return vTokenAmountOut - token amount coming out of pool\\n    /// @return vQuoteAmountOut - vQuote amount coming out of pool\\n    function swapToken(\\n        VTokenPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        IClearingHouseStructures.SwapParams memory swapParams,\\n        IVPoolWrapper wrapper,\\n        Protocol.Info storage protocol\\n    ) internal returns (int256 vTokenAmountOut, int256 vQuoteAmountOut) {\\n        IVPoolWrapper.SwapResult memory swapResult = wrapper.swap(\\n            swapParams.amount < 0,\\n            swapParams.isNotional ? swapParams.amount : -swapParams.amount,\\n            swapParams.sqrtPriceLimit\\n        );\\n\\n        // change direction basis uniswap to balance increase\\n        vTokenAmountOut = -swapResult.vTokenIn;\\n        vQuoteAmountOut = -swapResult.vQuoteIn;\\n\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments = IClearingHouseStructures\\n            .BalanceAdjustments(vQuoteAmountOut, vTokenAmountOut, vTokenAmountOut);\\n\\n        set.update(accountId, balanceAdjustments, poolId, protocol);\\n\\n        emit TokenPositionChanged(\\n            accountId,\\n            poolId,\\n            vTokenAmountOut,\\n            vQuoteAmountOut,\\n            swapResult.sqrtPriceX96Start,\\n            swapResult.sqrtPriceX96End\\n        );\\n    }\\n\\n    /// @notice function to liquidate all liquidity positions\\n    /// @param set VTokenPositionSet\\n    /// @param accountId account identifier, used for emitting event\\n    /// @param protocol platform constants\\n    /// @return notionalAmountClosed - value of net token position coming out (in notional) of all the ranges closed\\n    function liquidateLiquidityPositions(\\n        VTokenPosition.Set storage set,\\n        uint256 accountId,\\n        Protocol.Info storage protocol\\n    ) internal returns (uint256 notionalAmountClosed) {\\n        for (uint8 i = 0; i < set.active.length; i++) {\\n            uint32 truncated = set.active[i];\\n            if (truncated == 0) break;\\n\\n            notionalAmountClosed += set.liquidateLiquidityPositions(accountId, set.active[i], protocol);\\n        }\\n    }\\n\\n    /// @notice function to liquidate liquidity positions for a particular token\\n    /// @param set VTokenPositionSet\\n    /// @param accountId account identifier, used for emitting event\\n    /// @param poolId id of the rage trade pool\\n    /// @param protocol platform constants\\n    /// @return notionalAmountClosed - value of net token position coming out (in notional) of all the ranges closed\\n    function liquidateLiquidityPositions(\\n        VTokenPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        Protocol.Info storage protocol\\n    ) internal returns (uint256 notionalAmountClosed) {\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments;\\n\\n        set.getTokenPosition(poolId, false).liquidityPositions.closeAllLiquidityPositions(\\n            accountId,\\n            poolId,\\n            balanceAdjustments,\\n            protocol\\n        );\\n\\n        set.update(accountId, balanceAdjustments, poolId, protocol);\\n\\n        // returns notional value of token position closed\\n        return protocol.getNotionalValue(poolId, balanceAdjustments.traderPositionIncrease);\\n    }\\n\\n    /// @notice function for liquidity add/remove\\n    /// @param set VTokenPositionSet\\n    /// @param accountId account identifier, used for emitting event\\n    /// @param poolId id of the rage trade pool\\n    /// @param liquidityChangeParams includes tickLower, tickUpper, liquidityDelta, limitOrderType\\n    /// @return vTokenAmountOut amount of tokens that account received (positive) or paid (negative)\\n    /// @return vQuoteAmountOut amount of vQuote tokens that account received (positive) or paid (negative)\\n    function liquidityChange(\\n        VTokenPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        IClearingHouseStructures.LiquidityChangeParams memory liquidityChangeParams,\\n        Protocol.Info storage protocol\\n    ) internal returns (int256 vTokenAmountOut, int256 vQuoteAmountOut) {\\n        VTokenPosition.Info storage vTokenPosition = set.getTokenPosition(poolId, true);\\n\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments;\\n\\n        vTokenPosition.liquidityPositions.liquidityChange(\\n            accountId,\\n            poolId,\\n            liquidityChangeParams,\\n            balanceAdjustments,\\n            protocol\\n        );\\n\\n        set.update(accountId, balanceAdjustments, poolId, protocol);\\n\\n        if (liquidityChangeParams.closeTokenPosition && balanceAdjustments.traderPositionIncrease != 0) {\\n            set.swapTokenAmount(accountId, poolId, -balanceAdjustments.traderPositionIncrease, protocol);\\n        }\\n\\n        return (balanceAdjustments.vTokenIncrease, balanceAdjustments.vQuoteIncrease);\\n    }\\n\\n    /// @notice function to remove an eligible limit order\\n    /// @dev checks whether the current price is on the correct side of the range based on the type of limit order (None, Low, High)\\n    /// @param set VTokenPositionSet\\n    /// @param accountId account identifier, used for emitting event\\n    /// @param poolId id of the rage trade pool\\n    /// @param tickLower lower tick index for the range\\n    /// @param tickUpper upper tick index for the range\\n    /// @param protocol platform constants\\n    function removeLimitOrder(\\n        VTokenPosition.Set storage set,\\n        uint256 accountId,\\n        uint32 poolId,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        Protocol.Info storage protocol\\n    ) internal {\\n        VTokenPosition.Info storage vTokenPosition = set.getTokenPosition(poolId, false);\\n\\n        IClearingHouseStructures.BalanceAdjustments memory balanceAdjustments;\\n        int24 currentTick = protocol.getVirtualCurrentTick(poolId);\\n\\n        vTokenPosition.liquidityPositions.removeLimitOrder(\\n            accountId,\\n            poolId,\\n            currentTick,\\n            tickLower,\\n            tickUpper,\\n            balanceAdjustments,\\n            protocol\\n        );\\n\\n        set.update(accountId, balanceAdjustments, poolId, protocol);\\n    }\\n\\n    function updateOpenPoolPrices(VTokenPosition.Set storage set, Protocol.Info storage protocol) internal {\\n        for (uint8 i = 0; i < set.active.length; i++) {\\n            uint32 poolId = set.active[i];\\n            if (poolId == 0) break;\\n            protocol.updatePoolPriceCache(poolId);\\n        }\\n    }\\n\\n    /**\\n     *  Internal view methods\\n     */\\n\\n    /// @notice returns account market value of active positions\\n    /// @param set VTokenPositionSet\\n    /// @param protocol platform constants\\n    /// @return accountMarketValue - value of all active positions\\n    function getAccountMarketValue(VTokenPosition.Set storage set, Protocol.Info storage protocol)\\n        internal\\n        view\\n        returns (int256 accountMarketValue)\\n    {\\n        for (uint8 i = 0; i < set.active.length; i++) {\\n            uint32 poolId = set.active[i];\\n            if (poolId == 0) break;\\n            // IVToken vToken = protocol[poolId].vToken;\\n            VTokenPosition.Info storage position = set.positions[poolId];\\n\\n            (, uint256 virtualPriceX128) = protocol.getCachedTwapPricesWithDeviationCheck(poolId);\\n            uint160 virtualSqrtPriceX96 = virtualPriceX128.toSqrtPriceX96();\\n            //Value of token position for current vToken\\n            accountMarketValue += position.marketValue(poolId, virtualPriceX128, protocol);\\n\\n            //Value of all active range position for the current vToken\\n            accountMarketValue += position.liquidityPositions.marketValue(virtualSqrtPriceX96, poolId, protocol);\\n        }\\n\\n        // Value of the vQuote token balance\\n        accountMarketValue += set.vQuoteBalance;\\n    }\\n\\n    /// @notice gets information about the token and liquidity positions for all the pools\\n    /// @param set VTokenPositionSet\\n    /// @return vQuoteBalance vQuote balance for the token position\\n    /// @return vTokenPositions array of vToken position\\n    function getInfo(VTokenPosition.Set storage set)\\n        internal\\n        view\\n        returns (int256 vQuoteBalance, IClearingHouseStructures.VTokenPositionView[] memory vTokenPositions)\\n    {\\n        vQuoteBalance = set.vQuoteBalance;\\n\\n        uint256 numberOfTokenPositions = set.active.numberOfNonZeroElements();\\n        vTokenPositions = new IClearingHouseStructures.VTokenPositionView[](numberOfTokenPositions);\\n\\n        for (uint256 i = 0; i < numberOfTokenPositions; i++) {\\n            vTokenPositions[i].poolId = set.active[i];\\n            vTokenPositions[i].balance = set.positions[set.active[i]].balance;\\n            vTokenPositions[i].netTraderPosition = set.positions[set.active[i]].netTraderPosition;\\n            vTokenPositions[i].sumALastX128 = set.positions[set.active[i]].sumALastX128;\\n            vTokenPositions[i].liquidityPositions = set.positions[set.active[i]].liquidityPositions.getInfo();\\n        }\\n    }\\n\\n    /// @notice returns the long and short side risk for range positions of a particular token\\n    /// @param set VTokenPositionSet\\n    /// @param isInitialMargin specifies to use initial margin factor (true) or maintainance margin factor (false)\\n    /// @param poolId id of the rage trade pool\\n    /// @param protocol platform constants\\n    /// @return longSideRisk - risk if the token price goes down\\n    /// @return shortSideRisk - risk if the token price goes up\\n    function getLongShortSideRisk(\\n        VTokenPosition.Set storage set,\\n        bool isInitialMargin,\\n        uint32 poolId,\\n        Protocol.Info storage protocol\\n    ) internal view returns (int256 longSideRisk, int256 shortSideRisk) {\\n        VTokenPosition.Info storage position = set.positions[poolId];\\n\\n        (, uint256 virtualPriceX128) = protocol.getCachedTwapPricesWithDeviationCheck(poolId);\\n        uint160 virtualSqrtPriceX96 = virtualPriceX128.toSqrtPriceX96();\\n\\n        uint16 marginRatio = protocol.getMarginRatioBps(poolId, isInitialMargin);\\n\\n        int256 tokenPosition = position.balance;\\n        int256 longSideRiskRanges = position.liquidityPositions.longSideRisk(virtualSqrtPriceX96).toInt256();\\n\\n        longSideRisk = SignedMath\\n            .max(position.netTraderPosition.mulDiv(virtualPriceX128, FixedPoint128.Q128) + longSideRiskRanges, 0)\\n            .mulDiv(marginRatio, 1e4);\\n\\n        shortSideRisk = SignedMath.max(-tokenPosition, 0).mulDiv(virtualPriceX128, FixedPoint128.Q128).mulDiv(\\n            marginRatio,\\n            1e4\\n        );\\n        return (longSideRisk, shortSideRisk);\\n    }\\n\\n    /// @notice gets the net position for the given poolId\\n    /// @param set VTokenPositionSet\\n    /// @param poolId id of the rage trade pool\\n    /// @param protocol platform constants\\n    /// @return netPosition net position of the account for the pool\\n    function getNetPosition(\\n        VTokenPosition.Set storage set,\\n        uint32 poolId,\\n        Protocol.Info storage protocol\\n    ) internal view returns (int256 netPosition) {\\n        if (!set.active.exists(poolId)) return 0;\\n        VTokenPosition.Info storage tokenPosition = set.positions[poolId];\\n        return tokenPosition.getNetPosition(poolId, protocol);\\n    }\\n\\n    /// @notice returns the long and short side risk for range positions of a particular token\\n    /// @param set VTokenPositionSet\\n    /// @param isInitialMargin specifies to use initial margin factor (true) or maintainance margin factor (false)\\n    /// @param protocol platform constants\\n    /// @return requiredMargin - required margin value based on the current active positions\\n    function getRequiredMargin(\\n        VTokenPosition.Set storage set,\\n        bool isInitialMargin,\\n        Protocol.Info storage protocol\\n    ) internal view returns (int256 requiredMargin) {\\n        int256 longSideRiskTotal;\\n        int256 shortSideRiskTotal;\\n        int256 longSideRisk;\\n        int256 shortSideRisk;\\n        for (uint8 i = 0; i < set.active.length; i++) {\\n            if (set.active[i] == 0) break;\\n            uint32 poolId = set.active[i];\\n            (longSideRisk, shortSideRisk) = set.getLongShortSideRisk(isInitialMargin, poolId, protocol);\\n\\n            if (protocol.isPoolCrossMargined(poolId)) {\\n                longSideRiskTotal += longSideRisk;\\n                shortSideRiskTotal += shortSideRisk;\\n            } else {\\n                requiredMargin += SignedMath.max(longSideRisk, shortSideRisk);\\n            }\\n        }\\n\\n        requiredMargin += SignedMath.max(longSideRiskTotal, shortSideRiskTotal);\\n    }\\n\\n    /// @notice get or create token position\\n    /// @dev activates inactive vToken if isCreateNew is true else reverts\\n    /// @param set VTokenPositionSet\\n    /// @param poolId id of the rage trade pool\\n    /// @param createNew if 'vToken' is inactive then activates (true) else reverts with TokenInactive(false)\\n    /// @return position - VTokenPosition corresponding to 'vToken'\\n    function getTokenPosition(\\n        VTokenPosition.Set storage set,\\n        uint32 poolId,\\n        bool createNew\\n    ) internal returns (VTokenPosition.Info storage position) {\\n        if (createNew) {\\n            set.activate(poolId);\\n        } else if (!set.active.exists(poolId)) {\\n            revert VPS_TokenInactive(poolId);\\n        }\\n\\n        position = set.positions[poolId];\\n    }\\n\\n    /// @notice returns true if the set does not have any token position active\\n    /// @param set VTokenPositionSet\\n    /// @return True if there are no active positions\\n    function isEmpty(VTokenPosition.Set storage set) internal view returns (bool) {\\n        return set.active.isEmpty();\\n    }\\n\\n    /// @notice returns true if range position is active for 'vToken'\\n    /// @param set VTokenPositionSet\\n    /// @param poolId poolId of the vToken\\n    /// @return isRangeActive - True if the range position is active\\n    function isTokenRangeActive(VTokenPosition.Set storage set, uint32 poolId) internal returns (bool isRangeActive) {\\n        VTokenPosition.Info storage vTokenPosition = set.getTokenPosition(poolId, false);\\n        isRangeActive = !vTokenPosition.liquidityPositions.isEmpty();\\n    }\\n}\\n\",\"keccak256\":\"0xeaad27a02472015a705f48c1c4cc42bfbac2380de5206583a8ba2fd8ad62579f\",\"license\":\"BUSL-1.1\"},\"contracts/protocol/clearinghouse/ClearingHouse.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.14;\\n\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport { Initializable } from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport { PausableUpgradeable } from '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\\nimport { SafeCast } from '@uniswap/v3-core-0.8-support/contracts/libraries/SafeCast.sol';\\n\\nimport { Account } from '../../libraries/Account.sol';\\nimport { AddressHelper } from '../../libraries/AddressHelper.sol';\\nimport { BatchedLoop } from '../../libraries/BatchedLoop.sol';\\nimport { Protocol } from '../../libraries/Protocol.sol';\\nimport { SignedMath } from '../../libraries/SignedMath.sol';\\n\\nimport { IClearingHouse } from '../../interfaces/IClearingHouse.sol';\\nimport { IInsuranceFund } from '../../interfaces/IInsuranceFund.sol';\\nimport { IVPoolWrapper } from '../../interfaces/IVPoolWrapper.sol';\\nimport { IOracle } from '../../interfaces/IOracle.sol';\\nimport { IVQuote } from '../../interfaces/IVQuote.sol';\\nimport { IVToken } from '../../interfaces/IVToken.sol';\\n\\nimport { IClearingHouseActions } from '../../interfaces/clearinghouse/IClearingHouseActions.sol';\\nimport { IClearingHouseStructures } from '../../interfaces/clearinghouse/IClearingHouseStructures.sol';\\nimport { IClearingHouseEnums } from '../../interfaces/clearinghouse/IClearingHouseEnums.sol';\\nimport { IClearingHouseOwnerActions } from '../../interfaces/clearinghouse/IClearingHouseOwnerActions.sol';\\nimport { IClearingHouseSystemActions } from '../../interfaces/clearinghouse/IClearingHouseSystemActions.sol';\\n\\nimport { Governable } from '../../utils/Governable.sol';\\nimport { Multicall } from '../../utils/Multicall.sol';\\nimport { ClearingHouseView } from './ClearingHouseView.sol';\\n\\ncontract ClearingHouse is\\n    IClearingHouse,\\n    Multicall,\\n    ClearingHouseView, // contains storage\\n    Initializable, // contains storage\\n    PausableUpgradeable, // contains storage\\n    Governable // contains storage\\n{\\n    using AddressHelper for address;\\n    using AddressHelper for IERC20;\\n    using AddressHelper for IVToken;\\n    using SafeERC20 for IERC20;\\n    using SignedMath for int256;\\n    using SafeCast for uint256;\\n    using SafeCast for int256;\\n\\n    using Account for Account.Info;\\n    using BatchedLoop for BatchedLoop.Info;\\n    using Protocol for Protocol.Info;\\n\\n    uint16 constant PERC_100_BPS = 10000; // 100% in basis points\\n    uint16 constant PERC_10_1E5 = 10000; // 10% in base 1e5\\n\\n    modifier onlyRageTradeFactory() {\\n        if (rageTradeFactoryAddress != msg.sender) revert NotRageTradeFactory();\\n        _;\\n    }\\n\\n    /**\\n        SYSTEM FUNCTIONS\\n     */\\n\\n    function initialize(\\n        address _rageTradeFactoryAddress,\\n        address initialGovernance,\\n        address initialTeamMultisig,\\n        IERC20 _defaultCollateralToken,\\n        IOracle _defaultCollateralTokenOracle,\\n        IInsuranceFund _insuranceFund,\\n        IVQuote _vQuote\\n    ) external initializer {\\n        rageTradeFactoryAddress = _rageTradeFactoryAddress;\\n        protocol.settlementToken = _defaultCollateralToken;\\n        insuranceFund = _insuranceFund;\\n\\n        protocol.vQuote = _vQuote;\\n\\n        _updateCollateralSettings(\\n            _defaultCollateralToken,\\n            CollateralSettings({ oracle: _defaultCollateralTokenOracle, twapDuration: 60, isAllowedForDeposit: true })\\n        );\\n\\n        __Governable_init(initialGovernance, initialTeamMultisig);\\n        __Pausable_init_unchained();\\n    }\\n\\n    function registerPool(Pool calldata poolInfo) external onlyRageTradeFactory {\\n        uint32 poolId = poolInfo.vToken.truncate();\\n\\n        // pool will not be registered twice by the rage trade factory\\n        assert(protocol.pools[poolId].vToken.isZero());\\n\\n        protocol.pools[poolId] = poolInfo;\\n        protocol.poolIds.push(poolId);\\n\\n        emit PoolSettingsUpdated(poolId, poolInfo.settings);\\n    }\\n\\n    /**\\n        ADMIN FUNCTIONS\\n     */\\n\\n    function updateCollateralSettings(IERC20 cToken, CollateralSettings memory collateralSettings)\\n        external\\n        onlyGovernance\\n    {\\n        if ((address(collateralSettings.oracle)).isZero()) revert InvalidSetting(0x10);\\n        if (collateralSettings.twapDuration > 1 days) revert InvalidSetting(0x11);\\n        _updateCollateralSettings(cToken, collateralSettings);\\n    }\\n\\n    function updatePoolSettings(uint32 poolId, PoolSettings calldata newSettings) external onlyGovernance {\\n        protocol.pools[poolId].settings = newSettings;\\n        if ((address(newSettings.oracle)).isZero()) revert InvalidSetting(0x20);\\n        if (newSettings.twapDuration < 5 minutes || newSettings.twapDuration > 1 days) revert InvalidSetting(0x21);\\n        if (newSettings.initialMarginRatioBps > PERC_100_BPS) revert InvalidSetting(0x22);\\n        if (newSettings.maintainanceMarginRatioBps > PERC_100_BPS) revert InvalidSetting(0x23);\\n        if (newSettings.maxVirtualPriceDeviationRatioBps > (PERC_100_BPS * 2) / 10) revert InvalidSetting(0x24);\\n\\n        emit PoolSettingsUpdated(poolId, newSettings);\\n    }\\n\\n    function updateProtocolSettings(\\n        LiquidationParams calldata _liquidationParams,\\n        uint256 _removeLimitOrderFee,\\n        uint256 _minimumOrderNotional,\\n        uint256 _minRequiredMargin\\n    ) external onlyGovernance {\\n        if (_liquidationParams.rangeLiquidationFeeFraction > PERC_10_1E5) revert InvalidSetting(0x30);\\n        if (_liquidationParams.tokenLiquidationFeeFraction > PERC_10_1E5) revert InvalidSetting(0x31);\\n        if (_liquidationParams.closeFactorMMThresholdBps > PERC_100_BPS) revert InvalidSetting(0x32);\\n        if (_liquidationParams.partialLiquidationCloseFactorBps > PERC_100_BPS) revert InvalidSetting(0x33);\\n        if (_liquidationParams.insuranceFundFeeShareBps > PERC_100_BPS) revert InvalidSetting(0x34);\\n        if (_liquidationParams.liquidationSlippageSqrtToleranceBps > PERC_100_BPS / 10) revert InvalidSetting(0x35);\\n        if (_liquidationParams.maxRangeLiquidationFees > 1000e6) revert InvalidSetting(0x36);\\n        if (_liquidationParams.minNotionalLiquidatable > 1000e6) revert InvalidSetting(0x37);\\n        if (_removeLimitOrderFee > 1000e6) revert InvalidSetting(0x38);\\n        if (_minimumOrderNotional > 1000e6) revert InvalidSetting(0x39);\\n        if (_minRequiredMargin > 1000e6) revert InvalidSetting(0x3A);\\n\\n        protocol.liquidationParams = _liquidationParams;\\n        protocol.removeLimitOrderFee = _removeLimitOrderFee;\\n        protocol.minimumOrderNotional = _minimumOrderNotional;\\n        protocol.minRequiredMargin = _minRequiredMargin;\\n        emit ProtocolSettingsUpdated(\\n            _liquidationParams,\\n            _removeLimitOrderFee,\\n            _minimumOrderNotional,\\n            _minRequiredMargin\\n        );\\n    }\\n\\n    function pause(uint256 numberOfPoolsToUpdateInThisTx) external onlyGovernanceOrTeamMultisig whenNotPaused {\\n        if (unpauseLoop.isInProgress()) revert CannotPauseIfUnpauseInProgress();\\n\\n        bool completed = pauseLoop.iterate({\\n            startAt: 0,\\n            endBefore: protocol.poolIds.length,\\n            batchSize: numberOfPoolsToUpdateInThisTx,\\n            execute: _forEachPoolOnPause\\n        });\\n\\n        if (completed) _pause();\\n    }\\n\\n    function unpause(uint256 numberOfPoolsToUpdateInThisTx) external onlyGovernanceOrTeamMultisig whenPaused {\\n        if (pauseLoop.isInProgress()) revert CannotUnpauseIfPauseInProgress();\\n\\n        bool completed = unpauseLoop.iterate({\\n            startAt: 0,\\n            endBefore: protocol.poolIds.length,\\n            batchSize: numberOfPoolsToUpdateInThisTx,\\n            execute: _forEachPoolOnUnpause\\n        });\\n\\n        if (completed) _unpause();\\n    }\\n\\n    /// @inheritdoc IClearingHouseOwnerActions\\n    function withdrawProtocolFee(uint256 numberOfPoolsToUpdateInThisTx) external {\\n        withdrawProtocolFeeLoop.iterate({\\n            startAt: 0,\\n            endBefore: protocol.poolIds.length,\\n            batchSize: numberOfPoolsToUpdateInThisTx,\\n            execute: _forEachPoolOnWithdrawProtocolFee\\n        });\\n    }\\n\\n    /**\\n        USER FUNCTIONS\\n     */\\n\\n    /// @inheritdoc IClearingHouseActions\\n    function createAccount() public whenNotPaused returns (uint256 newAccountId) {\\n        newAccountId = numAccounts;\\n        numAccounts = newAccountId + 1; // SSTORE\\n\\n        Account.Info storage newAccount = accounts[newAccountId];\\n        newAccount.owner = msg.sender;\\n        newAccount.id = uint96(newAccountId);\\n\\n        emit AccountCreated(msg.sender, newAccountId);\\n    }\\n\\n    /// @inheritdoc IClearingHouseActions\\n    function updateMargin(\\n        uint256 accountId,\\n        uint32 collateralId,\\n        int256 amount\\n    ) public whenNotPaused {\\n        Account.Info storage account = _getAccountAndCheckOwner(accountId);\\n        _updateAccountPoolPrices(account);\\n        _updateMargin(account, collateralId, amount, amount < 0);\\n    }\\n\\n    /// @inheritdoc IClearingHouseActions\\n    function createAccountAndAddMargin(uint32 collateralId, uint256 amount) external returns (uint256 newAccountId) {\\n        newAccountId = createAccount();\\n        updateMargin(newAccountId, collateralId, int256(amount));\\n    }\\n\\n    /// @inheritdoc IClearingHouseActions\\n    function updateProfit(uint256 accountId, int256 amount) external whenNotPaused {\\n        Account.Info storage account = _getAccountAndCheckOwner(accountId);\\n        _updateAccountPoolPrices(account);\\n        _updateProfit(account, amount, true);\\n    }\\n\\n    /// @inheritdoc IClearingHouseActions\\n    function settleProfit(uint256 accountId) external whenNotPaused {\\n        Account.Info storage account = _getAccountAndCheckOwner(accountId);\\n        _updateAccountPoolPrices(account);\\n        account.settleProfit(protocol);\\n    }\\n\\n    /// @inheritdoc IClearingHouseActions\\n    function swapToken(\\n        uint256 accountId,\\n        uint32 poolId,\\n        SwapParams memory swapParams\\n    ) external whenNotPaused returns (int256 vTokenAmountOut, int256 vQuoteAmountOut) {\\n        Account.Info storage account = _getAccountAndCheckOwner(accountId);\\n        _updateAccountPoolPrices(account);\\n        return _swapToken(account, poolId, swapParams, true);\\n    }\\n\\n    /// @inheritdoc IClearingHouseActions\\n    function updateRangeOrder(\\n        uint256 accountId,\\n        uint32 poolId,\\n        LiquidityChangeParams calldata liquidityChangeParams\\n    ) external whenNotPaused returns (int256 vTokenAmountOut, int256 vQuoteAmountOut) {\\n        Account.Info storage account = _getAccountAndCheckOwner(accountId);\\n        _updateAccountPoolPrices(account);\\n        return _updateRangeOrder(account, poolId, liquidityChangeParams, true);\\n    }\\n\\n    /// @inheritdoc IClearingHouseActions\\n    function removeLimitOrder(\\n        uint256 accountId,\\n        uint32 poolId,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external {\\n        _updateAccountPoolPrices(accounts[accountId]);\\n        _removeLimitOrder(accountId, poolId, tickLower, tickUpper);\\n    }\\n\\n    /// @inheritdoc IClearingHouseActions\\n    function liquidateLiquidityPositions(uint256 accountId) external {\\n        _updateAccountPoolPrices(accounts[accountId]);\\n        _liquidateLiquidityPositions(accountId);\\n    }\\n\\n    /// @inheritdoc IClearingHouseActions\\n    function liquidateTokenPosition(uint256 targetAccountId, uint32 poolId) external returns (int256 keeperFee) {\\n        _updateAccountPoolPrices(accounts[targetAccountId]);\\n        return _liquidateTokenPosition(targetAccountId, poolId);\\n    }\\n\\n    /**\\n        MULTICALL\\n     */\\n\\n    function multicallWithSingleMarginCheck(uint256 accountId, MulticallOperation[] calldata operations)\\n        external\\n        returns (bytes[] memory results)\\n    {\\n        results = new bytes[](operations.length);\\n\\n        Account.Info storage account = accounts[accountId];\\n        _updateAccountPoolPrices(account);\\n\\n        bool checkOwner = false;\\n        bool checkProfit = false;\\n        bool checkMargin = false;\\n\\n        for (uint256 i; i < operations.length; i++) {\\n            if (operations[i].operationType == MulticallOperationType.UPDATE_MARGIN) {\\n                // ADD_MARGIN\\n                (uint32 collateralId, int256 amount) = abi.decode(operations[i].data, (uint32, int256));\\n                checkOwner = true;\\n                checkMargin = checkMargin || amount < 0;\\n                _updateMargin(account, collateralId, amount, false);\\n            } else if (operations[i].operationType == MulticallOperationType.UPDATE_PROFIT) {\\n                // UPDATE_PROFIT\\n                int256 amount = abi.decode(operations[i].data, (int256));\\n                _updateProfit(account, amount, false);\\n                checkOwner = true;\\n                if (amount < 0) {\\n                    checkProfit = true;\\n                    checkMargin = true;\\n                }\\n            } else if (operations[i].operationType == MulticallOperationType.SWAP_TOKEN) {\\n                // SWAP_TOKEN\\n                (uint32 poolId, SwapParams memory sp) = abi.decode(operations[i].data, (uint32, SwapParams));\\n                (int256 vTokenAmountOut, int256 vQuoteAmountOut) = _swapToken(account, poolId, sp, false);\\n                results[i] = abi.encode(vTokenAmountOut, vQuoteAmountOut);\\n                checkOwner = true;\\n                checkMargin = true;\\n            } else if (operations[i].operationType == MulticallOperationType.UPDATE_RANGE_ORDER) {\\n                // UPDATE_RANGE_ORDER\\n                (uint32 poolId, LiquidityChangeParams memory lcp) = abi.decode(\\n                    operations[i].data,\\n                    (uint32, LiquidityChangeParams)\\n                );\\n                (int256 vTokenAmountOut, int256 vQuoteAmountOut) = _updateRangeOrder(account, poolId, lcp, false);\\n                results[i] = abi.encode(vTokenAmountOut, vQuoteAmountOut);\\n                checkOwner = true;\\n                checkMargin = true;\\n            } else if (operations[i].operationType == MulticallOperationType.REMOVE_LIMIT_ORDER) {\\n                // REMOVE_LIMIT_ORDER\\n                (uint32 poolId, int24 tickLower, int24 tickUpper) = abi.decode(\\n                    operations[i].data,\\n                    (uint32, int24, int24)\\n                );\\n                _removeLimitOrder(accountId, poolId, tickLower, tickUpper);\\n            } else if (operations[i].operationType == MulticallOperationType.LIQUIDATE_LIQUIDITY_POSITIONS) {\\n                // LIQUIDATE_LIQUIDITY_POSITIONS\\n                uint32 accountToLiquidate = abi.decode(operations[i].data, (uint32));\\n                _liquidateLiquidityPositions(accountToLiquidate);\\n            } else if (operations[i].operationType == MulticallOperationType.LIQUIDATE_TOKEN_POSITION) {\\n                // LIQUIDATE_TOKEN_POSITION\\n                (uint32 accountToLiquidate, uint32 poolId) = abi.decode(operations[i].data, (uint32, uint32));\\n                results[i] = abi.encode(_liquidateTokenPosition(accountToLiquidate, poolId));\\n            } else {\\n                revert InvalidMulticallOperationType(operations[i].operationType);\\n            }\\n        }\\n\\n        // after all the operations are done, check the margin requirements\\n        if (checkOwner) _getAccountAndCheckOwner(accountId);\\n        if (checkProfit) account.checkIfProfitAvailable(protocol);\\n        if (checkMargin) account.checkIfMarginAvailable(true, protocol);\\n\\n        return results;\\n    }\\n\\n    /**\\n        INTERNAL HELPERS\\n     */\\n\\n    function _updateAccountPoolPrices(Account.Info storage account) internal {\\n        account.updateAccountPoolPrices(protocol);\\n    }\\n\\n    function _updateMargin(\\n        Account.Info storage account,\\n        uint32 collateralId,\\n        int256 amount,\\n        bool checkMargin\\n    ) internal whenNotPaused {\\n        Collateral storage collateral = _checkCollateralIdAndGetInfo({\\n            collateralId: collateralId,\\n            isWithdraw: amount < 0\\n        });\\n\\n        // delegate call to account library to perform state update and emit events\\n        account.updateMargin(collateralId, amount, protocol, checkMargin);\\n\\n        // transfer settlement tokens between clearing house and account owner\\n        if (amount > 0) {\\n            collateral.token.safeTransferFrom(msg.sender, address(this), uint256(amount));\\n        } else if (amount < 0) {\\n            collateral.token.safeTransfer(msg.sender, uint256(-amount));\\n        }\\n    }\\n\\n    function _updateProfit(\\n        Account.Info storage account,\\n        int256 amount,\\n        bool checkMargin\\n    ) internal whenNotPaused {\\n        if (amount == 0) revert ZeroAmount();\\n\\n        account.updateProfit(amount, protocol, checkMargin);\\n        if (amount > 0) {\\n            protocol.settlementToken.safeTransferFrom(msg.sender, address(this), uint256(amount));\\n        } else {\\n            protocol.settlementToken.safeTransfer(msg.sender, uint256(-amount));\\n        }\\n    }\\n\\n    function _updateRangeOrder(\\n        Account.Info storage account,\\n        uint32 poolId,\\n        LiquidityChangeParams memory liquidityChangeParams,\\n        bool checkMargin\\n    ) internal whenNotPaused returns (int256 vTokenAmountOut, int256 vQuoteAmountOut) {\\n        _checkPoolId(poolId);\\n\\n        if (liquidityChangeParams.sqrtPriceCurrent != 0) {\\n            _checkSlippage(poolId, liquidityChangeParams.sqrtPriceCurrent, liquidityChangeParams.slippageToleranceBps);\\n        }\\n\\n        uint256 notionalValueAbs;\\n        (vTokenAmountOut, vQuoteAmountOut, notionalValueAbs) = account.liquidityChange(\\n            poolId,\\n            liquidityChangeParams,\\n            protocol,\\n            checkMargin\\n        );\\n\\n        if (notionalValueAbs < protocol.minimumOrderNotional) revert LowNotionalValue(notionalValueAbs);\\n    }\\n\\n    function _swapToken(\\n        Account.Info storage account,\\n        uint32 poolId,\\n        SwapParams memory swapParams,\\n        bool checkMargin\\n    ) internal whenNotPaused returns (int256 vTokenAmountOut, int256 vQuoteAmountOut) {\\n        _checkPoolId(poolId);\\n\\n        (vTokenAmountOut, vQuoteAmountOut) = account.swapToken(poolId, swapParams, protocol, checkMargin);\\n\\n        uint256 vQuoteAmountOutAbs = uint256(vQuoteAmountOut.abs());\\n        if (vQuoteAmountOutAbs < protocol.minimumOrderNotional) revert LowNotionalValue(vQuoteAmountOutAbs);\\n\\n        if (swapParams.sqrtPriceLimit != 0 && !swapParams.isPartialAllowed) {\\n            if (\\n                !((swapParams.isNotional && vQuoteAmountOut.abs() == swapParams.amount.abs()) ||\\n                    (!swapParams.isNotional && vTokenAmountOut.abs() == swapParams.amount.abs()))\\n            ) revert SlippageBeyondTolerance();\\n        }\\n    }\\n\\n    function _liquidateLiquidityPositions(uint256 accountId) internal whenNotPaused returns (int256) {\\n        Account.Info storage account = accounts[accountId];\\n\\n        (int256 keeperFee, int256 insuranceFundFee, int256 accountMarketValue) = account.liquidateLiquidityPositions(\\n            protocol\\n        );\\n\\n        int256 accountFee = keeperFee + insuranceFundFee;\\n\\n        if (keeperFee <= 0) revert KeeperFeeNotPositive(keeperFee);\\n        protocol.settlementToken.safeTransfer(msg.sender, uint256(keeperFee));\\n        _transferInsuranceFundFee(insuranceFundFee);\\n\\n        emit Account.LiquidityPositionsLiquidated(\\n            accountId,\\n            msg.sender,\\n            accountFee,\\n            keeperFee,\\n            insuranceFundFee,\\n            accountMarketValue\\n        );\\n\\n        return keeperFee;\\n    }\\n\\n    function _liquidateTokenPosition(uint256 accountId, uint32 poolId)\\n        internal\\n        whenNotPaused\\n        returns (int256 keeperFee)\\n    {\\n        Account.Info storage account = accounts[accountId];\\n\\n        _checkPoolId(poolId);\\n        int256 insuranceFundFee;\\n        (keeperFee, insuranceFundFee) = account.liquidateTokenPosition(poolId, protocol);\\n        if (keeperFee <= 0) revert KeeperFeeNotPositive(keeperFee);\\n        protocol.settlementToken.safeTransfer(msg.sender, uint256(keeperFee));\\n        _transferInsuranceFundFee(insuranceFundFee);\\n    }\\n\\n    function _removeLimitOrder(\\n        uint256 accountId,\\n        uint32 poolId,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal whenNotPaused returns (uint256 keeperFee) {\\n        Account.Info storage account = accounts[accountId];\\n\\n        _checkPoolId(poolId);\\n        keeperFee = protocol.removeLimitOrderFee;\\n\\n        account.removeLimitOrder(poolId, tickLower, tickUpper, keeperFee, protocol);\\n\\n        protocol.settlementToken.safeTransfer(msg.sender, keeperFee);\\n    }\\n\\n    function _transferInsuranceFundFee(int256 insuranceFundFee) internal {\\n        if (insuranceFundFee > 0) {\\n            protocol.settlementToken.safeTransfer(address(insuranceFund), uint256(insuranceFundFee));\\n        } else {\\n            insuranceFund.claim(uint256(-insuranceFundFee));\\n        }\\n    }\\n\\n    function _updateCollateralSettings(IERC20 collateralToken, CollateralSettings memory collateralSettings) internal {\\n        uint32 collateralId = collateralToken.truncate();\\n\\n        // doesn't allow zero address as a collateral token\\n        if (collateralToken.isZero()) revert InvalidCollateralAddress(address(0));\\n\\n        // doesn't allow owner to change the cToken address when updating settings, once it's truncated previously\\n        if (\\n            !protocol.collaterals[collateralId].token.isZero() &&\\n            !protocol.collaterals[collateralId].token.eq(collateralToken)\\n        ) {\\n            revert IncorrectCollateralAddress(collateralToken, protocol.collaterals[collateralId].token);\\n        }\\n\\n        protocol.collaterals[collateralId] = Collateral(collateralToken, collateralSettings);\\n\\n        emit CollateralSettingsUpdated(collateralToken, collateralSettings);\\n    }\\n\\n    /**\\n        INTERNAL VIEW METHODS\\n     */\\n\\n    function _getAccountAndCheckOwner(uint256 accountId) internal view returns (Account.Info storage account) {\\n        account = accounts[accountId];\\n        if (msg.sender != account.owner) revert AccessDenied(msg.sender);\\n    }\\n\\n    function _checkCollateralIdAndGetInfo(uint32 collateralId, bool isWithdraw)\\n        internal\\n        view\\n        returns (Collateral storage collateral)\\n    {\\n        collateral = protocol.collaterals[collateralId];\\n        if (collateral.token.isZero()) revert CollateralDoesNotExist(collateralId);\\n        // do not check if it is a withdraw operation, so that users can withdraw even if collateral is banned\\n        if (!isWithdraw && !collateral.settings.isAllowedForDeposit) revert CollateralNotAllowedForUse(collateralId);\\n    }\\n\\n    function _checkPoolId(uint32 poolId) internal view {\\n        Pool storage pool = protocol.pools[poolId];\\n        if (pool.vToken.isZero()) revert PoolDoesNotExist(poolId);\\n        if (!pool.settings.isAllowedForTrade) revert PoolNotAllowedForTrade(poolId);\\n    }\\n\\n    function _checkSlippage(\\n        uint32 poolId,\\n        uint160 sqrtPriceToCheck,\\n        uint16 slippageToleranceBps\\n    ) internal view {\\n        uint160 sqrtPriceCurrent = protocol.getVirtualCurrentSqrtPriceX96(poolId);\\n        uint160 diff = sqrtPriceCurrent > sqrtPriceToCheck\\n            ? sqrtPriceCurrent - sqrtPriceToCheck\\n            : sqrtPriceToCheck - sqrtPriceCurrent;\\n        if (diff > (slippageToleranceBps * sqrtPriceToCheck) / 1e4) {\\n            revert SlippageBeyondTolerance();\\n        }\\n    }\\n\\n    /**\\n        PRIVATE METHODS\\n     */\\n\\n    function _forEachPoolOnPause(uint256 index) private {\\n        uint32 poolId = protocol.poolIds[index];\\n        // account for the funding payment upto this moment before pausing\\n        protocol.pools[poolId].vPoolWrapper.updateGlobalFundingState({ useZeroFundingRate: false });\\n    }\\n\\n    function _forEachPoolOnUnpause(uint256 index) private {\\n        uint32 poolId = protocol.poolIds[index];\\n        // record the funding payment as zero for the entire duration for which clearing house was paused.\\n        protocol.pools[poolId].vPoolWrapper.updateGlobalFundingState({ useZeroFundingRate: true });\\n    }\\n\\n    function _forEachPoolOnWithdrawProtocolFee(uint256 index) private {\\n        uint32 poolId = protocol.poolIds[index];\\n        uint256 feeCollected = protocol.pools[poolId].vPoolWrapper.collectAccruedProtocolFee();\\n        // if any protocol fee was collected then transfer to multisig\\n        if (feeCollected != 0) {\\n            protocol.settlementToken.safeTransfer(teamMultisig(), feeCollected);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x34083721231a6fd559eb0fc77c6bdf8e6c83bd4a5798cceb3c784b7aa6f2a004\",\"license\":\"BUSL-1.1\"},\"contracts/protocol/clearinghouse/ClearingHouseStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.14;\\n\\nimport { Account } from '../../libraries/Account.sol';\\nimport { BatchedLoop } from '../../libraries/BatchedLoop.sol';\\nimport { Protocol } from '../../libraries/Protocol.sol';\\n\\nimport { IInsuranceFund } from '../../interfaces/IInsuranceFund.sol';\\nimport { IOracle } from '../../interfaces/IOracle.sol';\\n\\nabstract contract ClearingHouseStorage {\\n    // rest slots reserved for any states from inheritance in future\\n    uint256[100] private _emptySlots1;\\n\\n    // at slot # 100\\n    Protocol.Info internal protocol;\\n\\n    uint256 public numAccounts;\\n    mapping(uint256 => Account.Info) accounts;\\n\\n    address public rageTradeFactoryAddress;\\n    IInsuranceFund public insuranceFund;\\n\\n    // progress index, used for performing for loop\\n    // over an unbounded array in multiple txs\\n    BatchedLoop.Info internal pauseLoop;\\n    BatchedLoop.Info internal unpauseLoop;\\n    BatchedLoop.Info internal withdrawProtocolFeeLoop;\\n\\n    // reserved for adding slots in future\\n    uint256[100] private _emptySlots2;\\n}\\n\",\"keccak256\":\"0x30e24a3572f24a033cc9ed78865bd8406191ddfbb70cc20019b68503c4d1a624\",\"license\":\"BUSL-1.1\"},\"contracts/protocol/clearinghouse/ClearingHouseView.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.14;\\n\\nimport { IClearingHouse } from '../../interfaces/IClearingHouse.sol';\\nimport { IClearingHouseView } from '../../interfaces/clearinghouse/IClearingHouseView.sol';\\n\\nimport { Account } from '../../libraries/Account.sol';\\nimport { Protocol } from '../../libraries/Protocol.sol';\\n\\nimport { ClearingHouseStorage } from './ClearingHouseStorage.sol';\\n\\nimport { Extsload } from '../../utils/Extsload.sol';\\n\\nabstract contract ClearingHouseView is IClearingHouse, ClearingHouseStorage, Extsload {\\n    using Account for Account.Info;\\n    using Protocol for Protocol.Info;\\n\\n    /// @inheritdoc IClearingHouseView\\n    function getAccountMarketValueAndRequiredMargin(uint256 accountId, bool isInitialMargin)\\n        public\\n        view\\n        returns (int256 marketValue, int256 requiredMargin)\\n    {\\n        (marketValue, requiredMargin) = accounts[accountId].getAccountValueAndRequiredMargin(isInitialMargin, protocol);\\n    }\\n\\n    /// @inheritdoc IClearingHouseView\\n    function getAccountNetProfit(uint256 accountId) public view returns (int256 accountNetProfit) {\\n        accountNetProfit = accounts[accountId].getAccountPositionProfits(protocol);\\n    }\\n\\n    /// @inheritdoc IClearingHouseView\\n    function getAccountNetTokenPosition(uint256 accountId, uint32 poolId) public view returns (int256 netPosition) {\\n        return accounts[accountId].getNetPosition(poolId, protocol);\\n    }\\n\\n    /// @inheritdoc IClearingHouseView\\n    function getRealTwapPriceX128(uint32 poolId) public view returns (uint256 realPriceX128) {\\n        realPriceX128 = protocol.getCachedRealTwapPriceX128(poolId);\\n    }\\n\\n    /// @inheritdoc IClearingHouseView\\n    function getVirtualTwapPriceX128(uint32 poolId) public view returns (uint256 virtualPriceX128) {\\n        virtualPriceX128 = protocol.getCachedVirtualTwapPriceX128(poolId);\\n    }\\n}\\n\",\"keccak256\":\"0xbec5c93cfdf81646e4539224af0b4cb4922ab3d2e6e2523534903fd2fa6dbc11\",\"license\":\"BUSL-1.1\"},\"contracts/utils/Extsload.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport { IExtsload } from '../interfaces/IExtsload.sol';\\n\\n/// @notice Allows the inheriting contract make it's state accessable to other contracts\\n/// https://ethereum-magicians.org/t/extsload-opcode-proposal/2410/11\\nabstract contract Extsload is IExtsload {\\n    function extsload(bytes32 slot) external view returns (bytes32 val) {\\n        assembly {\\n            val := sload(slot)\\n        }\\n    }\\n\\n    function extsload(bytes32[] memory slots) external view returns (bytes32[] memory) {\\n        assembly {\\n            let end := add(0x20, add(slots, mul(mload(slots), 0x20)))\\n            for {\\n                let pointer := add(slots, 32)\\n            } lt(pointer, end) {\\n\\n            } {\\n                let value := sload(mload(pointer))\\n                mstore(pointer, value)\\n                pointer := add(pointer, 0x20)\\n            }\\n        }\\n\\n        return slots;\\n    }\\n}\\n\",\"keccak256\":\"0xb74368b2d34810fd8f3586adfc2884fde340a89eba265456b284278ede44eed1\",\"license\":\"MIT\"},\"contracts/utils/Governable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport { ContextUpgradeable } from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\\nimport { Initializable } from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\n\\nimport { IGovernable } from '../interfaces/IGovernable.sol';\\n\\n/// @title Governable module that exposes onlyGovernance and onlyGovernanceOrTeamMultisig modifiers\\n/// @notice Copied and modified from @openzeppelin/contracts/access/Ownable.sol\\nabstract contract Governable is IGovernable, Initializable, ContextUpgradeable {\\n    address private _governance;\\n    address private _teamMultisig;\\n    address private _governancePending;\\n    address private _teamMultisigPending;\\n\\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\\n    event TeamMultisigTransferred(address indexed previousTeamMultisig, address indexed newTeamMultisig);\\n    event GovernancePending(address indexed previousGovernancePending, address indexed newGovernancePending);\\n    event TeamMultisigPending(address indexed previousTeamMultisigPending, address indexed newTeamMultisigPending);\\n\\n    error Unauthorised();\\n    error ZeroAddress();\\n\\n    /// @notice Initializes the contract setting the deployer as the initial governance and team multisig.\\n    constructor() {\\n        __Governable_init();\\n    }\\n\\n    /// @notice Useful to proxy contracts for initializing\\n    function __Governable_init() internal initializer {\\n        __Context_init();\\n        address msgSender = _msgSender();\\n        __Governable_init(msgSender, msgSender);\\n    }\\n\\n    /// @notice Useful to proxy contracts for initializing with custom addresses\\n    /// @param initialGovernance the initial governance address\\n    /// @param initialTeamMultisig  the initial teamMultisig address\\n    function __Governable_init(address initialGovernance, address initialTeamMultisig) internal initializer {\\n        _governance = initialGovernance;\\n        emit GovernanceTransferred(address(0), initialGovernance);\\n\\n        _teamMultisig = initialTeamMultisig;\\n        emit TeamMultisigTransferred(address(0), initialTeamMultisig);\\n    }\\n\\n    /// @notice Returns the address of the current governance.\\n\\n    function governance() public view virtual returns (address) {\\n        return _governance;\\n    }\\n\\n    /// @notice Returns the address of the current governance.\\n    function governancePending() public view virtual returns (address) {\\n        return _governancePending;\\n    }\\n\\n    /// @notice Returns the address of the current team multisig.transferTeamMultisig\\n    function teamMultisig() public view virtual returns (address) {\\n        return _teamMultisig;\\n    }\\n\\n    /// @notice Returns the address of the current team multisig.transferTeamMultisig\\n    function teamMultisigPending() public view virtual returns (address) {\\n        return _teamMultisigPending;\\n    }\\n\\n    /// @notice Throws if called by any account other than the governance.\\n    modifier onlyGovernance() {\\n        if (governance() != _msgSender()) revert Unauthorised();\\n        _;\\n    }\\n\\n    /// @notice Throws if called by any account other than the governance or team multisig.\\n    modifier onlyGovernanceOrTeamMultisig() {\\n        if (teamMultisig() != _msgSender() && governance() != _msgSender()) revert Unauthorised();\\n        _;\\n    }\\n\\n    /// @notice Initiates governance transfer to a new account (`newGovernancePending`).\\n    /// @param newGovernancePending the new governance address\\n    function initiateGovernanceTransfer(address newGovernancePending) external virtual onlyGovernance {\\n        emit GovernancePending(_governancePending, newGovernancePending);\\n        _governancePending = newGovernancePending;\\n    }\\n\\n    /// @notice Completes governance transfer, on being called by _governancePending.\\n    function acceptGovernanceTransfer() external virtual {\\n        if (_msgSender() != _governancePending) revert Unauthorised();\\n\\n        emit GovernanceTransferred(_governance, _governancePending);\\n        _governance = _governancePending;\\n        _governancePending = address(0);\\n    }\\n\\n    /// @notice Initiates teamMultisig transfer to a new account (`newTeamMultisigPending`).\\n    /// @param newTeamMultisigPending the new team multisig address\\n    function initiateTeamMultisigTransfer(address newTeamMultisigPending) external virtual onlyGovernance {\\n        emit TeamMultisigPending(_teamMultisigPending, newTeamMultisigPending);\\n        _teamMultisigPending = newTeamMultisigPending;\\n    }\\n\\n    /// @notice Completes teamMultisig transfer, on being called by _teamMultisigPending.\\n    function acceptTeamMultisigTransfer() external virtual {\\n        if (_msgSender() != _teamMultisigPending) revert Unauthorised();\\n\\n        emit TeamMultisigTransferred(_teamMultisig, _teamMultisigPending);\\n        _teamMultisig = _teamMultisigPending;\\n        _teamMultisigPending = address(0);\\n    }\\n}\\n\",\"keccak256\":\"0x0f117f453fc3f3f47eeb7dccdf61204ced4674194ad901aef168cfe09c8ff6a1\",\"license\":\"MIT\"},\"contracts/utils/Multicall.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport { IMulticall } from '@uniswap/v3-periphery/contracts/interfaces/IMulticall.sol';\\n\\n/// @title Multicall\\n/// @notice Enables calling multiple methods in a single call to the contract\\nabstract contract Multicall is IMulticall {\\n    /// @inheritdoc IMulticall\\n    function multicall(bytes[] calldata data) public payable override returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd44030ded009dd01cd697c036595249f3c49355ceb8d37eaa2ea546eb7375f7b\",\"license\":\"GPL-2.0-or-later\"}},\"version\":1}",
  "bytecode": "0x6080604052346200011b5761013d805460ff8160081c1690816000146200010c57506200002e303b1562000120565b159081620000f6575b5460ff8160081c1680156200009d57156200008e57506200005a303b1562000120565b62000066333362000184565b6200007c575b604051615f6f9081620002098239f35b61013d805461ff00191690556200006c565b60ff6200005a91161562000120565b60405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608490fd5b61013d805461ffff191661010117905562000037565b60ff6200002e91161562000120565b600080fd5b156200012857565b60405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608490fd5b6101a280546001600160a01b039283166001600160a01b0319918216811790925560405190936000937f39355f2f5c8206286978f443aa8126bbd29fa09c53c04569502647f3a59c8cb29385939290847f5f56bee8cffbe9a78652a74a60705edede02af10b0bbb888ca44b79a0d42ce808186a31694856101a391825416179055a356fe60806040526004361015610013575b600080fd5b60003560e01c806304a6f2641461031f5780630df181ea14610316578063134015511461030d578063136439dd146103045780631e2eaeaf146102fb5780632a90b8da146102f25780633562490c146102e957806335876476146102e05780633d0aea3d146102d75780633d56a35e146102ce5780633ffe794c146102c557806340c4f69b146102bc578063424cd833146102b357806343afafba146102aa578063569634d3146102a15780635aa6e675146102985780635c975abb1461028f5780636a486482146102865780636ae732301461027d578063706bdd25146102745780637cc2f4f51461026b5780637d2efe071461026257806383d778eb146102595780638ce25a93146102505780638f24ab11146102475780638f8022bc1461023e5780639cd1be58146102355780639dca362f1461022c578063a05c8baf14610223578063ac9650d81461021a578063b790230314610211578063c7505c1514610208578063ce4c18de146101ff578063dbc0c085146101f6578063dbd035ff146101ed578063e3d41c18146101e4578063e450f6f4146101db578063e67ed1df146101d25763fabc1cbc146101ca57600080fd5b61000e6126be565b5061000e6125e5565b5061000e612477565b5061000e6123e3565b5061000e61234c565b5061000e6122c1565b5061000e612299565b5061000e6120ff565b5061000e6120d7565b5061000e611ff6565b5061000e611d76565b5061000e611d18565b5061000e611be1565b5061000e611b5b565b5061000e611954565b5061000e611935565b5061000e6116e9565b5061000e6114f3565b5061000e61149a565b5061000e61145c565b5061000e6113be565b5061000e6112e5565b5061000e6112c0565b5061000e611297565b5061000e611269565b5061000e611221565b5061000e611096565b5061000e610b82565b5061000e610978565b5061000e610950565b5061000e6108a4565b5061000e6106a7565b5061000e6105ee565b5061000e61056e565b5061000e61054e565b5061000e61044a565b5061000e610421565b5061000e61035c565b5061000e610333565b600091031261000e57565b503461000e57600060031936011261000e5760206001600160a01b036101a55416604051908152f35b503461000e576000602060031936011261041e5761038060ff6101705416156133e7565b61038b600435615af4565b61039481613b1a565b817361Fea7b93D977D31EF80747666F18864824E6da891823b1561041a576044604051809481937feaf393260000000000000000000000000000000000000000000000000000000083526004830152606460248301525af4801561040d575b6103fe575b50604051f35b610407906107a7565b386103f8565b61041561377f565b6103f3565b5080fd5b80fd5b503461000e57600060031936011261000e5760206001600160a01b036101a45416604051908152f35b503461000e57602060031936011261000e576001600160a01b03806101a35416331415908161053e575b506105145761017061048a60ff825416156133e7565b60d7546104ea5761049f60043560665461345a565b6104a6575b005b600160ff1982546104ba60ff8216156133e7565b161790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b60046040517fd2067f43000000000000000000000000000000000000000000000000000000008152fd5b60046040517fd7a2ae6a000000000000000000000000000000000000000000000000000000008152fd5b6101a25416331415905038610474565b503461000e57602060031936011261000e57602060043554604051908152f35b503461000e57600060031936011261000e576101a48054906001600160a01b0390818316803303610514576000936101a2805492806040519685167f5f56bee8cffbe9a78652a74a60705edede02af10b0bbb888ca44b79a0d42ce808989a373ffffffffffffffffffffffffffffffffffffffff19809416179055169055f35b503461000e57600060031936011261000e576101a58054906001600160a01b0390818316803303610514576000936101a3805492806040519685167f39355f2f5c8206286978f443aa8126bbd29fa09c53c04569502647f3a59c8cb28989a373ffffffffffffffffffffffffffffffffffffffff19809416179055169055f35b6001600160a01b0381160361000e57565b610124359061068d8261066e565b565b60e4359061068d8261066e565b359061068d8261066e565b503461000e5760e060031936011261000e576004356106c58161066e565b61073f6024356106d48161066e565b6044356106e08161066e565b6064356106ec8161066e565b608435906106f98261066e565b60a435926107068461066e565b60c435946107138661066e565b61013d5460ff8160081c1690816000146107835750610733303b15612792565b15978861075657612803565b61074557005b6104a461013d61ff00198154169055565b61076b61013d61010061ff0019825416179055565b61077e61013d600160ff19825416179055565b612803565b60ff610733911615612792565b50634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff81116107bb57604052565b6107c3610790565b604052565b60a0810190811067ffffffffffffffff8211176107bb57604052565b6040810190811067ffffffffffffffff8211176107bb57604052565b6060810190811067ffffffffffffffff8211176107bb57604052565b90601f601f19910116810190811067ffffffffffffffff8211176107bb57604052565b6040519061068d826107e4565b63ffffffff81160361000e57565b8015150361000e57565b60e4359061068d8261085a565b610104359061068d8261085a565b60a4359061068d8261085a565b60c4359061068d8261085a565b359061068d8261085a565b503461000e57608060031936011261000e576004356108c28161066e565b60607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc36011261000e576040516104a4916060820167ffffffffffffffff811183821017610943575b60405260243561091a8161066e565b82526044356109288161084c565b60208301526064356109398161085a565b6040830152612fd6565b61094b610790565b61090b565b503461000e57600060031936011261000e5760206001600160a01b0360d45416604051908152f35b503461000e5761014060031936011261000e576001600160a01b038060d454163303610a4d576109d163ffffffff6004356109b28161066e565b1691826000526064602052604060002054166001600160a01b03161590565b15610a3757610a3281610a1d610a187f4182acc9c169391ef7e765eb446fc15c9d49bc73060c678bf4c424a5c0dbdbcb9463ffffffff166000526064602052604060002090565b612c43565b610a2681612e15565b60405191829182612eae565b0390a1005b634e487b7160e01b600052600160045260246000fd5b60046040517f85734f31000000000000000000000000000000000000000000000000000000008152fd5b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020808501948460051b01011161000e57565b918091926000905b828210610ac8575011610ac1575050565b6000910152565b91508060209183015181860152018291610ab0565b90601f19601f602093610afb81518092818752878088019101610aa8565b0116010190565b602080820190808352835180925260408301928160408460051b8301019501936000915b848310610b365750505050505090565b9091929394958480610b72837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc086600196030187528a51610add565b9801930193019194939290610b26565b503461000e5760408060031936011261000e57600480359160243567ffffffffffffffff811161000e57610bb99036908401610a77565b610bc581949294613864565b93610bda8660005260d3602052604060002090565b95610be487613b1a565b60008781938295835b818110610d5f5750505050610d4f575b50610cb8575b610c19575b815180610c158582610b02565b0390f35b7361Fea7b93D977D31EF80747666F18864824E6da890813b1561000e5782517f998c53350000000000000000000000000000000000000000000000000000000081529081019485526001602086015260646040860152610c159490916000918391908290819060600103915af48015610cab575b15610c085780610c9f610ca5926107a7565b80610328565b38610c08565b610cb361377f565b610c8d565b7361Fea7b93D977D31EF80747666F18864824E6da8803b1561000e576000845180927f651524ed0000000000000000000000000000000000000000000000000000000082528180610d198b8983016020606491939293604081019481520152565b03915af48015610d42575b610d2f575b50610c03565b80610c9f610d3c926107a7565b38610d29565b610d4a61377f565b610d24565b610d5890615af4565b5038610bfd565b9091929693610d77610d728385876138ad565b613924565b610d8081613912565b610dd8575080610dc0610daf610da7610d9d610dc59587896138ad565b602081019061394f565b810190613afb565b906001978015610dce575b9a614a4e565b61344a565b908a9291610bed565b5060008212610dba565b939650610de9610d728284866138ad565b93610df385613912565b6001948503610e425750610e16610e0e610d9d8385876138ad565b810190613aec565b93610e21858d614e39565b6000819512610e35575b50610dc59061344a565b9650869550610dc5610e2b565b6002610e55610d728486889c969c6138ad565b610e5e81613912565b03610edf575050610eb1610ebf610e768884866138ad565b610e9a8d610e94610e8c6020948581019061394f565b810190613a66565b9161514c565b8c5192830191825260208201529092839160400190565b03601f19810183528261081c565b610ec9878b6139ec565b52610ed4868a6139ec565b50610dc5839661344a565b6003610eef610d728a86886138ad565b610ef881613912565b03610f34575050610eb1610ebf610f108884866138ad565b610e9a8d610f2e610f266020948581019061394f565b810190613a41565b91614f20565b93509587610f46610d728385876138ad565b610f4f81613912565b03610f815780610f7b610f74610f6c610d9d610dc59587896138ad565b810190613a0e565b91896156b9565b5061344a565b6005610f91610d728385876138ad565b610f9a81613912565b03610fd05780610f7b610fcb610fc2610fba610d9d610dc596888a6138ad565b810190611444565b63ffffffff1690565b6153a3565b6006610fe0610d728385876138ad565b610fe981613912565b036110505780610ffd610dc59284866138ad565b61103b61102963ffffffff61102261101a6020958681019061394f565b8101906139a0565b9116615588565b8c519283019081528290602001610eb1565b611045828d6139ec565b52610f7b818c6139ec565b611063610d72611092928a948c966138ad565b92519283927f62c9ca420000000000000000000000000000000000000000000000000000000084528301613931565b0390fd5b503461000e5760208060031936011261000e5760665460d85460049283358215611218575b600090806111f55750508293915b8481106110e65750505081036110e15750600060d855005b60d855005b8060008361113e611132600261112463ffffffff61110661118799612dc7565b90549060031b1c1663ffffffff166000526064602052604060002090565b01546001600160a01b031690565b6001600160a01b031690565b86604051809481937f5e622abc0000000000000000000000000000000000000000000000000000000083525af19081156111e8575b6000916111bb575b508061118c575061344a565b6110c9565b6111b5906111a26067546001600160a01b031690565b6001600160a01b036101a3541690614b55565b38610f7b565b6111db9150843d86116111e1575b6111d3818361081c565b810190613edc565b3861117b565b503d6111c9565b6111f061377f565b611173565b6111ff9084613432565b905083811015611211575b93916110c9565b508261120a565b600092506110bb565b503461000e57604060031936011261000e5760206112616024356004356112478261084c565b8060005260d3845261125c6040600020613b1a565b615588565b604051908152f35b503461000e57602060031936011261000e576104a46004358060005260d3602052610fcb6040600020613b1a565b503461000e57600060031936011261000e5760206001600160a01b036101a25416604051908152f35b503461000e57600060031936011261000e57602060ff61017054166040519015158152f35b503461000e57604060031936011261000e57610c156024356113068161084c565b60043560005260d360205263ffffffff604060002091604051927f7188a1ed0000000000000000000000000000000000000000000000000000000084526004840152166024820152606460448201526020816064817361Fea7b93D977D31EF80747666F18864824E6da85af49081156113b1575b600091611393575b506040519081529081906020820190565b6113ab915060203d81116111e1576111d3818361081c565b38611382565b6113b961377f565b61137a565b503461000e57602060031936011261000e576004356113dc8161066e565b6001600160a01b03806101a254163303610514576000916101a59073ffffffffffffffffffffffffffffffffffffffff19838354921691826040519582167f9b068aae3039a2512c2f13bffb5fd9d95b1895b276b5c7ddf1d4fa24ec3686588888a316179055f35b9081602091031261000e57356114598161084c565b90565b503461000e57602060031936011261000e57602061126160043561147f8161084c565b615dd9565b8060020b0361000e57565b359061068d82611484565b503461000e57608060031936011261000e576104a46004356024356114be8161084c565b604435906114cb82611484565b606435926114d884611484565b8060005260d36020526114ee6040600020613b1a565b6156b9565b503461000e57606060031936011261000e576024356115118161084c565b6044356101709061152660ff835416156133e7565b611531600435615af4565b9161153b83613b1a565b60009361154f60ff868512935416156133e7565b8461155a8383615b3f565b947361Fea7b93D977D31EF80747666F18864824E6da8803b15611662576040517ff5a284a1000000000000000000000000000000000000000000000000000000008152600481019290925263ffffffff93909316602482015260448101859052606480820152831515608482015291829060a49082905af48015611655575b611642575b508382131561160a57506115fc61160592546001600160a01b031690565b30903390614bc7565b604051f35b611616575b5050604051f35b61163361162d61163b93546001600160a01b031690565b916144f2565b903390614b55565b388061160f565b80610c9f61164f926107a7565b386115de565b61165d61377f565b6115d9565b8280fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbc60a091011261000e576040519061169d826107c8565b8160443581526064356116af8161066e565b60208201526084356116c08161085a565b604082015260a4356116d18161085a565b6060820152608060c435916116e58361085a565b0152565b503461000e5760e060031936011261000e576024356117078161084c565b61171036611666565b809161017061172360ff825416156133e7565b61174560ff611733600435615af4565b9261173d84613b1a565b5416156133e7565b61174e82615bea565b6040918291611789835195869384937f140cf61e0000000000000000000000000000000000000000000000000000000085526004850161533c565b03817361Fea7b93D977D31EF80747666F18864824E6da85af4928315611928575b60009283946118f3575b506117be8461452d565b606c5481106118c157506001600160a01b036117e460208301516001600160a01b031690565b161515806118ab575b611804575b50519081526020810191909152604090f35b818101906118128251151590565b918261188f575b8215611856575b50501561182d57386117f2565b600490517f07a1db07000000000000000000000000000000000000000000000000000000008152fd5b5190915015611864565b1590565b9081611873575b503880611820565b90506118886118818461452d565b915161452d565b143861186b565b915061189a8561452d565b6118a4825161452d565b1491611819565b506118bc6118606060830151151590565b6117ed565b82517f256d6b9a0000000000000000000000000000000000000000000000000000000081526004810191909152602490fd5b909350816119179293503d8411611921575b61190f818361081c565b810190615326565b91909192386117b4565b503d611905565b61193061377f565b6117aa565b503461000e57600060031936011261000e57602060d254604051908152f35b503461000e5761010060031936011261000e5760048035906119758261084c565b60e07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc36011261000e576001600160a01b036101a254163303611b33576119d760036119d18463ffffffff166000526064602052604060002090565b01612a65565b6119f26119e5611132612a4c565b6001600160a01b03161590565b611b155763ffffffff61012c81611a07612a27565b1610908115611aff575b50611ae05761ffff6127108082611a266129f9565b1611611ac257611a3e611a37612a05565b61ffff1690565b11611aa4576107d090611a4f612a11565b1611611a85576040517f4182acc9c169391ef7e765eb446fc15c9d49bc73060c678bf4c424a5c0dbdbcb9080610a328582612f52565b604051636a098dd160e11b815260249181019182529081906020010390fd5b604051636a098dd160e11b8152602381840190815281906020010390fd5b604051636a098dd160e11b8152602281850190815281906020010390fd5b604051636a098dd160e11b815260219181019182529081906020010390fd5b620151809150611b0d612a27565b161138611a11565b604051636a098dd160e11b8152602091810182815290918291010390fd5b6040517fd7a2ae6a000000000000000000000000000000000000000000000000000000008152fd5b503461000e57602060031936011261000e57600435611b798161066e565b6001600160a01b03806101a254163303610514576000916101a49073ffffffffffffffffffffffffffffffffffffffff19838354921691826040519582167f8c405decc72a19ef328c92989ce6db4e4a498e1c246413fd60997a3051ba5cff8888a316179055f35b503461000e57604060031936011261000e57602435610170611c0760ff825416156133e7565b611c1760ff611733600435615af4565b8115611cee577361Fea7b93D977D31EF80747666F18864824E6da8803b1561000e576040517fd25c4a6f000000000000000000000000000000000000000000000000000000008152600481019290925260248201839052606460448301819052600190830152600090829060849082905af48015611ce1575b611cce575b506000811315611cb5576104a4906115fc6067546001600160a01b031690565b6104a49061163361162d6067546001600160a01b031690565b80610c9f611cdb926107a7565b38611c95565b611ce961377f565b611c90565b60046040517f1f2a2005000000000000000000000000000000000000000000000000000000008152fd5b503461000e57600060031936011261000e5760206112616136aa565b60031961010091011261000e57600490565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbc61010091011261000e57604490565b503461000e5761016060031936011261000e57611d9236611d34565b610104356101243591610144356001600160a01b036101a254163303610514576127109361ffff8581611dc486612a1d565b1611611fdd5785611dda611a3760208701612a1d565b11611fc45760409580611df1611a37898801612a1d565b11611fac5780611e06611a3760608801612a1d565b11611f9457611e1a611a3760808701612a1d565b11611f7c576103e890611e2f60a08601612a1d565b1611611f6457633b9aca008067ffffffffffffffff611e5060c0870161308e565b1611611f4c5780611e73611e6660e0870161308e565b67ffffffffffffffff1690565b11611f3457808511611f1c57808211611f04578211611eec5791611ee660009594927f697aec6e94e319190380ab0f1f10018d81b64da2479eb874be92c9a733e0a83794611ec084613098565b611ec985606b55565b611ed281606c55565b611edb82606a55565b8651948594856132fb565b0390a151f35b8451636a098dd160e11b8152603a6004820152602490fd5b8551636a098dd160e11b815260396004820152602490fd5b8551636a098dd160e11b815260386004820152602490fd5b8551636a098dd160e11b815260376004820152602490fd5b8551636a098dd160e11b815260366004820152602490fd5b8451636a098dd160e11b815260356004820152602490fd5b8551636a098dd160e11b815260346004820152602490fd5b8651636a098dd160e11b815260336004820152602490fd5b8651636a098dd160e11b815260326004820152602490fd5b604051636a098dd160e11b815260316004820152602490fd5b604051636a098dd160e11b815260306004820152602490fd5b50602060031936011261000e576004803567ffffffffffffffff811161000e576120239036908301610a77565b9061202d82613864565b9160005b8181106120465760405180610c158682610b02565b600080612054838587615ea2565b60409391612066855180938193615ecc565b0390305af490612074614db8565b9182901561209d575050906120989161208d82876139ec565b52610f7b81866139ec565b612031565b826044899394511061000e5761109291836120c2920160248091518301019101615eda565b925192839262461bcd60e51b84528301614de8565b503461000e57600060031936011261000e5760206001600160a01b0360d55416604051908152f35b503461000e5761014060031936011261000e5760243561211e8161084c565b606061212936611d46565b916101709261213c60ff855416156133e7565b61216960ff61216061214f600435615af4565b9361215985613b1a565b36906137a7565b955416156133e7565b61217282615bea565b828401516001600160a01b031680612279575b506121bd60405194859384937fc27789d10000000000000000000000000000000000000000000000000000000085526004850161503a565b03817361Fea7b93D977D31EF80747666F18864824E6da85af4801561226c575b60009081928291612238575b50606c5481106122055750604080519182526020820192909252f35b6040517f256d6b9a0000000000000000000000000000000000000000000000000000000081526004810191909152602490fd5b91505061225c915060603d8111612265575b612254818361081c565b810190615012565b919091386121e9565b503d61224a565b61227461377f565b6121dd565b6122939061228c608087015161ffff1690565b9084615cc7565b38612185565b503461000e57602060031936011261000e5760206112616004356122bc8161084c565b615e37565b503461000e57600060031936011261000e5760206001600160a01b036101a35416604051908152f35b60209067ffffffffffffffff8111612304575b60051b0190565b61230c610790565b6122fd565b6020908160408183019282815285518094520193019160005b828110612338575050505090565b83518552938101939281019260010161232a565b503461000e5760208060031936011261000e5760043567ffffffffffffffff811161000e573660238201121561000e5780600401359061238b826122ea565b91612399604051938461081c565b80835260248484019160051b8301019136831161000e57602401905b8282106123d457610c156123c885615e79565b60405191829182612311565b813581529084019084016123b5565b503461000e57602060031936011261000e5760043560005260d3602052610c156040600020604051907fc4b22b860000000000000000000000000000000000000000000000000000000082526004820152606460248201526020816044817361Fea7b93D977D31EF80747666F18864824E6da85af49081156113b15760009161139357506040519081529081906020820190565b503461000e57604060031936011261000e576004356124958161084c565b602435906124a16136aa565b90610170926124b460ff855416156133e7565b6124bd83615af4565b936124c785613b1a565b6124d960ff60008412925416156133e7565b6124e38184615b3f565b927361Fea7b93D977D31EF80747666F18864824E6da890813b1561000e576040517ff5a284a1000000000000000000000000000000000000000000000000000000008152600481019790975263ffffffff166024870152604486018390526064808701528115156084870152610c159590600090829060a49082905af480156125d8575b6125c5575b50600082131561259b57506115fc61258b92546001600160a01b031690565b6040519081529081906020820190565b6125a7575b505061258b565b61163361162d6125be93546001600160a01b031690565b38806125a0565b80610c9f6125d2926107a7565b3861256c565b6125e061377f565b612567565b503461000e5760408060031936011261000e576024356126048161085a565b60043560005260d360205281600020908251917f0c6d7f340000000000000000000000000000000000000000000000000000000083526004830152151560248201526064604482015281816064817361Fea7b93D977D31EF80747666F18864824E6da85af49182156126b1575b600091829361268c5750519081526020810191909152604090f35b816126a9929450610c1593503d85116119215761190f818361081c565b9290916117f2565b6126b961377f565b612671565b503461000e57602060031936011261000e576001600160a01b03806101a354163314159081612782575b50610514576101706126fd60ff82541661365f565b60d65461275857612712600435606654613574565b61271857005b60ff19815461272960ff821661365f565b1690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b60046040517ffc23b9cd000000000000000000000000000000000000000000000000000000008152fd5b6101a254163314159050386126e8565b1561279957565b608460405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152fd5b93916128a27f39355f2f5c8206286978f443aa8126bbd29fa09c53c04569502647f3a59c8cb2936000958694986001600160a01b039a8b80928173ffffffffffffffffffffffffffffffffffffffff199c168c60d454161760d4558185168c6067541617606755168a60d554161760d55516886068541617606855896040519261288c84610800565b168252603c60208301526001604083015261592c565b61013d9680885460ff8160081c169081861461295a57506128c4303b15612792565b15978861292d575b16916101a2838882541617905560405192847f5f56bee8cffbe9a78652a74a60705edede02af10b0bbb888ca44b79a0d42ce808186a31694856101a391825416179055a361291e575b5061068d612967565b61ff0019815416905538612915565b61294261013d61010061ff0019825416179055565b61295561013d600160ff19825416179055565b6128cc565b60ff6128c4911615612792565b60ff61013d5460081c16156129835761017060ff198154169055565b608460405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152fd5b61ffff81160361000e57565b602435611459816129ed565b604435611459816129ed565b606435611459816129ed565b35611459816129ed565b6084356114598161084c565b60e4356114598161085a565b610104356114598161085a565b60e4356114598161066e565b610124356114598161066e565b61068d90612aa7602435612a78816129ed565b829061ffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000825416179055565b612aeb604435612ab6816129ed565b82547fffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff1660109190911b63ffff000016178255565b612b31606435612afa816129ed565b82547fffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff1660209190911b65ffff0000000016178255565b608435612b3d8161084c565b7fffffffffffffffffffffffffffffffffffffffffffff00000000ffffffffffff69ffffffff00000000000083549260301b169116178155612bc060a435612b848161085a565b82547fffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff1690151560501b6aff0000000000000000000016178255565b612c0c60c435612bcf8161085a565b82547fffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff1690151560581b6bff000000000000000000000016178255565b60e43590612c198261066e565b906bffffffffffffffffffffffff6bffffffffffffffffffffffff1983549260601b169116179055565b600361068d91612c81600435612c588161066e565b82906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b612cbc602435612c908161066e565b60018301906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b612cf7604435612ccb8161066e565b60028301906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b01612d07606435612a78816129ed565b612d16608435612ab6816129ed565b612d2560a435612afa816129ed565b60c435612d318161084c565b7fffffffffffffffffffffffffffffffffffffffffffff00000000ffffffffffff69ffffffff00000000000083549260301b169116178155612d74612b84612a33565b612d7f612bcf612a3f565b612d87612a58565b6bffffffffffffffffffffffff6bffffffffffffffffffffffff1983549260601b169116179055565b50634e487b7160e01b600052603260045260246000fd5b90606654821015612e08575b6066600052601c8260031c7f46501879b8ca8525e8c2fd519e2fbfcfa2ebea26501294aa02cbfcfb12e94354019260021b1690565b612e10612db0565b612dd3565b6066549068010000000000000000821015612e96575b6001820180606655821015612e89575b60666000528160031c7f46501879b8ca8525e8c2fd519e2fbfcfa2ebea26501294aa02cbfcfb12e94354019160e083549160051b169163ffffffff9283811b93849216901b16911916179055565b612e91612db0565b612e3b565b612e9e610790565b612e2b565b359061068d826129ed565b63ffffffff91821681526101008101929161068d9190606435612ed0816129ed565b61ffff809116602084015280608435612ee8816129ed565b16604084015260a435612efa816129ed565b16606083015260c435612f0c8161084c565b166080820152612f26612f1d610864565b151560a0830152565b612f3a612f31610871565b151560c0830152565b60e0612f4461067f565b6001600160a01b0316910152565b63ffffffff91821681526101008101929161068d9190602435612f74816129ed565b61ffff809116602084015280604435612f8c816129ed565b166040840152606435612f9e816129ed565b166060830152608435612fb08161084c565b166080820152612fc1612f1d61087f565b612fcc612f3161088c565b60e0612f4461068f565b906001600160a01b03806101a2541633036105145781511615613035576201518063ffffffff61300d602084015163ffffffff1690565b161161301c5761068d9161592c565b604051636a098dd160e11b815260116004820152602490fd5b604051636a098dd160e11b815260106004820152602490fd5b50634e487b7160e01b600052601160045260246000fd5b50634e487b7160e01b600052601260045260246000fd5b67ffffffffffffffff81160361000e57565b356114598161307c565b6132a260e061068d9261ffff81356130af816129ed565b167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000606954161760695561312060208201356130ea816129ed565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff63ffff00006069549260101b16911617606955565b6131696040820135613131816129ed565b7fffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff65ffff000000006069549260201b16911617606955565b6060810135613177816129ed565b7fffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffff67ffff0000000000006069549260301b169116176069556131fa6131be60808301612a1d565b7fffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffff69ffff00000000000000006069549260401b16911617606955565b61324761320960a08301612a1d565b7fffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffffff6bffff000000000000000000006069549260501b16911617606955565b61329c61325660c0830161308e565b7fffffffffffffffffffffffff0000000000000000ffffffffffffffffffffffff73ffffffffffffffff0000000000000000000000006069549260601b16911617606955565b0161308e565b7fffffffff0000000000000000ffffffffffffffffffffffffffffffffffffffff7bffffffffffffffff00000000000000000000000000000000000000006069549260a01b16911617606955565b359061068d8261307c565b90949392610140926133d76133c660e0610160860199803561331c816129ed565b61ffff80911688526020820135613332816129ed565b16602088015261335261334760408301612ea3565b61ffff166040890152565b61336c61336160608301612ea3565b61ffff166060890152565b61338661337b60808301612ea3565b61ffff166080890152565b6133a061339560a08301612ea3565b61ffff1660a0890152565b6133c06133af60c083016132f0565b67ffffffffffffffff1660c0890152565b016132f0565b67ffffffffffffffff1660e0850152565b6101008301526101208201520152565b156133ee57565b606460405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152fd5b8119811161343e570190565b61344661304e565b0190565b600190600019811461343e570190565b60d6549291831561356b575b6000908061354957505080925b8381106134915750821491821561348c5750600060d655565b60d655565b63ffffffff61349f82612dc7565b90549060031b1c1660005260646020526040906134cd611132600284600020016001600160a01b0390541690565b803b1561000e57600061352a935180927f5124033600000000000000000000000000000000000000000000000000000000825281838161351560048201906000602083019252565b03925af1801561353c575b61352f575061344a565b613473565b80610c9f6111b5926107a7565b61354461377f565b613520565b6135539085613432565b905081811015613564575b92613473565b508061355e565b60009350613466565b60d75492918315613656575b6000908061363457505080925b8381106135ab575082149182156135a65750600060d755565b60d755565b63ffffffff6135b982612dc7565b90549060031b1c1660005260646020526040906001600160a01b03600283600020015416803b1561000e5760008091602461362f9551809481937f51240336000000000000000000000000000000000000000000000000000000008352600160048401525af1801561353c5761352f575061344a565b61358d565b61363e9085613432565b90508181101561364f575b9261358d565b5080613649565b60009350613580565b1561366657565b606460405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152fd5b6136ba60ff6101705416156133e7565b60d2547ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe8111613772575b6001810160d255600081815260d36020526040902080546bffffffffffffffffffffffff163360601b6bffffffffffffffffffffffff19161781556bffffffffffffffffffffffff82166bffffffffffffffffffffffff198254161790556040518181527f7325fb14450d3e5eb288c620b4ff1d6b43a41b33b4a4f143ae88cd4c12f99ea360203392a290565b61377a61304e565b6136e5565b506040513d6000823e3d90fd5b359081600f0b820361000e57565b3590600382101561000e57565b809291610100918291031261000e5760405190810181811067ffffffffffffffff821117613857575b60405260e06138528183956137e48161148f565b85526137f26020820161148f565b60208601526138036040820161378c565b60408601526138146060820161069c565b606086015261382560808201612ea3565b608086015261383660a08201610899565b60a086015261384760c0820161379a565b60c086015201610899565b910152565b61385f610790565b6137d0565b9061386e826122ea565b61387b604051918261081c565b828152601f1961388b82946122ea565b019060005b82811061389c57505050565b806060602080938501015201613890565b91908110156138ee575b60051b810135907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc18136030182121561000e570190565b6138f6612db0565b6138b7565b50634e487b7160e01b600052602160045260246000fd5b6007111561391c57565b61068d6138fb565b35600781101561000e5790565b9190602083019260078210156139445752565b61394c6138fb565b52565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18136030182121561000e570180359067ffffffffffffffff821161000e5760200191813603831361000e57565b919082604091031261000e57602082356139b98161084c565b9201356114598161084c565b6020908051156139d3570190565b613446612db0565b6040908051600110156139d3570190565b6020918151811015613a01575b60051b010190565b613a09612db0565b6139f9565b9081606091031261000e578035613a248161084c565b9160406020830135613a3581611484565b92013561145981611484565b91906101208382031261000e576114599060208435613a5f8161084c565b94016137a7565b809291039160c0831261000e5760a0601f198235613a838161084c565b94011261000e5760a060405191613a99836107c8565b602081013583526040810135613aae8161066e565b60208401526060810135613ac18161085a565b60408401526080810135613ad48161085a565b60608401520135613ae48161085a565b608082015290565b9081602091031261000e573590565b919082604091031261000e5760208235613b148161084c565b92013590565b60005b60088060ff83161015613b7c57811015613b81575b63ffffffff60018260031c8401015460e08360051b161c16908115613b7c57613b5c600192613c06565b60ff809116908114613b6f575b01613b1d565b613b7761304e565b613b69565b505050565b613b89612db0565b613b32565b60008212827f8000000000000000000000000000000000000000000000000000000000000000018212811516613bf9575b827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01821316613bed570390565b613bf561304e565b0390565b613c0161304e565b613bbf565b613c0e613eeb565b613c288263ffffffff16600052606d602052604060002090565b805463ffffffff838116911614613b7c57613c42836143ed565b613c53613c4e8561400c565b613f97565b937c010000000000000000000000000000000000000000000000000000000080831090811591613e1f575b50613e185761068d94613d33613d38613db994613cbf6003613cb3613d849763ffffffff166000526064602052604060002090565b015460201c61ffff1690565b613cdf61ffff613cd7613cd28886613b8e565b61452d565b921683613e2a565b1015613de957613d33600188017c01000000000000000000000000000000000000000000000000000000007fffffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffff825416179055565b61447c565b60018601907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000825416179055565b825463ffffffff1660209190911b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000016178255565b9063ffffffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000825416179055565b613d33600188017fffffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffff8154169055565b5050505050565b905085101538613c7e565b9060001981830981830291828083109203918083039214613e8757612710908282111561000e577fbc01a36e2eb1c432ca57a786c226809d495182a9930be0ded288ce703afb7e91940990828211900360fc1b910360041c170290565b505061271091500490565b6000198282099082810292838084109303928084039314613ed35768010000000000000000918383111561000e570990828211900360c01b910360401c1790565b50505060401c90565b9081602091031261000e575190565b61a4b146148015613f8b575b8015613f7f575b15613f755763ffffffff6040517fa3b1b31d00000000000000000000000000000000000000000000000000000000815260208160048160645afa908115613f68575b600091613f4c57501690565b613f64915060203d81116111e1576111d3818361081c565b1690565b613f7061377f565b613f40565b63ffffffff431690565b5062066eec4614613efe565b5062066eeb4614613ef7565b6001600160a01b03166401000276a381108015613fee575b613fbd578061145991613e92565b602490604051907f5d236c450000000000000000000000000000000000000000000000000000000082526004820152fd5b5073fffd8963efd1fc6a506488495d951d5263988d26811015613faf565b6140269063ffffffff166000526064602052604060002090565b60036140506001600160a01b0392836001820154169063ffffffff938491015460301c1690614836565b60020b9060008212156143e75781600003915b620d89e883116143bd5760018316156143945770ffffffffffffffffffffffffffffffffff6ffffcb933bd6fad37aa2d162d1a5940015b169260028116614378575b6004811661435c575b60088116614340575b60108116614324575b60208116614308575b604081166142ec575b6080908181166142d1575b61010081166142b6575b610200811661429b575b6104008116614280575b6108008116614265575b611000811661424a575b612000811661422f575b6140008116614214575b61800081166141f9575b6201000081166141de575b6202000081166141c4575b6204000081166141aa575b620800001661418f575b5060001261417f575b81166141765760ff60005b169060201c011690565b60ff600161416c565b9061418990614542565b90614161565b6b048a170391f7dc42444e8fa26000929402901c9290614158565b6d2216e584f5fa1ea926041bedfe98909402811c9361414e565b936e5d6af8dedb81196699c329225ee60402811c93614143565b936f09aa508b5b7a84e1c677de54f3e99bc902811c93614138565b936f31be135f97d08fd981231505542fcfa602811c9361412d565b936f70d869a156d2a1b890bb3df62baf32f702811c93614123565b936fa9f746462d870fdf8a65dc1f90e061e502811c93614119565b936fd097f3bdfd2022b8845ad8f792aa582502811c9361410f565b936fe7159475a2c29b7443b29c7fa6e889d902811c93614105565b936ff3392b0822b70005940c7a398e4b70f302811c936140fb565b936ff987a7253ac413176f2b074cf7815e5402811c936140f1565b936ffcbe86c7900a88aedcffc83b479aa3a402811c936140e7565b936ffe5dee046a99a2a811c461f1969c305302811c936140dd565b926fff2ea16466c96a3843ec78b326b528610260801c926140d2565b926fff973b41fa98c081472e6896dfb254c00260801c926140c9565b926fffcb9843d60f6159c9db58835c9266440260801c926140c0565b926fffe5caca7e10e4e61c3624eaa0941cd00260801c926140b7565b926ffff2e50f5f656932ef12357cf3c7fdcc0260801c926140ae565b926ffff97272373d413259a46990580e213a0260801c926140a5565b70ffffffffffffffffffffffffffffffffff70010000000000000000000000000000000061409a565b60046040517f2bc80f3a000000000000000000000000000000000000000000000000000000008152fd5b81614063565b63ffffffff80911660005260646020526020600360406000200154916024604051809481937fdd86c1010000000000000000000000000000000000000000000000000000000083528160301c16600483015260601c5afa90811561446f575b600091614457575090565b611459915060203d81116111e1576111d3818361081c565b61447761377f565b61444c565b7c010000000000000000000000000000000000000000000000000000000081116144c1577bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690565b602490604051907f1ba344530000000000000000000000000000000000000000000000000000000082526004820152fd5b7f80000000000000000000000000000000000000000000000000000000000000008114614520575b60000390565b61452861304e565b61451a565b60008113156145395790565b611459906144f2565b8015614550575b6000190490565b614558613065565b614549565b6040519061456a82610800565b600282526040366020840137565b81601f8201121561000e5780519161458f836122ea565b9261459d604051948561081c565b808452602092838086019260051b82010192831161000e578301905b8282106145c7575050505090565b83809183516145d58161066e565b8152019101906145b9565b91909160408184031261000e5780519267ffffffffffffffff9384811161000e5782019381601f8601121561000e5784519461461b866122ea565b90614629604051928361081c565b868252602096878084019160051b8301019185831161000e578801905b828210614665575050509483015190811161000e576114599201614578565b81518060060b810361000e578152908801908801614646565b6020908160408183019282815285518094520193019160005b8281106146a5575050505090565b835163ffffffff1685529381019392810192600101614697565b60060b9060060b9060008212827fffffffffffffffffffffffffffffffffffffffffffffffffff8000000000000001821281151661470d575b82667fffffffffffff01821316613bed570390565b61471561304e565b6146f8565b60060b9060060b908115614766575b60001982147fffffffffffffffffffffffffffffffffffffffffffffffffff8000000000000082141661475a570590565b61476261304e565b0590565b61476e613065565b614729565b9060060b908115614786575b60060b0790565b61478e613065565b61477f565b6000199060020b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff800000811461343e570190565b908160e091031261000e5780516147db8161066e565b9160208201516147ea81611484565b9160408101516147f9816129ed565b916060820151614808816129ed565b916080810151614817816129ed565b9160a082015160ff8116810361000e5760c0909201516114598161085a565b9063ffffffff811680156149ee576148b56001600160a01b039361487061485b61455d565b94614865866139c5565b9063ffffffff169052565b60009485918261487f876139db565b521693604051809381927f883bdbfd0000000000000000000000000000000000000000000000000000000083526004830161467e565b0381865afa8491816149c9575b5061494a57505060e0600491604051928380927f3850c7bd0000000000000000000000000000000000000000000000000000000082525afa91821561493d575b9161490b575090565b61492c915060e03d8111614936575b614924818361081c565b8101906147c5565b5050505050905090565b503d61491a565b61494561377f565b614902565b61497591925061496f614962614969614962846139db565b5160060b90565b926139c5565b906146bf565b9060060b61498c614986828461471a565b60020b90565b928260060b1291826149ab575b50506149a25790565b61145990614793565b6149c09250906149ba91614773565b60060b90565b15153880614999565b6149e69192503d8087833e6149de818361081c565b8101906145e0565b5090386148c2565b50506114599060e06001600160a01b03916004604051809481937f3850c7bd000000000000000000000000000000000000000000000000000000008352165afa908115614a41575b60009161490b575090565b614a4961377f565b614a36565b919091614a6160ff6101705416156133e7565b6000821290614a708285615b3f565b937361Fea7b93D977D31EF80747666F18864824E6da891823b1561000e576040517ff5a284a1000000000000000000000000000000000000000000000000000000008152600481019190915263ffffffff919091166024820152604481018490526064808201526000608482018190529091829060a49082905af48015614b48575b614b35575b506000821315614b1657506115fc61068d92546001600160a01b031690565b614b1e575050565b61163361162d61068d93546001600160a01b031690565b80610c9f614b42926107a7565b38614af7565b614b5061377f565b614af2565b61068d926001600160a01b03604051937fa9059cbb0000000000000000000000000000000000000000000000000000000060208601521660248401526044830152604482526080820182811067ffffffffffffffff821117614bba575b604052614ce6565b614bc2610790565b614bb2565b909261068d93604051937f23b872dd0000000000000000000000000000000000000000000000000000000060208601526001600160a01b03809216602486015216604484015260648301526064825260a0820182811067ffffffffffffffff821117614bba57604052614ce6565b601f19601f60209267ffffffffffffffff8111614c53575b01160190565b614c5b610790565b614c4d565b9081602091031261000e57516114598161085a565b15614c7c57565b608460405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152fd5b6001600160a01b03169060405190614cfd826107e4565b6020928383527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656484840152803b15614d745760008281928287614d4f9796519301915af1614d49614db8565b90614df9565b80519081614d5c57505050565b8261068d93614d6f938301019101614c60565b614c75565b6064846040519062461bcd60e51b82526004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152fd5b3d15614de3573d90614dc982614c35565b91614dd7604051938461081c565b82523d6000602084013e565b606090565b906020611459928181520190610add565b90919015614e05575090565b815115614e155750805190602001fd5b6110929060405191829162461bcd60e51b8352602060048401526024830190610add565b614e4960ff6101705416156133e7565b8115611cee577361Fea7b93D977D31EF80747666F18864824E6da8803b1561000e576040517fd25c4a6f000000000000000000000000000000000000000000000000000000008152600481019290925260248201839052606460448301819052600090830181905290829060849082905af48015614f13575b614f00575b506000811315614ee75761068d906115fc6067546001600160a01b031690565b61068d9061163361162d6067546001600160a01b031690565b80610c9f614f0d926107a7565b38614ec7565b614f1b61377f565b614ec2565b90606091939293614f3760ff6101705416156133e7565b614f4082615bea565b828501516001600160a01b031680614ff9575b50614f8b60405195869384937fc27789d1000000000000000000000000000000000000000000000000000000008552600485016150e1565b03817361Fea7b93D977D31EF80747666F18864824E6da85af48015614fec575b60009081938291614fc6575b50606c54811061220557509190565b915050614fe291925060603d811161226557612254818361081c565b9291909238614fb7565b614ff461377f565b614fab565b61500c9061228c608088015161ffff1690565b38614f53565b9081606091031261000e578051916040602083015192015190565b9060038210156139445752565b6150d260e061016093969563ffffffff61068d966101808601998652166020850152805160020b6040850152602081015160020b60608501526040810151600f0b608085015261509a606082015160a08601906001600160a01b03169052565b608081015161ffff1660c085015260a08101511515848301526150c660c082015161010086019061502d565b01511515610120830152565b60646101408201520160019052565b61514060e061016093969563ffffffff6000966101808601998652166020850152805160020b6040850152602081015160020b60608501526040810151600f0b608085015261509a606082015160a08601906001600160a01b03169052565b60646101408201520152565b908293929161516160ff6101705416156133e7565b61516a82615bea565b6040918291615203835195869384937f140cf61e00000000000000000000000000000000000000000000000000000000855260048501608061010092959463ffffffff6000956101208501988552166020840152805160408401526001600160a01b03602082015116606084015260408101511515828401526060810151151560a08401520151151560c0820152606460e08201520152565b03817361Fea7b93D977D31EF80747666F18864824E6da85af4938415615319575b60009283956152f4575b506152388561452d565b606c5481106118c157506001600160a01b0361525e60208301516001600160a01b031690565b161515806152de575b615272575b50509190565b818101906152808251151590565b91826152c2575b821561529b575b50501561182d578061526c565b51159150816152ad575b50388061528e565b90506152bb6118818461452d565b14386152a5565b91506152cd8661452d565b6152d7825161452d565b1491615287565b506152ef6118606060830151151590565b615267565b9094508161530f9293503d84116119215761190f818361081c565b919091933861522e565b61532161377f565b615224565b919082604091031261000e576020825192015190565b608061010092959463ffffffff61068d956101208501988552166020840152805160408401526001600160a01b03602082015116606084015260408101511515828401526060810151151560a08401520151151560c0820152606460e08201520160019052565b6153b360ff6101705416156133e7565b61540d60606153cc8360005260d3602052604060002090565b604051809381927fdf19bf09000000000000000000000000000000000000000000000000000000008352600483016020606491939293604081019481520152565b03817361Fea7b93D977D31EF80747666F18864824E6da85af491821561550f575b600092839284916154e9575b50615445838561551c565b9260008513156154b757907f688f0846fe2852572c467d5e769db101b0fea55e8849406d85c9fb322b95299b9161548f866154886067546001600160a01b031690565b3390614b55565b615498816157a9565b604080519586526020860187905285015260608401523392608090a390565b6040517fef37dcc700000000000000000000000000000000000000000000000000000000815260048101869052602490fd5b91935050615505915060603d811161226557612254818361081c565b919290913861543a565b61551761377f565b61542e565b60008112817f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03831381151661557b575b817f80000000000000000000000000000000000000000000000000000000000000000383121661343e570190565b61558361304e565b61554d565b615607916155b26040926155a260ff6101705416156133e7565b60005260d3602052604060002090565b6155bb82615bea565b825193849283927fec1464960000000000000000000000000000000000000000000000000000000084526004840160409063ffffffff6064939594606083019683521660208201520152565b03817361Fea7b93D977D31EF80747666F18864824E6da85af480156156ac575b600091829161568c575b50600082131561565a5761145990615655836154886067546001600160a01b031690565b6157a9565b6040517fef37dcc700000000000000000000000000000000000000000000000000000000815260048101839052602490fd5b90506156a6915060403d81116119215761190f818361081c565b38615631565b6156b461377f565b615627565b929091926156cd60ff6101705416156133e7565b60005260d36020526040600020916156e481615bea565b606b54937361Fea7b93D977D31EF80747666F18864824E6da893843b1561000e5763ffffffff9460009460c49360405197889687957fe0448f0a000000000000000000000000000000000000000000000000000000008752600487015216602485015260020b604484015260020b6064830152866084830152606460a48301525af4801561579c575b615789575b50611459816154886067546001600160a01b031690565b80610c9f615796926107a7565b38615772565b6157a461377f565b61576d565b60008113156157ce5761068d906001600160a01b0380606754169060d5541690614b55565b6157e36001600160a01b0360d55416916144f2565b813b1561000e576000916024839260405194859384927f379607f500000000000000000000000000000000000000000000000000000000845260048401525af1801561583a575b6158315750565b61068d906107a7565b61584261377f565b61582a565b6158b8602060016001600160a01b03936158878587511682906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b019301519182511683906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b6020810151907fffffffffffffff0000000000ffffffffffffffffffffffffffffffffffffffff77ffffffff000000000000000000000000000000000000000078ff00000000000000000000000000000000000000000000000060408654940151151560c01b169360a01b16911617179055565b919063ffffffff83166001600160a01b03841615615ac2576159746118606119e56159678463ffffffff166000526065602052604060002090565b546001600160a01b031690565b80615a87575b615a2757926159de7f52983c04d8ccd4808cd0fcb24e6e48106ecb41e803d6270c6c94a15e3ebd08d293946159d96159b061083f565b6001600160a01b03851681529185602084015263ffffffff166000526065602052604060002090565b615847565b615a2260405192839283909291604060609160808401956001600160a01b038091168552815116602085015263ffffffff6020820151168285015201511515910152565b0390a1565b615a45615967859263ffffffff166000526065602052604060002090565b6040517fa5d4d0b50000000000000000000000000000000000000000000000000000000081526001600160a01b03928316600482015291166024820152604490fd5b50615abd61186085615aac6159678563ffffffff166000526065602052604060002090565b6001600160a01b0390811691161490565b61597a565b6040517f76d8a93100000000000000000000000000000000000000000000000000000000815260006004820152602490fd5b60005260d3602052604060002090815460601c3303615b0f57565b60246040517f0504a20d000000000000000000000000000000000000000000000000000000008152336004820152fd5b63ffffffff90929192168060005260656020526040600020926001600160a01b0384541615615bb9571580615ba7575b615b765750565b602490604051907f9150f8c80000000000000000000000000000000000000000000000000000000082526004820152fd5b5060ff600184015460c01c1615615b6f565b602482604051907f6b9c1a9d0000000000000000000000000000000000000000000000000000000082526004820152fd5b63ffffffff1680600052606460205260406000206001600160a01b0381541615615c51576003015460501c60ff1615615c205750565b602490604051907fb0fdd2020000000000000000000000000000000000000000000000000000000082526004820152fd5b602482604051907fb842f5a70000000000000000000000000000000000000000000000000000000082526004820152fd5b6001600160a01b039182169116818110613bed570390565b6001600160a01b039182809216918291169204821181151516615cbb570290565b615cc361304e565b0290565b63ffffffff166000526064602052615d65611132615d546001600160a01b039361ffff600460e08760016040600020015416604051928380927f3850c7bd0000000000000000000000000000000000000000000000000000000082525afa908115615dcc575b600091615da8575b50828781168289161115615d9857615d4c91615c82565b965b16615c9a565b6001600160a01b0361271091160490565b911611615d6e57565b60046040517f07a1db07000000000000000000000000000000000000000000000000000000008152fd5b90615da291615c82565b96615d4e565b615dc0915060e03d811161493657614924818361081c565b50505050505038615d35565b615dd461377f565b615d2d565b615de1613eeb565b9063ffffffff91828216600052606d60205260406000209280845416911614600014615e2d5750600101547bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690565b61145991506143ed565b615e3f613eeb565b9063ffffffff808216600052606d60205280604060002054931690831614600014615e6b575060201c90565b6114599150613c4e9061400c565b805160051b810160209081018183015b818110615e965750505090565b80515481528201615e89565b9091615ebb92811015615ebf575b60051b81019061394f565b9091565b615ec7612db0565b615eb0565b908092918237016000815290565b60208183031261000e5780519067ffffffffffffffff821161000e570181601f8201121561000e578051615f0d81614c35565b92615f1b604051948561081c565b8184526020828401011161000e576114599160208085019101610aa856fea2646970667358221220fab82ba3138bee6136a01bfe21ef7126674facf7eb334d4ee383eaa2301b15e664736f6c634300080e0033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b60003560e01c806304a6f2641461031f5780630df181ea14610316578063134015511461030d578063136439dd146103045780631e2eaeaf146102fb5780632a90b8da146102f25780633562490c146102e957806335876476146102e05780633d0aea3d146102d75780633d56a35e146102ce5780633ffe794c146102c557806340c4f69b146102bc578063424cd833146102b357806343afafba146102aa578063569634d3146102a15780635aa6e675146102985780635c975abb1461028f5780636a486482146102865780636ae732301461027d578063706bdd25146102745780637cc2f4f51461026b5780637d2efe071461026257806383d778eb146102595780638ce25a93146102505780638f24ab11146102475780638f8022bc1461023e5780639cd1be58146102355780639dca362f1461022c578063a05c8baf14610223578063ac9650d81461021a578063b790230314610211578063c7505c1514610208578063ce4c18de146101ff578063dbc0c085146101f6578063dbd035ff146101ed578063e3d41c18146101e4578063e450f6f4146101db578063e67ed1df146101d25763fabc1cbc146101ca57600080fd5b61000e6126be565b5061000e6125e5565b5061000e612477565b5061000e6123e3565b5061000e61234c565b5061000e6122c1565b5061000e612299565b5061000e6120ff565b5061000e6120d7565b5061000e611ff6565b5061000e611d76565b5061000e611d18565b5061000e611be1565b5061000e611b5b565b5061000e611954565b5061000e611935565b5061000e6116e9565b5061000e6114f3565b5061000e61149a565b5061000e61145c565b5061000e6113be565b5061000e6112e5565b5061000e6112c0565b5061000e611297565b5061000e611269565b5061000e611221565b5061000e611096565b5061000e610b82565b5061000e610978565b5061000e610950565b5061000e6108a4565b5061000e6106a7565b5061000e6105ee565b5061000e61056e565b5061000e61054e565b5061000e61044a565b5061000e610421565b5061000e61035c565b5061000e610333565b600091031261000e57565b503461000e57600060031936011261000e5760206001600160a01b036101a55416604051908152f35b503461000e576000602060031936011261041e5761038060ff6101705416156133e7565b61038b600435615af4565b61039481613b1a565b8173__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__91823b1561041a576044604051809481937feaf393260000000000000000000000000000000000000000000000000000000083526004830152606460248301525af4801561040d575b6103fe575b50604051f35b610407906107a7565b386103f8565b61041561377f565b6103f3565b5080fd5b80fd5b503461000e57600060031936011261000e5760206001600160a01b036101a45416604051908152f35b503461000e57602060031936011261000e576001600160a01b03806101a35416331415908161053e575b506105145761017061048a60ff825416156133e7565b60d7546104ea5761049f60043560665461345a565b6104a6575b005b600160ff1982546104ba60ff8216156133e7565b161790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b60046040517fd2067f43000000000000000000000000000000000000000000000000000000008152fd5b60046040517fd7a2ae6a000000000000000000000000000000000000000000000000000000008152fd5b6101a25416331415905038610474565b503461000e57602060031936011261000e57602060043554604051908152f35b503461000e57600060031936011261000e576101a48054906001600160a01b0390818316803303610514576000936101a2805492806040519685167f5f56bee8cffbe9a78652a74a60705edede02af10b0bbb888ca44b79a0d42ce808989a373ffffffffffffffffffffffffffffffffffffffff19809416179055169055f35b503461000e57600060031936011261000e576101a58054906001600160a01b0390818316803303610514576000936101a3805492806040519685167f39355f2f5c8206286978f443aa8126bbd29fa09c53c04569502647f3a59c8cb28989a373ffffffffffffffffffffffffffffffffffffffff19809416179055169055f35b6001600160a01b0381160361000e57565b610124359061068d8261066e565b565b60e4359061068d8261066e565b359061068d8261066e565b503461000e5760e060031936011261000e576004356106c58161066e565b61073f6024356106d48161066e565b6044356106e08161066e565b6064356106ec8161066e565b608435906106f98261066e565b60a435926107068461066e565b60c435946107138661066e565b61013d5460ff8160081c1690816000146107835750610733303b15612792565b15978861075657612803565b61074557005b6104a461013d61ff00198154169055565b61076b61013d61010061ff0019825416179055565b61077e61013d600160ff19825416179055565b612803565b60ff610733911615612792565b50634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff81116107bb57604052565b6107c3610790565b604052565b60a0810190811067ffffffffffffffff8211176107bb57604052565b6040810190811067ffffffffffffffff8211176107bb57604052565b6060810190811067ffffffffffffffff8211176107bb57604052565b90601f601f19910116810190811067ffffffffffffffff8211176107bb57604052565b6040519061068d826107e4565b63ffffffff81160361000e57565b8015150361000e57565b60e4359061068d8261085a565b610104359061068d8261085a565b60a4359061068d8261085a565b60c4359061068d8261085a565b359061068d8261085a565b503461000e57608060031936011261000e576004356108c28161066e565b60607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc36011261000e576040516104a4916060820167ffffffffffffffff811183821017610943575b60405260243561091a8161066e565b82526044356109288161084c565b60208301526064356109398161085a565b6040830152612fd6565b61094b610790565b61090b565b503461000e57600060031936011261000e5760206001600160a01b0360d45416604051908152f35b503461000e5761014060031936011261000e576001600160a01b038060d454163303610a4d576109d163ffffffff6004356109b28161066e565b1691826000526064602052604060002054166001600160a01b03161590565b15610a3757610a3281610a1d610a187f4182acc9c169391ef7e765eb446fc15c9d49bc73060c678bf4c424a5c0dbdbcb9463ffffffff166000526064602052604060002090565b612c43565b610a2681612e15565b60405191829182612eae565b0390a1005b634e487b7160e01b600052600160045260246000fd5b60046040517f85734f31000000000000000000000000000000000000000000000000000000008152fd5b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020808501948460051b01011161000e57565b918091926000905b828210610ac8575011610ac1575050565b6000910152565b91508060209183015181860152018291610ab0565b90601f19601f602093610afb81518092818752878088019101610aa8565b0116010190565b602080820190808352835180925260408301928160408460051b8301019501936000915b848310610b365750505050505090565b9091929394958480610b72837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc086600196030187528a51610add565b9801930193019194939290610b26565b503461000e5760408060031936011261000e57600480359160243567ffffffffffffffff811161000e57610bb99036908401610a77565b610bc581949294613864565b93610bda8660005260d3602052604060002090565b95610be487613b1a565b60008781938295835b818110610d5f5750505050610d4f575b50610cb8575b610c19575b815180610c158582610b02565b0390f35b73__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__90813b1561000e5782517f998c53350000000000000000000000000000000000000000000000000000000081529081019485526001602086015260646040860152610c159490916000918391908290819060600103915af48015610cab575b15610c085780610c9f610ca5926107a7565b80610328565b38610c08565b610cb361377f565b610c8d565b73__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__803b1561000e576000845180927f651524ed0000000000000000000000000000000000000000000000000000000082528180610d198b8983016020606491939293604081019481520152565b03915af48015610d42575b610d2f575b50610c03565b80610c9f610d3c926107a7565b38610d29565b610d4a61377f565b610d24565b610d5890615af4565b5038610bfd565b9091929693610d77610d728385876138ad565b613924565b610d8081613912565b610dd8575080610dc0610daf610da7610d9d610dc59587896138ad565b602081019061394f565b810190613afb565b906001978015610dce575b9a614a4e565b61344a565b908a9291610bed565b5060008212610dba565b939650610de9610d728284866138ad565b93610df385613912565b6001948503610e425750610e16610e0e610d9d8385876138ad565b810190613aec565b93610e21858d614e39565b6000819512610e35575b50610dc59061344a565b9650869550610dc5610e2b565b6002610e55610d728486889c969c6138ad565b610e5e81613912565b03610edf575050610eb1610ebf610e768884866138ad565b610e9a8d610e94610e8c6020948581019061394f565b810190613a66565b9161514c565b8c5192830191825260208201529092839160400190565b03601f19810183528261081c565b610ec9878b6139ec565b52610ed4868a6139ec565b50610dc5839661344a565b6003610eef610d728a86886138ad565b610ef881613912565b03610f34575050610eb1610ebf610f108884866138ad565b610e9a8d610f2e610f266020948581019061394f565b810190613a41565b91614f20565b93509587610f46610d728385876138ad565b610f4f81613912565b03610f815780610f7b610f74610f6c610d9d610dc59587896138ad565b810190613a0e565b91896156b9565b5061344a565b6005610f91610d728385876138ad565b610f9a81613912565b03610fd05780610f7b610fcb610fc2610fba610d9d610dc596888a6138ad565b810190611444565b63ffffffff1690565b6153a3565b6006610fe0610d728385876138ad565b610fe981613912565b036110505780610ffd610dc59284866138ad565b61103b61102963ffffffff61102261101a6020958681019061394f565b8101906139a0565b9116615588565b8c519283019081528290602001610eb1565b611045828d6139ec565b52610f7b818c6139ec565b611063610d72611092928a948c966138ad565b92519283927f62c9ca420000000000000000000000000000000000000000000000000000000084528301613931565b0390fd5b503461000e5760208060031936011261000e5760665460d85460049283358215611218575b600090806111f55750508293915b8481106110e65750505081036110e15750600060d855005b60d855005b8060008361113e611132600261112463ffffffff61110661118799612dc7565b90549060031b1c1663ffffffff166000526064602052604060002090565b01546001600160a01b031690565b6001600160a01b031690565b86604051809481937f5e622abc0000000000000000000000000000000000000000000000000000000083525af19081156111e8575b6000916111bb575b508061118c575061344a565b6110c9565b6111b5906111a26067546001600160a01b031690565b6001600160a01b036101a3541690614b55565b38610f7b565b6111db9150843d86116111e1575b6111d3818361081c565b810190613edc565b3861117b565b503d6111c9565b6111f061377f565b611173565b6111ff9084613432565b905083811015611211575b93916110c9565b508261120a565b600092506110bb565b503461000e57604060031936011261000e5760206112616024356004356112478261084c565b8060005260d3845261125c6040600020613b1a565b615588565b604051908152f35b503461000e57602060031936011261000e576104a46004358060005260d3602052610fcb6040600020613b1a565b503461000e57600060031936011261000e5760206001600160a01b036101a25416604051908152f35b503461000e57600060031936011261000e57602060ff61017054166040519015158152f35b503461000e57604060031936011261000e57610c156024356113068161084c565b60043560005260d360205263ffffffff604060002091604051927f7188a1ed00000000000000000000000000000000000000000000000000000000845260048401521660248201526064604482015260208160648173__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__5af49081156113b1575b600091611393575b506040519081529081906020820190565b6113ab915060203d81116111e1576111d3818361081c565b38611382565b6113b961377f565b61137a565b503461000e57602060031936011261000e576004356113dc8161066e565b6001600160a01b03806101a254163303610514576000916101a59073ffffffffffffffffffffffffffffffffffffffff19838354921691826040519582167f9b068aae3039a2512c2f13bffb5fd9d95b1895b276b5c7ddf1d4fa24ec3686588888a316179055f35b9081602091031261000e57356114598161084c565b90565b503461000e57602060031936011261000e57602061126160043561147f8161084c565b615dd9565b8060020b0361000e57565b359061068d82611484565b503461000e57608060031936011261000e576104a46004356024356114be8161084c565b604435906114cb82611484565b606435926114d884611484565b8060005260d36020526114ee6040600020613b1a565b6156b9565b503461000e57606060031936011261000e576024356115118161084c565b6044356101709061152660ff835416156133e7565b611531600435615af4565b9161153b83613b1a565b60009361154f60ff868512935416156133e7565b8461155a8383615b3f565b9473__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__803b15611662576040517ff5a284a1000000000000000000000000000000000000000000000000000000008152600481019290925263ffffffff93909316602482015260448101859052606480820152831515608482015291829060a49082905af48015611655575b611642575b508382131561160a57506115fc61160592546001600160a01b031690565b30903390614bc7565b604051f35b611616575b5050604051f35b61163361162d61163b93546001600160a01b031690565b916144f2565b903390614b55565b388061160f565b80610c9f61164f926107a7565b386115de565b61165d61377f565b6115d9565b8280fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbc60a091011261000e576040519061169d826107c8565b8160443581526064356116af8161066e565b60208201526084356116c08161085a565b604082015260a4356116d18161085a565b6060820152608060c435916116e58361085a565b0152565b503461000e5760e060031936011261000e576024356117078161084c565b61171036611666565b809161017061172360ff825416156133e7565b61174560ff611733600435615af4565b9261173d84613b1a565b5416156133e7565b61174e82615bea565b6040918291611789835195869384937f140cf61e0000000000000000000000000000000000000000000000000000000085526004850161533c565b038173__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__5af4928315611928575b60009283946118f3575b506117be8461452d565b606c5481106118c157506001600160a01b036117e460208301516001600160a01b031690565b161515806118ab575b611804575b50519081526020810191909152604090f35b818101906118128251151590565b918261188f575b8215611856575b50501561182d57386117f2565b600490517f07a1db07000000000000000000000000000000000000000000000000000000008152fd5b5190915015611864565b1590565b9081611873575b503880611820565b90506118886118818461452d565b915161452d565b143861186b565b915061189a8561452d565b6118a4825161452d565b1491611819565b506118bc6118606060830151151590565b6117ed565b82517f256d6b9a0000000000000000000000000000000000000000000000000000000081526004810191909152602490fd5b909350816119179293503d8411611921575b61190f818361081c565b810190615326565b91909192386117b4565b503d611905565b61193061377f565b6117aa565b503461000e57600060031936011261000e57602060d254604051908152f35b503461000e5761010060031936011261000e5760048035906119758261084c565b60e07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc36011261000e576001600160a01b036101a254163303611b33576119d760036119d18463ffffffff166000526064602052604060002090565b01612a65565b6119f26119e5611132612a4c565b6001600160a01b03161590565b611b155763ffffffff61012c81611a07612a27565b1610908115611aff575b50611ae05761ffff6127108082611a266129f9565b1611611ac257611a3e611a37612a05565b61ffff1690565b11611aa4576107d090611a4f612a11565b1611611a85576040517f4182acc9c169391ef7e765eb446fc15c9d49bc73060c678bf4c424a5c0dbdbcb9080610a328582612f52565b604051636a098dd160e11b815260249181019182529081906020010390fd5b604051636a098dd160e11b8152602381840190815281906020010390fd5b604051636a098dd160e11b8152602281850190815281906020010390fd5b604051636a098dd160e11b815260219181019182529081906020010390fd5b620151809150611b0d612a27565b161138611a11565b604051636a098dd160e11b8152602091810182815290918291010390fd5b6040517fd7a2ae6a000000000000000000000000000000000000000000000000000000008152fd5b503461000e57602060031936011261000e57600435611b798161066e565b6001600160a01b03806101a254163303610514576000916101a49073ffffffffffffffffffffffffffffffffffffffff19838354921691826040519582167f8c405decc72a19ef328c92989ce6db4e4a498e1c246413fd60997a3051ba5cff8888a316179055f35b503461000e57604060031936011261000e57602435610170611c0760ff825416156133e7565b611c1760ff611733600435615af4565b8115611cee5773__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__803b1561000e576040517fd25c4a6f000000000000000000000000000000000000000000000000000000008152600481019290925260248201839052606460448301819052600190830152600090829060849082905af48015611ce1575b611cce575b506000811315611cb5576104a4906115fc6067546001600160a01b031690565b6104a49061163361162d6067546001600160a01b031690565b80610c9f611cdb926107a7565b38611c95565b611ce961377f565b611c90565b60046040517f1f2a2005000000000000000000000000000000000000000000000000000000008152fd5b503461000e57600060031936011261000e5760206112616136aa565b60031961010091011261000e57600490565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbc61010091011261000e57604490565b503461000e5761016060031936011261000e57611d9236611d34565b610104356101243591610144356001600160a01b036101a254163303610514576127109361ffff8581611dc486612a1d565b1611611fdd5785611dda611a3760208701612a1d565b11611fc45760409580611df1611a37898801612a1d565b11611fac5780611e06611a3760608801612a1d565b11611f9457611e1a611a3760808701612a1d565b11611f7c576103e890611e2f60a08601612a1d565b1611611f6457633b9aca008067ffffffffffffffff611e5060c0870161308e565b1611611f4c5780611e73611e6660e0870161308e565b67ffffffffffffffff1690565b11611f3457808511611f1c57808211611f04578211611eec5791611ee660009594927f697aec6e94e319190380ab0f1f10018d81b64da2479eb874be92c9a733e0a83794611ec084613098565b611ec985606b55565b611ed281606c55565b611edb82606a55565b8651948594856132fb565b0390a151f35b8451636a098dd160e11b8152603a6004820152602490fd5b8551636a098dd160e11b815260396004820152602490fd5b8551636a098dd160e11b815260386004820152602490fd5b8551636a098dd160e11b815260376004820152602490fd5b8551636a098dd160e11b815260366004820152602490fd5b8451636a098dd160e11b815260356004820152602490fd5b8551636a098dd160e11b815260346004820152602490fd5b8651636a098dd160e11b815260336004820152602490fd5b8651636a098dd160e11b815260326004820152602490fd5b604051636a098dd160e11b815260316004820152602490fd5b604051636a098dd160e11b815260306004820152602490fd5b50602060031936011261000e576004803567ffffffffffffffff811161000e576120239036908301610a77565b9061202d82613864565b9160005b8181106120465760405180610c158682610b02565b600080612054838587615ea2565b60409391612066855180938193615ecc565b0390305af490612074614db8565b9182901561209d575050906120989161208d82876139ec565b52610f7b81866139ec565b612031565b826044899394511061000e5761109291836120c2920160248091518301019101615eda565b925192839262461bcd60e51b84528301614de8565b503461000e57600060031936011261000e5760206001600160a01b0360d55416604051908152f35b503461000e5761014060031936011261000e5760243561211e8161084c565b606061212936611d46565b916101709261213c60ff855416156133e7565b61216960ff61216061214f600435615af4565b9361215985613b1a565b36906137a7565b955416156133e7565b61217282615bea565b828401516001600160a01b031680612279575b506121bd60405194859384937fc27789d10000000000000000000000000000000000000000000000000000000085526004850161503a565b038173__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__5af4801561226c575b60009081928291612238575b50606c5481106122055750604080519182526020820192909252f35b6040517f256d6b9a0000000000000000000000000000000000000000000000000000000081526004810191909152602490fd5b91505061225c915060603d8111612265575b612254818361081c565b810190615012565b919091386121e9565b503d61224a565b61227461377f565b6121dd565b6122939061228c608087015161ffff1690565b9084615cc7565b38612185565b503461000e57602060031936011261000e5760206112616004356122bc8161084c565b615e37565b503461000e57600060031936011261000e5760206001600160a01b036101a35416604051908152f35b60209067ffffffffffffffff8111612304575b60051b0190565b61230c610790565b6122fd565b6020908160408183019282815285518094520193019160005b828110612338575050505090565b83518552938101939281019260010161232a565b503461000e5760208060031936011261000e5760043567ffffffffffffffff811161000e573660238201121561000e5780600401359061238b826122ea565b91612399604051938461081c565b80835260248484019160051b8301019136831161000e57602401905b8282106123d457610c156123c885615e79565b60405191829182612311565b813581529084019084016123b5565b503461000e57602060031936011261000e5760043560005260d3602052610c156040600020604051907fc4b22b8600000000000000000000000000000000000000000000000000000000825260048201526064602482015260208160448173__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__5af49081156113b15760009161139357506040519081529081906020820190565b503461000e57604060031936011261000e576004356124958161084c565b602435906124a16136aa565b90610170926124b460ff855416156133e7565b6124bd83615af4565b936124c785613b1a565b6124d960ff60008412925416156133e7565b6124e38184615b3f565b9273__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__90813b1561000e576040517ff5a284a1000000000000000000000000000000000000000000000000000000008152600481019790975263ffffffff166024870152604486018390526064808701528115156084870152610c159590600090829060a49082905af480156125d8575b6125c5575b50600082131561259b57506115fc61258b92546001600160a01b031690565b6040519081529081906020820190565b6125a7575b505061258b565b61163361162d6125be93546001600160a01b031690565b38806125a0565b80610c9f6125d2926107a7565b3861256c565b6125e061377f565b612567565b503461000e5760408060031936011261000e576024356126048161085a565b60043560005260d360205281600020908251917f0c6d7f3400000000000000000000000000000000000000000000000000000000835260048301521515602482015260646044820152818160648173__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__5af49182156126b1575b600091829361268c5750519081526020810191909152604090f35b816126a9929450610c1593503d85116119215761190f818361081c565b9290916117f2565b6126b961377f565b612671565b503461000e57602060031936011261000e576001600160a01b03806101a354163314159081612782575b50610514576101706126fd60ff82541661365f565b60d65461275857612712600435606654613574565b61271857005b60ff19815461272960ff821661365f565b1690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b60046040517ffc23b9cd000000000000000000000000000000000000000000000000000000008152fd5b6101a254163314159050386126e8565b1561279957565b608460405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152fd5b93916128a27f39355f2f5c8206286978f443aa8126bbd29fa09c53c04569502647f3a59c8cb2936000958694986001600160a01b039a8b80928173ffffffffffffffffffffffffffffffffffffffff199c168c60d454161760d4558185168c6067541617606755168a60d554161760d55516886068541617606855896040519261288c84610800565b168252603c60208301526001604083015261592c565b61013d9680885460ff8160081c169081861461295a57506128c4303b15612792565b15978861292d575b16916101a2838882541617905560405192847f5f56bee8cffbe9a78652a74a60705edede02af10b0bbb888ca44b79a0d42ce808186a31694856101a391825416179055a361291e575b5061068d612967565b61ff0019815416905538612915565b61294261013d61010061ff0019825416179055565b61295561013d600160ff19825416179055565b6128cc565b60ff6128c4911615612792565b60ff61013d5460081c16156129835761017060ff198154169055565b608460405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152fd5b61ffff81160361000e57565b602435611459816129ed565b604435611459816129ed565b606435611459816129ed565b35611459816129ed565b6084356114598161084c565b60e4356114598161085a565b610104356114598161085a565b60e4356114598161066e565b610124356114598161066e565b61068d90612aa7602435612a78816129ed565b829061ffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000825416179055565b612aeb604435612ab6816129ed565b82547fffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff1660109190911b63ffff000016178255565b612b31606435612afa816129ed565b82547fffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff1660209190911b65ffff0000000016178255565b608435612b3d8161084c565b7fffffffffffffffffffffffffffffffffffffffffffff00000000ffffffffffff69ffffffff00000000000083549260301b169116178155612bc060a435612b848161085a565b82547fffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff1690151560501b6aff0000000000000000000016178255565b612c0c60c435612bcf8161085a565b82547fffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff1690151560581b6bff000000000000000000000016178255565b60e43590612c198261066e565b906bffffffffffffffffffffffff6bffffffffffffffffffffffff1983549260601b169116179055565b600361068d91612c81600435612c588161066e565b82906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b612cbc602435612c908161066e565b60018301906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b612cf7604435612ccb8161066e565b60028301906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b01612d07606435612a78816129ed565b612d16608435612ab6816129ed565b612d2560a435612afa816129ed565b60c435612d318161084c565b7fffffffffffffffffffffffffffffffffffffffffffff00000000ffffffffffff69ffffffff00000000000083549260301b169116178155612d74612b84612a33565b612d7f612bcf612a3f565b612d87612a58565b6bffffffffffffffffffffffff6bffffffffffffffffffffffff1983549260601b169116179055565b50634e487b7160e01b600052603260045260246000fd5b90606654821015612e08575b6066600052601c8260031c7f46501879b8ca8525e8c2fd519e2fbfcfa2ebea26501294aa02cbfcfb12e94354019260021b1690565b612e10612db0565b612dd3565b6066549068010000000000000000821015612e96575b6001820180606655821015612e89575b60666000528160031c7f46501879b8ca8525e8c2fd519e2fbfcfa2ebea26501294aa02cbfcfb12e94354019160e083549160051b169163ffffffff9283811b93849216901b16911916179055565b612e91612db0565b612e3b565b612e9e610790565b612e2b565b359061068d826129ed565b63ffffffff91821681526101008101929161068d9190606435612ed0816129ed565b61ffff809116602084015280608435612ee8816129ed565b16604084015260a435612efa816129ed565b16606083015260c435612f0c8161084c565b166080820152612f26612f1d610864565b151560a0830152565b612f3a612f31610871565b151560c0830152565b60e0612f4461067f565b6001600160a01b0316910152565b63ffffffff91821681526101008101929161068d9190602435612f74816129ed565b61ffff809116602084015280604435612f8c816129ed565b166040840152606435612f9e816129ed565b166060830152608435612fb08161084c565b166080820152612fc1612f1d61087f565b612fcc612f3161088c565b60e0612f4461068f565b906001600160a01b03806101a2541633036105145781511615613035576201518063ffffffff61300d602084015163ffffffff1690565b161161301c5761068d9161592c565b604051636a098dd160e11b815260116004820152602490fd5b604051636a098dd160e11b815260106004820152602490fd5b50634e487b7160e01b600052601160045260246000fd5b50634e487b7160e01b600052601260045260246000fd5b67ffffffffffffffff81160361000e57565b356114598161307c565b6132a260e061068d9261ffff81356130af816129ed565b167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000606954161760695561312060208201356130ea816129ed565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff63ffff00006069549260101b16911617606955565b6131696040820135613131816129ed565b7fffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff65ffff000000006069549260201b16911617606955565b6060810135613177816129ed565b7fffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffff67ffff0000000000006069549260301b169116176069556131fa6131be60808301612a1d565b7fffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffff69ffff00000000000000006069549260401b16911617606955565b61324761320960a08301612a1d565b7fffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffffff6bffff000000000000000000006069549260501b16911617606955565b61329c61325660c0830161308e565b7fffffffffffffffffffffffff0000000000000000ffffffffffffffffffffffff73ffffffffffffffff0000000000000000000000006069549260601b16911617606955565b0161308e565b7fffffffff0000000000000000ffffffffffffffffffffffffffffffffffffffff7bffffffffffffffff00000000000000000000000000000000000000006069549260a01b16911617606955565b359061068d8261307c565b90949392610140926133d76133c660e0610160860199803561331c816129ed565b61ffff80911688526020820135613332816129ed565b16602088015261335261334760408301612ea3565b61ffff166040890152565b61336c61336160608301612ea3565b61ffff166060890152565b61338661337b60808301612ea3565b61ffff166080890152565b6133a061339560a08301612ea3565b61ffff1660a0890152565b6133c06133af60c083016132f0565b67ffffffffffffffff1660c0890152565b016132f0565b67ffffffffffffffff1660e0850152565b6101008301526101208201520152565b156133ee57565b606460405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152fd5b8119811161343e570190565b61344661304e565b0190565b600190600019811461343e570190565b60d6549291831561356b575b6000908061354957505080925b8381106134915750821491821561348c5750600060d655565b60d655565b63ffffffff61349f82612dc7565b90549060031b1c1660005260646020526040906134cd611132600284600020016001600160a01b0390541690565b803b1561000e57600061352a935180927f5124033600000000000000000000000000000000000000000000000000000000825281838161351560048201906000602083019252565b03925af1801561353c575b61352f575061344a565b613473565b80610c9f6111b5926107a7565b61354461377f565b613520565b6135539085613432565b905081811015613564575b92613473565b508061355e565b60009350613466565b60d75492918315613656575b6000908061363457505080925b8381106135ab575082149182156135a65750600060d755565b60d755565b63ffffffff6135b982612dc7565b90549060031b1c1660005260646020526040906001600160a01b03600283600020015416803b1561000e5760008091602461362f9551809481937f51240336000000000000000000000000000000000000000000000000000000008352600160048401525af1801561353c5761352f575061344a565b61358d565b61363e9085613432565b90508181101561364f575b9261358d565b5080613649565b60009350613580565b1561366657565b606460405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152fd5b6136ba60ff6101705416156133e7565b60d2547ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe8111613772575b6001810160d255600081815260d36020526040902080546bffffffffffffffffffffffff163360601b6bffffffffffffffffffffffff19161781556bffffffffffffffffffffffff82166bffffffffffffffffffffffff198254161790556040518181527f7325fb14450d3e5eb288c620b4ff1d6b43a41b33b4a4f143ae88cd4c12f99ea360203392a290565b61377a61304e565b6136e5565b506040513d6000823e3d90fd5b359081600f0b820361000e57565b3590600382101561000e57565b809291610100918291031261000e5760405190810181811067ffffffffffffffff821117613857575b60405260e06138528183956137e48161148f565b85526137f26020820161148f565b60208601526138036040820161378c565b60408601526138146060820161069c565b606086015261382560808201612ea3565b608086015261383660a08201610899565b60a086015261384760c0820161379a565b60c086015201610899565b910152565b61385f610790565b6137d0565b9061386e826122ea565b61387b604051918261081c565b828152601f1961388b82946122ea565b019060005b82811061389c57505050565b806060602080938501015201613890565b91908110156138ee575b60051b810135907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc18136030182121561000e570190565b6138f6612db0565b6138b7565b50634e487b7160e01b600052602160045260246000fd5b6007111561391c57565b61068d6138fb565b35600781101561000e5790565b9190602083019260078210156139445752565b61394c6138fb565b52565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18136030182121561000e570180359067ffffffffffffffff821161000e5760200191813603831361000e57565b919082604091031261000e57602082356139b98161084c565b9201356114598161084c565b6020908051156139d3570190565b613446612db0565b6040908051600110156139d3570190565b6020918151811015613a01575b60051b010190565b613a09612db0565b6139f9565b9081606091031261000e578035613a248161084c565b9160406020830135613a3581611484565b92013561145981611484565b91906101208382031261000e576114599060208435613a5f8161084c565b94016137a7565b809291039160c0831261000e5760a0601f198235613a838161084c565b94011261000e5760a060405191613a99836107c8565b602081013583526040810135613aae8161066e565b60208401526060810135613ac18161085a565b60408401526080810135613ad48161085a565b60608401520135613ae48161085a565b608082015290565b9081602091031261000e573590565b919082604091031261000e5760208235613b148161084c565b92013590565b60005b60088060ff83161015613b7c57811015613b81575b63ffffffff60018260031c8401015460e08360051b161c16908115613b7c57613b5c600192613c06565b60ff809116908114613b6f575b01613b1d565b613b7761304e565b613b69565b505050565b613b89612db0565b613b32565b60008212827f8000000000000000000000000000000000000000000000000000000000000000018212811516613bf9575b827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01821316613bed570390565b613bf561304e565b0390565b613c0161304e565b613bbf565b613c0e613eeb565b613c288263ffffffff16600052606d602052604060002090565b805463ffffffff838116911614613b7c57613c42836143ed565b613c53613c4e8561400c565b613f97565b937c010000000000000000000000000000000000000000000000000000000080831090811591613e1f575b50613e185761068d94613d33613d38613db994613cbf6003613cb3613d849763ffffffff166000526064602052604060002090565b015460201c61ffff1690565b613cdf61ffff613cd7613cd28886613b8e565b61452d565b921683613e2a565b1015613de957613d33600188017c01000000000000000000000000000000000000000000000000000000007fffffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffff825416179055565b61447c565b60018601907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000825416179055565b825463ffffffff1660209190911b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000016178255565b9063ffffffff167fffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000825416179055565b613d33600188017fffffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffff8154169055565b5050505050565b905085101538613c7e565b9060001981830981830291828083109203918083039214613e8757612710908282111561000e577fbc01a36e2eb1c432ca57a786c226809d495182a9930be0ded288ce703afb7e91940990828211900360fc1b910360041c170290565b505061271091500490565b6000198282099082810292838084109303928084039314613ed35768010000000000000000918383111561000e570990828211900360c01b910360401c1790565b50505060401c90565b9081602091031261000e575190565b61a4b146148015613f8b575b8015613f7f575b15613f755763ffffffff6040517fa3b1b31d00000000000000000000000000000000000000000000000000000000815260208160048160645afa908115613f68575b600091613f4c57501690565b613f64915060203d81116111e1576111d3818361081c565b1690565b613f7061377f565b613f40565b63ffffffff431690565b5062066eec4614613efe565b5062066eeb4614613ef7565b6001600160a01b03166401000276a381108015613fee575b613fbd578061145991613e92565b602490604051907f5d236c450000000000000000000000000000000000000000000000000000000082526004820152fd5b5073fffd8963efd1fc6a506488495d951d5263988d26811015613faf565b6140269063ffffffff166000526064602052604060002090565b60036140506001600160a01b0392836001820154169063ffffffff938491015460301c1690614836565b60020b9060008212156143e75781600003915b620d89e883116143bd5760018316156143945770ffffffffffffffffffffffffffffffffff6ffffcb933bd6fad37aa2d162d1a5940015b169260028116614378575b6004811661435c575b60088116614340575b60108116614324575b60208116614308575b604081166142ec575b6080908181166142d1575b61010081166142b6575b610200811661429b575b6104008116614280575b6108008116614265575b611000811661424a575b612000811661422f575b6140008116614214575b61800081166141f9575b6201000081166141de575b6202000081166141c4575b6204000081166141aa575b620800001661418f575b5060001261417f575b81166141765760ff60005b169060201c011690565b60ff600161416c565b9061418990614542565b90614161565b6b048a170391f7dc42444e8fa26000929402901c9290614158565b6d2216e584f5fa1ea926041bedfe98909402811c9361414e565b936e5d6af8dedb81196699c329225ee60402811c93614143565b936f09aa508b5b7a84e1c677de54f3e99bc902811c93614138565b936f31be135f97d08fd981231505542fcfa602811c9361412d565b936f70d869a156d2a1b890bb3df62baf32f702811c93614123565b936fa9f746462d870fdf8a65dc1f90e061e502811c93614119565b936fd097f3bdfd2022b8845ad8f792aa582502811c9361410f565b936fe7159475a2c29b7443b29c7fa6e889d902811c93614105565b936ff3392b0822b70005940c7a398e4b70f302811c936140fb565b936ff987a7253ac413176f2b074cf7815e5402811c936140f1565b936ffcbe86c7900a88aedcffc83b479aa3a402811c936140e7565b936ffe5dee046a99a2a811c461f1969c305302811c936140dd565b926fff2ea16466c96a3843ec78b326b528610260801c926140d2565b926fff973b41fa98c081472e6896dfb254c00260801c926140c9565b926fffcb9843d60f6159c9db58835c9266440260801c926140c0565b926fffe5caca7e10e4e61c3624eaa0941cd00260801c926140b7565b926ffff2e50f5f656932ef12357cf3c7fdcc0260801c926140ae565b926ffff97272373d413259a46990580e213a0260801c926140a5565b70ffffffffffffffffffffffffffffffffff70010000000000000000000000000000000061409a565b60046040517f2bc80f3a000000000000000000000000000000000000000000000000000000008152fd5b81614063565b63ffffffff80911660005260646020526020600360406000200154916024604051809481937fdd86c1010000000000000000000000000000000000000000000000000000000083528160301c16600483015260601c5afa90811561446f575b600091614457575090565b611459915060203d81116111e1576111d3818361081c565b61447761377f565b61444c565b7c010000000000000000000000000000000000000000000000000000000081116144c1577bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690565b602490604051907f1ba344530000000000000000000000000000000000000000000000000000000082526004820152fd5b7f80000000000000000000000000000000000000000000000000000000000000008114614520575b60000390565b61452861304e565b61451a565b60008113156145395790565b611459906144f2565b8015614550575b6000190490565b614558613065565b614549565b6040519061456a82610800565b600282526040366020840137565b81601f8201121561000e5780519161458f836122ea565b9261459d604051948561081c565b808452602092838086019260051b82010192831161000e578301905b8282106145c7575050505090565b83809183516145d58161066e565b8152019101906145b9565b91909160408184031261000e5780519267ffffffffffffffff9384811161000e5782019381601f8601121561000e5784519461461b866122ea565b90614629604051928361081c565b868252602096878084019160051b8301019185831161000e578801905b828210614665575050509483015190811161000e576114599201614578565b81518060060b810361000e578152908801908801614646565b6020908160408183019282815285518094520193019160005b8281106146a5575050505090565b835163ffffffff1685529381019392810192600101614697565b60060b9060060b9060008212827fffffffffffffffffffffffffffffffffffffffffffffffffff8000000000000001821281151661470d575b82667fffffffffffff01821316613bed570390565b61471561304e565b6146f8565b60060b9060060b908115614766575b60001982147fffffffffffffffffffffffffffffffffffffffffffffffffff8000000000000082141661475a570590565b61476261304e565b0590565b61476e613065565b614729565b9060060b908115614786575b60060b0790565b61478e613065565b61477f565b6000199060020b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff800000811461343e570190565b908160e091031261000e5780516147db8161066e565b9160208201516147ea81611484565b9160408101516147f9816129ed565b916060820151614808816129ed565b916080810151614817816129ed565b9160a082015160ff8116810361000e5760c0909201516114598161085a565b9063ffffffff811680156149ee576148b56001600160a01b039361487061485b61455d565b94614865866139c5565b9063ffffffff169052565b60009485918261487f876139db565b521693604051809381927f883bdbfd0000000000000000000000000000000000000000000000000000000083526004830161467e565b0381865afa8491816149c9575b5061494a57505060e0600491604051928380927f3850c7bd0000000000000000000000000000000000000000000000000000000082525afa91821561493d575b9161490b575090565b61492c915060e03d8111614936575b614924818361081c565b8101906147c5565b5050505050905090565b503d61491a565b61494561377f565b614902565b61497591925061496f614962614969614962846139db565b5160060b90565b926139c5565b906146bf565b9060060b61498c614986828461471a565b60020b90565b928260060b1291826149ab575b50506149a25790565b61145990614793565b6149c09250906149ba91614773565b60060b90565b15153880614999565b6149e69192503d8087833e6149de818361081c565b8101906145e0565b5090386148c2565b50506114599060e06001600160a01b03916004604051809481937f3850c7bd000000000000000000000000000000000000000000000000000000008352165afa908115614a41575b60009161490b575090565b614a4961377f565b614a36565b919091614a6160ff6101705416156133e7565b6000821290614a708285615b3f565b9373__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__91823b1561000e576040517ff5a284a1000000000000000000000000000000000000000000000000000000008152600481019190915263ffffffff919091166024820152604481018490526064808201526000608482018190529091829060a49082905af48015614b48575b614b35575b506000821315614b1657506115fc61068d92546001600160a01b031690565b614b1e575050565b61163361162d61068d93546001600160a01b031690565b80610c9f614b42926107a7565b38614af7565b614b5061377f565b614af2565b61068d926001600160a01b03604051937fa9059cbb0000000000000000000000000000000000000000000000000000000060208601521660248401526044830152604482526080820182811067ffffffffffffffff821117614bba575b604052614ce6565b614bc2610790565b614bb2565b909261068d93604051937f23b872dd0000000000000000000000000000000000000000000000000000000060208601526001600160a01b03809216602486015216604484015260648301526064825260a0820182811067ffffffffffffffff821117614bba57604052614ce6565b601f19601f60209267ffffffffffffffff8111614c53575b01160190565b614c5b610790565b614c4d565b9081602091031261000e57516114598161085a565b15614c7c57565b608460405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152fd5b6001600160a01b03169060405190614cfd826107e4565b6020928383527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656484840152803b15614d745760008281928287614d4f9796519301915af1614d49614db8565b90614df9565b80519081614d5c57505050565b8261068d93614d6f938301019101614c60565b614c75565b6064846040519062461bcd60e51b82526004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152fd5b3d15614de3573d90614dc982614c35565b91614dd7604051938461081c565b82523d6000602084013e565b606090565b906020611459928181520190610add565b90919015614e05575090565b815115614e155750805190602001fd5b6110929060405191829162461bcd60e51b8352602060048401526024830190610add565b614e4960ff6101705416156133e7565b8115611cee5773__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__803b1561000e576040517fd25c4a6f000000000000000000000000000000000000000000000000000000008152600481019290925260248201839052606460448301819052600090830181905290829060849082905af48015614f13575b614f00575b506000811315614ee75761068d906115fc6067546001600160a01b031690565b61068d9061163361162d6067546001600160a01b031690565b80610c9f614f0d926107a7565b38614ec7565b614f1b61377f565b614ec2565b90606091939293614f3760ff6101705416156133e7565b614f4082615bea565b828501516001600160a01b031680614ff9575b50614f8b60405195869384937fc27789d1000000000000000000000000000000000000000000000000000000008552600485016150e1565b038173__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__5af48015614fec575b60009081938291614fc6575b50606c54811061220557509190565b915050614fe291925060603d811161226557612254818361081c565b9291909238614fb7565b614ff461377f565b614fab565b61500c9061228c608088015161ffff1690565b38614f53565b9081606091031261000e578051916040602083015192015190565b9060038210156139445752565b6150d260e061016093969563ffffffff61068d966101808601998652166020850152805160020b6040850152602081015160020b60608501526040810151600f0b608085015261509a606082015160a08601906001600160a01b03169052565b608081015161ffff1660c085015260a08101511515848301526150c660c082015161010086019061502d565b01511515610120830152565b60646101408201520160019052565b61514060e061016093969563ffffffff6000966101808601998652166020850152805160020b6040850152602081015160020b60608501526040810151600f0b608085015261509a606082015160a08601906001600160a01b03169052565b60646101408201520152565b908293929161516160ff6101705416156133e7565b61516a82615bea565b6040918291615203835195869384937f140cf61e00000000000000000000000000000000000000000000000000000000855260048501608061010092959463ffffffff6000956101208501988552166020840152805160408401526001600160a01b03602082015116606084015260408101511515828401526060810151151560a08401520151151560c0820152606460e08201520152565b038173__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__5af4938415615319575b60009283956152f4575b506152388561452d565b606c5481106118c157506001600160a01b0361525e60208301516001600160a01b031690565b161515806152de575b615272575b50509190565b818101906152808251151590565b91826152c2575b821561529b575b50501561182d578061526c565b51159150816152ad575b50388061528e565b90506152bb6118818461452d565b14386152a5565b91506152cd8661452d565b6152d7825161452d565b1491615287565b506152ef6118606060830151151590565b615267565b9094508161530f9293503d84116119215761190f818361081c565b919091933861522e565b61532161377f565b615224565b919082604091031261000e576020825192015190565b608061010092959463ffffffff61068d956101208501988552166020840152805160408401526001600160a01b03602082015116606084015260408101511515828401526060810151151560a08401520151151560c0820152606460e08201520160019052565b6153b360ff6101705416156133e7565b61540d60606153cc8360005260d3602052604060002090565b604051809381927fdf19bf09000000000000000000000000000000000000000000000000000000008352600483016020606491939293604081019481520152565b038173__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__5af491821561550f575b600092839284916154e9575b50615445838561551c565b9260008513156154b757907f688f0846fe2852572c467d5e769db101b0fea55e8849406d85c9fb322b95299b9161548f866154886067546001600160a01b031690565b3390614b55565b615498816157a9565b604080519586526020860187905285015260608401523392608090a390565b6040517fef37dcc700000000000000000000000000000000000000000000000000000000815260048101869052602490fd5b91935050615505915060603d811161226557612254818361081c565b919290913861543a565b61551761377f565b61542e565b60008112817f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03831381151661557b575b817f80000000000000000000000000000000000000000000000000000000000000000383121661343e570190565b61558361304e565b61554d565b615607916155b26040926155a260ff6101705416156133e7565b60005260d3602052604060002090565b6155bb82615bea565b825193849283927fec1464960000000000000000000000000000000000000000000000000000000084526004840160409063ffffffff6064939594606083019683521660208201520152565b038173__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__5af480156156ac575b600091829161568c575b50600082131561565a5761145990615655836154886067546001600160a01b031690565b6157a9565b6040517fef37dcc700000000000000000000000000000000000000000000000000000000815260048101839052602490fd5b90506156a6915060403d81116119215761190f818361081c565b38615631565b6156b461377f565b615627565b929091926156cd60ff6101705416156133e7565b60005260d36020526040600020916156e481615bea565b606b549373__$86182d6e9eac51236f2aa8dd2a3ddeab6c$__93843b1561000e5763ffffffff9460009460c49360405197889687957fe0448f0a000000000000000000000000000000000000000000000000000000008752600487015216602485015260020b604484015260020b6064830152866084830152606460a48301525af4801561579c575b615789575b50611459816154886067546001600160a01b031690565b80610c9f615796926107a7565b38615772565b6157a461377f565b61576d565b60008113156157ce5761068d906001600160a01b0380606754169060d5541690614b55565b6157e36001600160a01b0360d55416916144f2565b813b1561000e576000916024839260405194859384927f379607f500000000000000000000000000000000000000000000000000000000845260048401525af1801561583a575b6158315750565b61068d906107a7565b61584261377f565b61582a565b6158b8602060016001600160a01b03936158878587511682906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b019301519182511683906001600160a01b031673ffffffffffffffffffffffffffffffffffffffff19825416179055565b6020810151907fffffffffffffff0000000000ffffffffffffffffffffffffffffffffffffffff77ffffffff000000000000000000000000000000000000000078ff00000000000000000000000000000000000000000000000060408654940151151560c01b169360a01b16911617179055565b919063ffffffff83166001600160a01b03841615615ac2576159746118606119e56159678463ffffffff166000526065602052604060002090565b546001600160a01b031690565b80615a87575b615a2757926159de7f52983c04d8ccd4808cd0fcb24e6e48106ecb41e803d6270c6c94a15e3ebd08d293946159d96159b061083f565b6001600160a01b03851681529185602084015263ffffffff166000526065602052604060002090565b615847565b615a2260405192839283909291604060609160808401956001600160a01b038091168552815116602085015263ffffffff6020820151168285015201511515910152565b0390a1565b615a45615967859263ffffffff166000526065602052604060002090565b6040517fa5d4d0b50000000000000000000000000000000000000000000000000000000081526001600160a01b03928316600482015291166024820152604490fd5b50615abd61186085615aac6159678563ffffffff166000526065602052604060002090565b6001600160a01b0390811691161490565b61597a565b6040517f76d8a93100000000000000000000000000000000000000000000000000000000815260006004820152602490fd5b60005260d3602052604060002090815460601c3303615b0f57565b60246040517f0504a20d000000000000000000000000000000000000000000000000000000008152336004820152fd5b63ffffffff90929192168060005260656020526040600020926001600160a01b0384541615615bb9571580615ba7575b615b765750565b602490604051907f9150f8c80000000000000000000000000000000000000000000000000000000082526004820152fd5b5060ff600184015460c01c1615615b6f565b602482604051907f6b9c1a9d0000000000000000000000000000000000000000000000000000000082526004820152fd5b63ffffffff1680600052606460205260406000206001600160a01b0381541615615c51576003015460501c60ff1615615c205750565b602490604051907fb0fdd2020000000000000000000000000000000000000000000000000000000082526004820152fd5b602482604051907fb842f5a70000000000000000000000000000000000000000000000000000000082526004820152fd5b6001600160a01b039182169116818110613bed570390565b6001600160a01b039182809216918291169204821181151516615cbb570290565b615cc361304e565b0290565b63ffffffff166000526064602052615d65611132615d546001600160a01b039361ffff600460e08760016040600020015416604051928380927f3850c7bd0000000000000000000000000000000000000000000000000000000082525afa908115615dcc575b600091615da8575b50828781168289161115615d9857615d4c91615c82565b965b16615c9a565b6001600160a01b0361271091160490565b911611615d6e57565b60046040517f07a1db07000000000000000000000000000000000000000000000000000000008152fd5b90615da291615c82565b96615d4e565b615dc0915060e03d811161493657614924818361081c565b50505050505038615d35565b615dd461377f565b615d2d565b615de1613eeb565b9063ffffffff91828216600052606d60205260406000209280845416911614600014615e2d5750600101547bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690565b61145991506143ed565b615e3f613eeb565b9063ffffffff808216600052606d60205280604060002054931690831614600014615e6b575060201c90565b6114599150613c4e9061400c565b805160051b810160209081018183015b818110615e965750505090565b80515481528201615e89565b9091615ebb92811015615ebf575b60051b81019061394f565b9091565b615ec7612db0565b615eb0565b908092918237016000815290565b60208183031261000e5780519067ffffffffffffffff821161000e570181601f8201121561000e578051615f0d81614c35565b92615f1b604051948561081c565b8184526020828401011161000e576114599160208085019101610aa856fea2646970667358221220fab82ba3138bee6136a01bfe21ef7126674facf7eb334d4ee383eaa2301b15e664736f6c634300080e0033",
  "libraries": {
    "Account": "0x61Fea7b93D977D31EF80747666F18864824E6da8"
  },
  "devdoc": {
    "errors": {
      "AccessDenied(address)": [
        {
          "params": {
            "senderAddress": "address of msg sender"
          }
        }
      ],
      "CollateralDoesNotExist(uint32)": [
        {
          "params": {
            "collateralId": "address of token"
          }
        }
      ],
      "CollateralNotAllowedForUse(uint32)": [
        {
          "params": {
            "collateralId": "address of token"
          }
        }
      ],
      "IncorrectCollateralAddress(address,address)": [
        {
          "params": {
            "correctAddress": "correct address of collateral token",
            "incorrectAddress": "incorrect address of collateral token"
          }
        }
      ],
      "InvalidCollateralAddress(address)": [
        {
          "params": {
            "invalidAddress": "invalid address of collateral token"
          }
        }
      ],
      "InvalidMulticallOperationType(uint8)": [
        {
          "params": {
            "multicallOperationType": "is the value that is out of bounds"
          }
        }
      ],
      "LowNotionalValue(uint256)": [
        {
          "params": {
            "notionalValue": "notional value of txn"
          }
        }
      ],
      "PoolDoesNotExist(uint32)": [
        {
          "params": {
            "poolId": "unitialized truncated address supplied"
          }
        }
      ],
      "PoolNotAllowedForTrade(uint32)": [
        {
          "params": {
            "poolId": "address of token"
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "createAccount()": {
        "returns": {
          "newAccountId": "- serial number of the new account created"
        }
      },
      "createAccountAndAddMargin(uint32,uint256)": {
        "params": {
          "amount": "amount of token to deposit",
          "collateralId": "truncated address of collateral token to deposit"
        },
        "returns": {
          "newAccountId": "- serial number of the new account created"
        }
      },
      "extsload(bytes32)": {
        "params": {
          "slot": "to read from."
        },
        "returns": {
          "val": "stored at the slot."
        }
      },
      "extsload(bytes32[])": {
        "params": {
          "slots": "to read from."
        },
        "returns": {
          "_0": "values stored at the slots."
        }
      },
      "getAccountMarketValueAndRequiredMargin(uint256,bool)": {
        "details": "This method can be used to check if an account is under water or not.     If accountMarketValue < requiredMargin then liquidation can take place.",
        "params": {
          "accountId": "the account id",
          "isInitialMargin": "true is initial margin, false is maintainance margin"
        },
        "returns": {
          "marketValue": "the market value of the account, due to collateral and positions",
          "requiredMargin": "margin needed due to positions"
        }
      },
      "getAccountNetProfit(uint256)": {
        "params": {
          "accountId": "the account id"
        },
        "returns": {
          "accountNetProfit": "the net profit of the account"
        }
      },
      "getAccountNetTokenPosition(uint256,uint32)": {
        "params": {
          "accountId": "the account id",
          "poolId": "the id of the pool (vETH, ... etc)"
        },
        "returns": {
          "netPosition": "the net position of the account"
        }
      },
      "getRealTwapPriceX128(uint32)": {
        "params": {
          "poolId": "the id of the pool"
        },
        "returns": {
          "realPriceX128": "the real price of the pool"
        }
      },
      "getVirtualTwapPriceX128(uint32)": {
        "params": {
          "poolId": "the id of the pool"
        },
        "returns": {
          "virtualPriceX128": "the virtual price of the pool"
        }
      },
      "initiateGovernanceTransfer(address)": {
        "params": {
          "newGovernancePending": "the new governance address"
        }
      },
      "initiateTeamMultisigTransfer(address)": {
        "params": {
          "newTeamMultisigPending": "the new team multisig address"
        }
      },
      "liquidateLiquidityPositions(uint256)": {
        "details": "removes all the active range positions and gives liquidator a percent of notional amount closed + fixedFee",
        "params": {
          "accountId": "account id"
        }
      },
      "liquidateTokenPosition(uint256,uint32)": {
        "details": "transfers the fraction of token position at a discount to current price to liquidators account and gives liquidator some fixedFee",
        "params": {
          "poolId": "truncated address of token to withdraw",
          "targetAccountId": "account id"
        },
        "returns": {
          "keeperFee": "- amount of fees transferred to keeper"
        }
      },
      "multicall(bytes[])": {
        "details": "The `msg.value` should not be trusted for any method callable from multicall.",
        "params": {
          "data": "The encoded function data for each of the calls to make to this contract"
        },
        "returns": {
          "results": "The results from each of the calls passed in via data"
        }
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "removeLimitOrder(uint256,uint32,int24,int24)": {
        "details": "checks the position of current price relative to limit order and checks limitOrderType",
        "params": {
          "accountId": "account id",
          "poolId": "truncated address of token to withdraw",
          "tickLower": "liquidity change parameters",
          "tickUpper": "liquidity change parameters"
        }
      },
      "settleProfit(uint256)": {
        "params": {
          "accountId": "account id"
        }
      },
      "swapToken(uint256,uint32,(int256,uint160,bool,bool,bool))": {
        "params": {
          "accountId": "account id",
          "poolId": "truncated address of token to withdraw",
          "swapParams": "swap parameters"
        }
      },
      "updateMargin(uint256,uint32,int256)": {
        "params": {
          "accountId": "account id",
          "amount": "amount of token to deposit",
          "collateralId": "truncated address of token to deposit"
        }
      },
      "updatePoolSettings(uint32,(uint16,uint16,uint16,uint32,bool,bool,address))": {
        "params": {
          "newSettings": "updated rage trade pool settings",
          "poolId": "rage trade pool id"
        }
      },
      "updateProfit(uint256,int256)": {
        "params": {
          "accountId": "account id",
          "amount": "amount of token to withdraw"
        }
      },
      "updateRangeOrder(uint256,uint32,(int24,int24,int128,uint160,uint16,bool,uint8,bool))": {
        "params": {
          "accountId": "account id",
          "liquidityChangeParams": "liquidity change parameters",
          "poolId": "truncated address of token to withdraw"
        }
      },
      "withdrawProtocolFee(uint256)": {
        "params": {
          "numberOfPoolsToUpdateInThisTx": "number of pools to collect fees from"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "AccessDenied(address)": [
        {
          "notice": "error to denote invalid account access"
        }
      ],
      "CannotPauseIfUnpauseInProgress()": [
        {
          "notice": "error to denote unpause is in progress, hence cannot pause"
        }
      ],
      "CannotUnpauseIfPauseInProgress()": [
        {
          "notice": "error to denote pause is in progress, hence cannot unpause"
        }
      ],
      "CollateralDoesNotExist(uint32)": [
        {
          "notice": "error to denote usage of uninitialized token"
        }
      ],
      "CollateralNotAllowedForUse(uint32)": [
        {
          "notice": "error to denote usage of unsupported collateral token"
        }
      ],
      "IncorrectCollateralAddress(address,address)": [
        {
          "notice": "error to denote incorrect address is supplied while updating collateral settings"
        }
      ],
      "InvalidCollateralAddress(address)": [
        {
          "notice": "error to denote invalid address supplied as a collateral token"
        }
      ],
      "InvalidMulticallOperationType(uint8)": [
        {
          "notice": "this is errored when the enum (uint8) value is out of bounds"
        }
      ],
      "InvalidSetting(uint256)": [
        {
          "notice": "error to denote an invalid setting for parameters"
        }
      ],
      "InvalidTokenLiquidationParameters()": [
        {
          "notice": "error to denote invalid token liquidation (fraction to liquidate> 1)"
        }
      ],
      "KeeperFeeNotPositive(int256)": [
        {
          "notice": "error to denote that keeper fee is negative or zero"
        }
      ],
      "LowNotionalValue(uint256)": [
        {
          "notice": "error to denote low notional value of txn"
        }
      ],
      "NotRageTradeFactory()": [
        {
          "notice": "error to denote that caller is not ragetrade factory"
        }
      ],
      "PoolDoesNotExist(uint32)": [
        {
          "notice": "error to denote usage of uninitialized pool"
        }
      ],
      "PoolNotAllowedForTrade(uint32)": [
        {
          "notice": "error to denote usage of unsupported pool"
        }
      ],
      "SlippageBeyondTolerance()": [
        {
          "notice": "error to denote slippage of txn beyond set threshold"
        }
      ],
      "ZeroAmount()": [
        {
          "notice": "error to denote that zero amount is passed and it's prohibited"
        }
      ]
    },
    "events": {
      "AccountCreated(address,uint256)": {
        "notice": "denotes new account creation"
      },
      "CollateralSettingsUpdated(address,(address,uint32,bool))": {
        "notice": "new collateral supported as margin"
      },
      "PoolSettingsUpdated(uint32,(uint16,uint16,uint16,uint32,bool,bool,address))": {
        "notice": "maintainance margin ratio of a pool changed"
      },
      "ProtocolSettingsUpdated((uint16,uint16,uint16,uint16,uint16,uint16,uint64,uint64),uint256,uint256,uint256)": {
        "notice": "protocol settings changed"
      }
    },
    "kind": "user",
    "methods": {
      "acceptGovernanceTransfer()": {
        "notice": "Completes governance transfer, on being called by _governancePending."
      },
      "acceptTeamMultisigTransfer()": {
        "notice": "Completes teamMultisig transfer, on being called by _teamMultisigPending."
      },
      "createAccount()": {
        "notice": "creates a new account and adds it to the accounts map"
      },
      "createAccountAndAddMargin(uint32,uint256)": {
        "notice": "creates a new account and deposits 'amount' of token associated with 'poolId'"
      },
      "extsload(bytes32)": {
        "notice": "Returns a value from the storage."
      },
      "extsload(bytes32[])": {
        "notice": "Returns multiple values from storage."
      },
      "getAccountMarketValueAndRequiredMargin(uint256,bool)": {
        "notice": "Gets the market value and required margin of an account"
      },
      "getAccountNetProfit(uint256)": {
        "notice": "Gets the net profit of an account"
      },
      "getAccountNetTokenPosition(uint256,uint32)": {
        "notice": "Gets the net position of an account"
      },
      "getRealTwapPriceX128(uint32)": {
        "notice": "Gets the real twap price from the respective oracle of the given poolId"
      },
      "getVirtualTwapPriceX128(uint32)": {
        "notice": "Gets the virtual twap price from the respective oracle of the given poolId"
      },
      "governance()": {
        "notice": "Returns the address of the current governance."
      },
      "governancePending()": {
        "notice": "Returns the address of the current governance."
      },
      "initialize(address,address,address,address,address,address,address)": {
        "notice": "SYSTEM FUNCTIONS"
      },
      "initiateGovernanceTransfer(address)": {
        "notice": "Initiates governance transfer to a new account (`newGovernancePending`)."
      },
      "initiateTeamMultisigTransfer(address)": {
        "notice": "Initiates teamMultisig transfer to a new account (`newTeamMultisigPending`)."
      },
      "liquidateLiquidityPositions(uint256)": {
        "notice": "keeper call for liquidation of range position"
      },
      "liquidateTokenPosition(uint256,uint32)": {
        "notice": "keeper call for liquidation of token position"
      },
      "multicall(bytes[])": {
        "notice": "Call multiple functions in the current contract and return the data from all of them if they all succeed"
      },
      "multicallWithSingleMarginCheck(uint256,(uint8,bytes)[])": {
        "notice": "MULTICALL"
      },
      "removeLimitOrder(uint256,uint32,int24,int24)": {
        "notice": "keeper call to remove a limit order"
      },
      "settleProfit(uint256)": {
        "notice": "settles the profit/loss made with the settlement token collateral deposits"
      },
      "swapToken(uint256,uint32,(int256,uint160,bool,bool,bool))": {
        "notice": "swaps token associated with 'poolId' by 'amount' (Long if amount>0 else Short)"
      },
      "teamMultisig()": {
        "notice": "Returns the address of the current team multisig.transferTeamMultisig"
      },
      "teamMultisigPending()": {
        "notice": "Returns the address of the current team multisig.transferTeamMultisig"
      },
      "updateCollateralSettings(address,(address,uint32,bool))": {
        "notice": "ADMIN FUNCTIONS"
      },
      "updateMargin(uint256,uint32,int256)": {
        "notice": "deposits 'amount' of token associated with 'poolId'"
      },
      "updatePoolSettings(uint32,(uint16,uint16,uint16,uint32,bool,bool,address))": {
        "notice": "updates the rage trade pool settings"
      },
      "updateProfit(uint256,int256)": {
        "notice": "withdraws 'amount' of settlement token from the profit made"
      },
      "updateRangeOrder(uint256,uint32,(int24,int24,int128,uint160,uint16,bool,uint8,bool))": {
        "notice": "updates range order of token associated with 'poolId' by 'liquidityDelta' (Adds if amount>0 else Removes)also can be used to update limitOrderType"
      },
      "withdrawProtocolFee(uint256)": {
        "notice": "withdraws protocol fees collected in the supplied wrappers to team multisig"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 26758,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "_emptySlots1",
        "offset": 0,
        "slot": "0",
        "type": "t_array(t_uint256)100_storage"
      },
      {
        "astId": 26761,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "protocol",
        "offset": 0,
        "slot": "100",
        "type": "t_struct(Info)17645_storage"
      },
      {
        "astId": 26763,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "numAccounts",
        "offset": 0,
        "slot": "210",
        "type": "t_uint256"
      },
      {
        "astId": 26768,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "accounts",
        "offset": 0,
        "slot": "211",
        "type": "t_mapping(t_uint256,t_struct(Info)13042_storage)"
      },
      {
        "astId": 26770,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "rageTradeFactoryAddress",
        "offset": 0,
        "slot": "212",
        "type": "t_address"
      },
      {
        "astId": 26773,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "insuranceFund",
        "offset": 0,
        "slot": "213",
        "type": "t_contract(IInsuranceFund)11389"
      },
      {
        "astId": 26776,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "pauseLoop",
        "offset": 0,
        "slot": "214",
        "type": "t_struct(Info)14472_storage"
      },
      {
        "astId": 26779,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "unpauseLoop",
        "offset": 0,
        "slot": "215",
        "type": "t_struct(Info)14472_storage"
      },
      {
        "astId": 26782,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "withdrawProtocolFeeLoop",
        "offset": 0,
        "slot": "216",
        "type": "t_struct(Info)14472_storage"
      },
      {
        "astId": 26786,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "_emptySlots2",
        "offset": 0,
        "slot": "217",
        "type": "t_array(t_uint256)100_storage"
      },
      {
        "astId": 93,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "_initialized",
        "offset": 0,
        "slot": "317",
        "type": "t_bool"
      },
      {
        "astId": 96,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "_initializing",
        "offset": 1,
        "slot": "317",
        "type": "t_bool"
      },
      {
        "astId": 1271,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "__gap",
        "offset": 0,
        "slot": "318",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 181,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "_paused",
        "offset": 0,
        "slot": "368",
        "type": "t_bool"
      },
      {
        "astId": 270,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "__gap",
        "offset": 0,
        "slot": "369",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 35272,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "_governance",
        "offset": 0,
        "slot": "418",
        "type": "t_address"
      },
      {
        "astId": 35274,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "_teamMultisig",
        "offset": 0,
        "slot": "419",
        "type": "t_address"
      },
      {
        "astId": 35276,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "_governancePending",
        "offset": 0,
        "slot": "420",
        "type": "t_address"
      },
      {
        "astId": 35278,
        "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
        "label": "_teamMultisigPending",
        "offset": 0,
        "slot": "421",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)100_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[100]",
        "numberOfBytes": "3200"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_array(t_uint32)8_storage": {
        "base": "t_uint32",
        "encoding": "inplace",
        "label": "uint32[8]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint32)dyn_storage": {
        "base": "t_uint32",
        "encoding": "dynamic_array",
        "label": "uint32[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint48)5_storage": {
        "base": "t_uint48",
        "encoding": "inplace",
        "label": "uint48[5]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(IERC20)4189": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(IInsuranceFund)11389": {
        "encoding": "inplace",
        "label": "contract IInsuranceFund",
        "numberOfBytes": "20"
      },
      "t_contract(IOracle)11399": {
        "encoding": "inplace",
        "label": "contract IOracle",
        "numberOfBytes": "20"
      },
      "t_contract(IUniswapV3Pool)6184": {
        "encoding": "inplace",
        "label": "contract IUniswapV3Pool",
        "numberOfBytes": "20"
      },
      "t_contract(IVPoolWrapper)11608": {
        "encoding": "inplace",
        "label": "contract IVPoolWrapper",
        "numberOfBytes": "20"
      },
      "t_contract(IVQuote)11632": {
        "encoding": "inplace",
        "label": "contract IVQuote",
        "numberOfBytes": "20"
      },
      "t_contract(IVToken)11656": {
        "encoding": "inplace",
        "label": "contract IVToken",
        "numberOfBytes": "20"
      },
      "t_enum(LimitOrderType)11856": {
        "encoding": "inplace",
        "label": "enum IClearingHouseEnums.LimitOrderType",
        "numberOfBytes": "1"
      },
      "t_int24": {
        "encoding": "inplace",
        "label": "int24",
        "numberOfBytes": "3"
      },
      "t_int256": {
        "encoding": "inplace",
        "label": "int256",
        "numberOfBytes": "32"
      },
      "t_mapping(t_uint256,t_struct(Info)13042_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Account.Info)",
        "numberOfBytes": "32",
        "value": "t_struct(Info)13042_storage"
      },
      "t_mapping(t_uint32,t_struct(Collateral)11995_storage)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => struct IClearingHouseStructures.Collateral)",
        "numberOfBytes": "32",
        "value": "t_struct(Collateral)11995_storage"
      },
      "t_mapping(t_uint32,t_struct(Info)21337_storage)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => struct VTokenPosition.Info)",
        "numberOfBytes": "32",
        "value": "t_struct(Info)21337_storage"
      },
      "t_mapping(t_uint32,t_struct(Pool)12083_storage)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => struct IClearingHouseStructures.Pool)",
        "numberOfBytes": "32",
        "value": "t_struct(Pool)12083_storage"
      },
      "t_mapping(t_uint32,t_struct(PriceCache)17607_storage)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => struct Protocol.PriceCache)",
        "numberOfBytes": "32",
        "value": "t_struct(PriceCache)17607_storage"
      },
      "t_mapping(t_uint32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint48,t_struct(Info)15527_storage)": {
        "encoding": "mapping",
        "key": "t_uint48",
        "label": "mapping(uint48 => struct LiquidityPosition.Info)",
        "numberOfBytes": "32",
        "value": "t_struct(Info)15527_storage"
      },
      "t_struct(Collateral)11995_storage": {
        "encoding": "inplace",
        "label": "struct IClearingHouseStructures.Collateral",
        "members": [
          {
            "astId": 11991,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "token",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(IERC20)4189"
          },
          {
            "astId": 11994,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "settings",
            "offset": 0,
            "slot": "1",
            "type": "t_struct(CollateralSettings)12003_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(CollateralSettings)12003_storage": {
        "encoding": "inplace",
        "label": "struct IClearingHouseStructures.CollateralSettings",
        "members": [
          {
            "astId": 11998,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "oracle",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(IOracle)11399"
          },
          {
            "astId": 12000,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "twapDuration",
            "offset": 20,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 12002,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "isAllowedForDeposit",
            "offset": 24,
            "slot": "0",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Info)13042_storage": {
        "encoding": "inplace",
        "label": "struct Account.Info",
        "members": [
          {
            "astId": 13029,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "id",
            "offset": 0,
            "slot": "0",
            "type": "t_uint96"
          },
          {
            "astId": 13031,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "owner",
            "offset": 12,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 13034,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "tokenPositions",
            "offset": 0,
            "slot": "1",
            "type": "t_struct(Set)21323_storage"
          },
          {
            "astId": 13037,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "collateralDeposits",
            "offset": 0,
            "slot": "104",
            "type": "t_struct(Set)14796_storage"
          },
          {
            "astId": 13041,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "_emptySlots",
            "offset": 0,
            "slot": "206",
            "type": "t_array(t_uint256)100_storage"
          }
        ],
        "numberOfBytes": "9792"
      },
      "t_struct(Info)14472_storage": {
        "encoding": "inplace",
        "label": "struct BatchedLoop.Info",
        "members": [
          {
            "astId": 14471,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "progress",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Info)15527_storage": {
        "encoding": "inplace",
        "label": "struct LiquidityPosition.Info",
        "members": [
          {
            "astId": 15506,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "limitOrderType",
            "offset": 0,
            "slot": "0",
            "type": "t_enum(LimitOrderType)11856"
          },
          {
            "astId": 15508,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "tickLower",
            "offset": 1,
            "slot": "0",
            "type": "t_int24"
          },
          {
            "astId": 15510,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "tickUpper",
            "offset": 4,
            "slot": "0",
            "type": "t_int24"
          },
          {
            "astId": 15512,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "liquidity",
            "offset": 7,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 15514,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "vTokenAmountIn",
            "offset": 0,
            "slot": "1",
            "type": "t_int256"
          },
          {
            "astId": 15516,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "sumALastX128",
            "offset": 0,
            "slot": "2",
            "type": "t_int256"
          },
          {
            "astId": 15518,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "sumBInsideLastX128",
            "offset": 0,
            "slot": "3",
            "type": "t_int256"
          },
          {
            "astId": 15520,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "sumFpInsideLastX128",
            "offset": 0,
            "slot": "4",
            "type": "t_int256"
          },
          {
            "astId": 15522,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "sumFeeInsideLastX128",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 15526,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "_emptySlots",
            "offset": 0,
            "slot": "6",
            "type": "t_array(t_uint256)100_storage"
          }
        ],
        "numberOfBytes": "3392"
      },
      "t_struct(Info)17645_storage": {
        "encoding": "inplace",
        "label": "struct Protocol.Info",
        "members": [
          {
            "astId": 17612,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "pools",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint32,t_struct(Pool)12083_storage)"
          },
          {
            "astId": 17617,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "collaterals",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint32,t_struct(Collateral)11995_storage)"
          },
          {
            "astId": 17620,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "poolIds",
            "offset": 0,
            "slot": "2",
            "type": "t_array(t_uint32)dyn_storage"
          },
          {
            "astId": 17623,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "settlementToken",
            "offset": 0,
            "slot": "3",
            "type": "t_contract(IERC20)4189"
          },
          {
            "astId": 17626,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "vQuote",
            "offset": 0,
            "slot": "4",
            "type": "t_contract(IVQuote)11632"
          },
          {
            "astId": 17629,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "liquidationParams",
            "offset": 0,
            "slot": "5",
            "type": "t_struct(LiquidationParams)12064_storage"
          },
          {
            "astId": 17631,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "minRequiredMargin",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 17633,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "removeLimitOrderFee",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 17635,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "minimumOrderNotional",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 17640,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "priceCache",
            "offset": 0,
            "slot": "9",
            "type": "t_mapping(t_uint32,t_struct(PriceCache)17607_storage)"
          },
          {
            "astId": 17644,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "_emptySlots",
            "offset": 0,
            "slot": "10",
            "type": "t_array(t_uint256)100_storage"
          }
        ],
        "numberOfBytes": "3520"
      },
      "t_struct(Info)21337_storage": {
        "encoding": "inplace",
        "label": "struct VTokenPosition.Info",
        "members": [
          {
            "astId": 21325,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "balance",
            "offset": 0,
            "slot": "0",
            "type": "t_int256"
          },
          {
            "astId": 21327,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "netTraderPosition",
            "offset": 0,
            "slot": "1",
            "type": "t_int256"
          },
          {
            "astId": 21329,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "sumALastX128",
            "offset": 0,
            "slot": "2",
            "type": "t_int256"
          },
          {
            "astId": 21332,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "liquidityPositions",
            "offset": 0,
            "slot": "3",
            "type": "t_struct(Set)15503_storage"
          },
          {
            "astId": 21336,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "_emptySlots",
            "offset": 0,
            "slot": "105",
            "type": "t_array(t_uint256)100_storage"
          }
        ],
        "numberOfBytes": "6560"
      },
      "t_struct(LiquidationParams)12064_storage": {
        "encoding": "inplace",
        "label": "struct IClearingHouseStructures.LiquidationParams",
        "members": [
          {
            "astId": 12049,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "rangeLiquidationFeeFraction",
            "offset": 0,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 12051,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "tokenLiquidationFeeFraction",
            "offset": 2,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 12053,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "closeFactorMMThresholdBps",
            "offset": 4,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 12055,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "partialLiquidationCloseFactorBps",
            "offset": 6,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 12057,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "insuranceFundFeeShareBps",
            "offset": 8,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 12059,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "liquidationSlippageSqrtToleranceBps",
            "offset": 10,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 12061,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "maxRangeLiquidationFees",
            "offset": 12,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 12063,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "minNotionalLiquidatable",
            "offset": 20,
            "slot": "0",
            "type": "t_uint64"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Pool)12083_storage": {
        "encoding": "inplace",
        "label": "struct IClearingHouseStructures.Pool",
        "members": [
          {
            "astId": 12073,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "vToken",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(IVToken)11656"
          },
          {
            "astId": 12076,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "vPool",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(IUniswapV3Pool)6184"
          },
          {
            "astId": 12079,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "vPoolWrapper",
            "offset": 0,
            "slot": "2",
            "type": "t_contract(IVPoolWrapper)11608"
          },
          {
            "astId": 12082,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "settings",
            "offset": 0,
            "slot": "3",
            "type": "t_struct(PoolSettings)12099_storage"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(PoolSettings)12099_storage": {
        "encoding": "inplace",
        "label": "struct IClearingHouseStructures.PoolSettings",
        "members": [
          {
            "astId": 12085,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "initialMarginRatioBps",
            "offset": 0,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 12087,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "maintainanceMarginRatioBps",
            "offset": 2,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 12089,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "maxVirtualPriceDeviationRatioBps",
            "offset": 4,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 12091,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "twapDuration",
            "offset": 6,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 12093,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "isAllowedForTrade",
            "offset": 10,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 12095,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "isCrossMargined",
            "offset": 11,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 12098,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "oracle",
            "offset": 12,
            "slot": "0",
            "type": "t_contract(IOracle)11399"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(PriceCache)17607_storage": {
        "encoding": "inplace",
        "label": "struct Protocol.PriceCache",
        "members": [
          {
            "astId": 17600,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "updateBlockNumber",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 17602,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "virtualPriceX128",
            "offset": 4,
            "slot": "0",
            "type": "t_uint224"
          },
          {
            "astId": 17604,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "realPriceX128",
            "offset": 0,
            "slot": "1",
            "type": "t_uint224"
          },
          {
            "astId": 17606,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "isDeviationBreached",
            "offset": 28,
            "slot": "1",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Set)14796_storage": {
        "encoding": "inplace",
        "label": "struct CollateralDeposit.Set",
        "members": [
          {
            "astId": 14787,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "active",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_uint32)8_storage"
          },
          {
            "astId": 14791,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "deposits",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint32,t_uint256)"
          },
          {
            "astId": 14795,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "_emptySlots",
            "offset": 0,
            "slot": "2",
            "type": "t_array(t_uint256)100_storage"
          }
        ],
        "numberOfBytes": "3264"
      },
      "t_struct(Set)15503_storage": {
        "encoding": "inplace",
        "label": "struct LiquidityPosition.Set",
        "members": [
          {
            "astId": 15493,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "active",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_uint48)5_storage"
          },
          {
            "astId": 15498,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "positions",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint48,t_struct(Info)15527_storage)"
          },
          {
            "astId": 15502,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "_emptySlots",
            "offset": 0,
            "slot": "2",
            "type": "t_array(t_uint256)100_storage"
          }
        ],
        "numberOfBytes": "3264"
      },
      "t_struct(Set)21323_storage": {
        "encoding": "inplace",
        "label": "struct VTokenPosition.Set",
        "members": [
          {
            "astId": 21311,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "active",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_uint32)8_storage"
          },
          {
            "astId": 21316,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "positions",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint32,t_struct(Info)21337_storage)"
          },
          {
            "astId": 21318,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "vQuoteBalance",
            "offset": 0,
            "slot": "2",
            "type": "t_int256"
          },
          {
            "astId": 21322,
            "contract": "contracts/protocol/clearinghouse/ClearingHouse.sol:ClearingHouse",
            "label": "_emptySlots",
            "offset": 0,
            "slot": "3",
            "type": "t_array(t_uint256)100_storage"
          }
        ],
        "numberOfBytes": "3296"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint224": {
        "encoding": "inplace",
        "label": "uint224",
        "numberOfBytes": "28"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint48": {
        "encoding": "inplace",
        "label": "uint48",
        "numberOfBytes": "6"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint96": {
        "encoding": "inplace",
        "label": "uint96",
        "numberOfBytes": "12"
      }
    }
  }
}